<?xml version="1.0"?>
<doc>
    <assembly>
        <name>com.Tivadar.Best.HTTP</name>
    </assembly>
    <members>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves">
            <summary>Elliptic curve registry for ANSSI.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetByName(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetByOid(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetByOidLazy(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetName(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetOid(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.Names">
            <summary>Enumerate the available curve names in this registry.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1BitStringParser.GetBitStream">
            <summary>Return a <see cref="T:System.IO.Stream"/> representing the contents of the BIT STRING. The final byte, if any,
            may include pad bits. See <see cref="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1BitStringParser.PadBits"/>.</summary>
            <returns>A <see cref="T:System.IO.Stream"/> with its source as the BIT STRING content.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1BitStringParser.GetOctetStream">
            <summary>Return a <see cref="T:System.IO.Stream"/> representing the contents of the BIT STRING, where the content is
            expected to be octet-aligned (this will be automatically checked during parsing).</summary>
            <returns>A <see cref="T:System.IO.Stream"/> with its source as the BIT STRING content.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1BitStringParser.PadBits">
            <summary>Return the number of pad bits, if any, in the final byte, if any, read from
            <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1BitStringParser.GetBitStream"/>.</summary>
            <remarks>
            This number is in the range zero to seven. That number of the least significant bits of the final byte, if
            any, are not part of the contents and should be ignored. NOTE: Must be called AFTER the stream has been
            fully processed. (Does not need to be called if <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1BitStringParser.GetOctetStream"/> was used instead of
            <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1BitStringParser.GetBitStream"/>.
            </remarks>
            <returns>The number of pad bits. In the range zero to seven.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable.GetDerEncoded">
             Return the DER encoding of the object, null if the DER encoding can not be made.
            
             @return a DER byte array, null otherwise.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1EncodableVector">
            Mutable class for building ASN.1 constructed objects such as SETs or SEQUENCEs.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1GeneralizedTime">
            <summary>GeneralizedTime ASN.1 type</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1InputStream">
            a general purpose ASN.1 decoder - note: this class differs from the
            others in that it returns null after it has read the last object in
            the stream. If an ASN.1 Null is encountered a Der/BER Null object is
            returned.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.Byte[])">
             Create an ASN1InputStream based on the input byte array. The length of DER objects in
             the stream is automatically limited to the length of the input array.
            
             @param input array containing ASN.1 encoded data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.IO.Stream,System.Int32)">
             Create an ASN1InputStream where no DER object will be longer than limit.
            
             @param input stream containing ASN.1 encoded data.
             @param limit maximum size of a DER encoded object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1InputStream.BuildObject(System.Int32,System.Int32,System.Int32)">
            build an object given its tag and the number of bytes to construct it from.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Null">
            A Null object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Object.FromByteArray(System.Byte[])">
            <summary>Create a base ASN.1 object from a byte array.</summary>
            <param name="data">The byte array to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">
            If there is a problem parsing the data, or parsing an object did not exhaust the available data.
            </exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Object.FromStream(System.IO.Stream)">
            <summary>Read a base ASN.1 object from a stream.</summary>
            <param name="inStr">The stream to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1ObjectDescriptor.GetInstance(System.Object)">
             Return an ObjectDescriptor from the passed in object.
            
             @param obj an ASN1ObjectDescriptor or an object that can be converted into one.
             @exception IllegalArgumentException if the object cannot be converted.
             @return an ASN1ObjectDescriptor instance, or null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1ObjectDescriptor.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return an ObjectDescriptor from a tagged object.
            
             @param taggedObject the tagged object holding the object we want.
             @param declaredExplicit true if the object is meant to be explicitly tagged, false otherwise.
             @exception IllegalArgumentException if the tagged object cannot be converted.
             @return an ASN1ObjectDescriptor instance, or null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1OctetString.GetInstance(System.Object)">
             return an Octet string from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1OctetString.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an octet string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want.
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1OctetString.#ctor(System.Byte[])">
            @param string the octets making up the octet string.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1OctetStringParser.GetOctetStream">
            <summary>Return the content of the OCTET STRING as a <see cref="T:System.IO.Stream"/>.</summary>
            <returns>A <see cref="T:System.IO.Stream"/> represnting the OCTET STRING's content.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence.GetInstance(System.Object)">
             return an Asn1Sequence from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return an ASN1 sequence from a tagged object. There is a special
             case here, if an object appears to have been explicitly tagged on
             reading but we were expecting it to be implicitly tagged in the
             normal course of events it indicates that we lost the surrounding
             sequence - so we need to add it back (this will happen if the tagged
             object is a sequence that contains other sequences). If you are
             dealing with implicitly tagged sequences you really <b>should</b>
             be using this method.
            
             @param taggedObject the tagged object.
             @param declaredExplicit true if the object is meant to be explicitly tagged, false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence.Item(System.Int32)">
             return the object at the sequence position indicated by index.
            
             @param index the sequence number (starting at zero) of the object
             @return the object at the sequence position indicated by index.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Set.GetInstance(System.Object)">
             return an ASN1Set from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Set.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return an ASN1 set from a tagged object. There is a special
             case here, if an object appears to have been explicitly tagged on
             reading but we were expecting it to be implicitly tagged in the
             normal course of events it indicates that we lost the surrounding
             set - so we need to add it back (this will happen if the tagged
             object is a sequence that contains other sequences). If you are
             dealing with implicitly tagged sets you really <b>should</b>
             be using this method.
            
             @param taggedObject the tagged object.
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Set.Item(System.Int32)">
             return the object at the set position indicated by index.
            
             @param index the set number (starting at zero) of the object
             @return the object at the set position indicated by index.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject">
            ASN.1 TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject.#ctor(System.Boolean,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param explicitly true if the object is explicitly tagged.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject.IsExplicit">
            return whether or not the object may be explicitly tagged.
            <p>
            Note: if the object has been read from an input stream, the only
            time you can be sure if isExplicit is returning the true state of
            affairs is if it returns false. An implicitly tagged object may appear
            to be explicitly tagged, so you need to understand the context under
            which the reading was done as well, see GetObject below.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject.GetObject">
            return whatever was following the tag.
            <p>
            Note: tagged objects are generally context dependent if you're
            trying to extract a tagged object you should be going via the
            appropriate GetInstance method.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject.GetBaseObject">
            Needed for open types, until we have better type-guided parsing support. Use sparingly for other
            purposes, and prefer {@link #getExplicitBaseTagged()}, {@link #getImplicitBaseTagged(int, int)} or
            {@link #getBaseUniversal(boolean, int)} where possible. Before using, check for matching tag
            {@link #getTagClass() class} and {@link #getTagNo() number}.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject.GetExplicitBaseObject">
            Needed for open types, until we have better type-guided parsing support. Use
            sparingly for other purposes, and prefer {@link #getExplicitBaseTagged()} or
            {@link #getBaseUniversal(boolean, int)} where possible. Before using, check
            for matching tag {@link #getTagClass() class} and {@link #getTagNo() number}.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser.ParseBaseUniversal(System.Boolean,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser.ParseExplicitBaseObject">
            <summary>Needed for open types, until we have better type-guided parsing support.</summary>
            <remarks>
            Use sparingly for other purposes, and prefer <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser.ParseExplicitBaseTagged"/> or
            <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser.ParseBaseUniversal(System.Boolean,System.Int32)"/> where possible. Before using, check for matching tag
            <see cref="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser.TagClass">class</see> and <see cref="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser.TagNo">number</see>.
            </remarks>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser.ParseExplicitBaseTagged">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser.ParseImplicitBaseTagged(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1UniversalType.FromByteArray(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1UtcTime">
            <summary>UTCTime ASN.1 type</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1UtcTime.GetInstance(System.Object)">
             return a UTC Time from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1UtcTime.ToAdjustedDateTime">
            <summary>Return an adjusted date in the range of 1950 - 2049.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Utilities.ParseExplicitBaseTagged(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Utilities.ParseExplicitContextBaseTagged(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Utilities.TryParseExplicitBaseTagged(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Utilities.TryParseExplicitContextBaseTagged(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Utilities.ParseImplicitBaseTagged(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Utilities.ParseImplicitContextBaseTagged(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Utilities.TryParseImplicitBaseTagged(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Utilities.TryParseImplicitContextBaseTagged(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Utilities.ParseBaseUniversal(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32,System.Boolean,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Utilities.ParseContextBaseUniversal(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Boolean,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Utilities.TryParseBaseUniversal(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32,System.Boolean,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Utilities.TryParseContextBaseUniversal(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Boolean,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Utilities.ParseExplicitBaseObject(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Utilities.ParseExplicitContextBaseObject(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Utilities.TryParseExplicitBaseObject(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Utilities.TryParseExplicitContextBaseObject(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc">
            iso.org.dod.internet.private.enterprise.legion-of-the-bouncy-castle
            <p>1.3.6.1.4.1.22554</p>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe">
            pbe(1) algorithms
            <p>1.3.6.1.4.1.22554.1</p>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1">
            SHA-1(1)
            <p>1.3.6.1.4.1.22554.1.1</p>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256">
            SHA-2.SHA-256; 1.3.6.1.4.1.22554.1.2.1 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha384">
            SHA-2.SHA-384; 1.3.6.1.4.1.22554.1.2.2 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha512">
            SHA-2.SHA-512; 1.3.6.1.4.1.22554.1.2.3 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha224">
            SHA-2.SHA-224; 1.3.6.1.4.1.22554.1.2.4 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1_pkcs5">
            PKCS-5(1)|PKCS-12(2)
            SHA-1.PKCS5;  1.3.6.1.4.1.22554.1.1.1 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1_pkcs12">
            SHA-1.PKCS12; 1.3.6.1.4.1.22554.1.1.2 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256_pkcs5">
            SHA-256.PKCS12; 1.3.6.1.4.1.22554.1.2.1.1 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256_pkcs12">
            SHA-256.PKCS12; 1.3.6.1.4.1.22554.1.2.1.2 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes128_cbc">
            AES(1) . (CBC-128(2)|CBC-192(22)|CBC-256(42))
            1.3.6.1.4.1.22554.1.1.2.1.2 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes192_cbc">
            1.3.6.1.4.1.22554.1.1.2.1.22 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes256_cbc">
            1.3.6.1.4.1.22554.1.1.2.1.42 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes128_cbc">
            1.3.6.1.4.1.22554.1.1.2.2.2 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes192_cbc">
            1.3.6.1.4.1.22554.1.1.2.2.22 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes256_cbc">
            1.3.6.1.4.1.22554.1.1.2.2.42 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_sig">
            signature(2) algorithms
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.sphincs256">
            Sphincs-256
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.xmss">
            XMSS
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.xmss_mt">
            XMSS^MT
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.sphincsPlus">
            SPHINCS+
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.picnic">
            Picnic
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_exch">
            key_exchange(3) algorithms
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.newHope">
            NewHope
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_ext">
            X.509 extension(4) values
            <p/>
            1.3.6.1.4.1.22554.4
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_kem">
            KEM(4) algorithms
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.pqc_kem_mceliece">
            Classic McEliece
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.pqc_kem_saber">
            SABER
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.pqc_kem_sike">
            SIKE
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.pqc_kem_kyber">
            Kyber
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.pqc_kem_bike">
            BIKE
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.pqc_kem_hqc">
            HQC
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BC.LinkedCertificate">
            Extension to tie an alternate certificate to the containing certificate.
            <pre>
                LinkedCertificate := SEQUENCE {
                    digest        DigestInfo,                   -- digest of PQC certificate
                    certLocation  GeneralName,                  -- location of PQC certificate
                    certIssuer    [0] Name OPTIONAL,            -- issuer of PQC cert (if different from current certificate)
                    cACerts       [1] GeneralNames OPTIONAL,    -- CA certificates for PQC cert (one of more locations)
            }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BerBitStringParser">
            <summary>A parser for indefinite-length BIT STRINGs.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BerSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BerSequence.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BerSequence.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing two objects
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BerSequence.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BerSet.#ctor">
            create an empty set
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BerSet.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a set containing one object
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BerSet.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a set containing a vector of objects.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BerTaggedObject">
            BER TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BerTaggedObject.#ctor(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.BerTaggedObject.#ctor(System.Boolean,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param isExplicit true if an explicitly tagged object.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers">
            <remarks>See https://www.bsi.bund.de/cae/servlet/contentblob/471398/publicationFile/30615/BSI-TR-03111_pdf.pdf</remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.algorithm">
            0.4.0.127.0.7.1 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.ecka_eg_X963kdf">
            ElGamal Elliptic Curve Key Agreement and Key Derivation according to X963 OID: 0.4.0.127.0.7.1.1.5.1.1 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.ecka_eg_X963kdf_SHA1">
            ElGamal Elliptic Curve Key Agreement and Key Derivation according to X963
            with hash function SHA-1
            OID: 0.4.0.127.0.7.1.1.5.1.1.1 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.ecka_eg_X963kdf_SHA224">
            ElGamal Elliptic Curve Key Agreement and Key Derivation according to X963
            with hash function SHA224
            OID: 0.4.0.127.0.7.1.1.5.1.1.2 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.ecka_eg_X963kdf_SHA256">
            ElGamal Elliptic Curve Key Agreement and Key Derivation according to X963
            with hash function SHA256
            OID: 0.4.0.127.0.7.1.1.5.1.1.3 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.ecka_eg_X963kdf_SHA384">
            ElGamal Elliptic Curve Key Agreement and Key Derivation according to X963
            with hash function SHA384
            OID: 0.4.0.127.0.7.1.1.5.1.1.4 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.ecka_eg_X963kdf_SHA512">
            ElGamal Elliptic Curve Key Agreement and Key Derivation according to X963
            with hash function SHA512
            OID: 0.4.0.127.0.7.1.1.5.1.1.5 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.ecka_eg_X963kdf_RIPEMD160">
            ElGamal Elliptic Curve Key Agreement and Key Derivation according to X963
            with hash function RIPEMD160
            OID: 0.4.0.127.0.7.1.1.5.1.1.6 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.ecka_eg_SessionKDF">
            Key Derivation Function for Session Keys
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CAKeyUpdAnnContent.ToAsn1Object">
            <pre>
            CAKeyUpdAnnContent ::= SEQUENCE {
                                        oldWithNew   CmpCertificate, -- old pub signed with new priv
                                        newWithOld   CmpCertificate, -- new pub signed with old priv
                                        newWithNew   CmpCertificate  -- new pub signed with new priv
             }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CertAnnContent">
            CertAnnContent ::= CMPCertificate
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CertConfirmContent.ToAsn1Object">
            <pre>
            CertConfirmContent ::= SEQUENCE OF CertStatus
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CertifiedKeyPair.ToAsn1Object">
            <pre>
            CertifiedKeyPair ::= SEQUENCE {
                                             certOrEncCert       CertOrEncCert,
                                             privateKey      [0] EncryptedValue      OPTIONAL,
                                             -- see [CRMF] for comment on encoding
                                             publicationInfo [1] PKIPublicationInfo  OPTIONAL
                  }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CertOrEncCert.ToAsn1Object">
            <pre>
            CertOrEncCert ::= CHOICE {
                                 certificate     [0] CMPCertificate,
                                 encryptedCert   [1] EncryptedKey
                      }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CertRepMessage.ToAsn1Object">
            <pre>
            CertRepMessage ::= SEQUENCE {
                                     caPubs       [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
                                                                                        OPTIONAL,
                                     response         SEQUENCE OF CertResponse
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CertReqTemplateContent">
            GenMsg:    {id-it 19}, &lt; absent &gt;
            GenRep:    {id-it 19}, CertReqTemplateContent | &lt; absent &gt;
            <p>
            CertReqTemplateValue  ::= CertReqTemplateContent
            </p><p>
            CertReqTemplateContent ::= SEQUENCE {
            certTemplate           CertTemplate,
            keySpec                Controls OPTIONAL }
            </p><p>
            Controls  ::= SEQUENCE SIZE (1..MAX) OF AttributeTypeAndValue
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CertResponse.ToAsn1Object">
            <pre>
            CertResponse ::= SEQUENCE {
                                       certReqId           INTEGER,
                                       -- to match this response with corresponding request (a value
                                       -- of -1 is to be used if certReqId is not specified in the
                                       -- corresponding request)
                                       status              PKIStatusInfo,
                                       certifiedKeyPair    CertifiedKeyPair    OPTIONAL,
                                       rspInfo             OCTET STRING        OPTIONAL
                                       -- analogous to the id-regInfo-utf8Pairs string defined
                                       -- for regInfo in CertReqMsg [CRMF]
                        }
            </pre> 
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CertStatus.ToAsn1Object">
             <pre>
            
              CertStatus ::= SEQUENCE {
                 certHash    OCTET STRING,
                 certReqId   INTEGER,
                 statusInfo  PKIStatusInfo OPTIONAL,
                 hashAlg [0] AlgorithmIdentifier{DIGEST-ALGORITHM, {...}} OPTIONAL
               }
            
             </pre>
            
             @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.Challenge">
             <pre>
             Challenge ::= SEQUENCE {
                      owf                 AlgorithmIdentifier  OPTIONAL,
            
                      -- MUST be present in the first Challenge; MAY be omitted in
                      -- any subsequent Challenge in POPODecKeyChallContent (if
                      -- omitted, then the owf used in the immediately preceding
                      -- Challenge is to be used).
            
                      witness             OCTET STRING,
                      -- the result of applying the one-way function (owf) to a
                      -- randomly-generated INTEGER, A.  [Note that a different
                      -- INTEGER MUST be used for each Challenge.]
                      challenge           OCTET STRING
                      -- the encryption (under the public key for which the cert.
                      -- request is being made) of Rand, where Rand is specified as
                      --   Rand ::= SEQUENCE {
                      --      int      INTEGER,
                      --       - the randomly-generated INTEGER A (above)
                      --      sender   GeneralName
                      --       - the sender's name (as included in PKIHeader)
                      --   }
                  }
                  </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.Challenge.ToAsn1Object">
             <pre>
             Challenge ::= SEQUENCE {
                             owf                 AlgorithmIdentifier  OPTIONAL,
            
                             -- MUST be present in the first Challenge; MAY be omitted in
                             -- any subsequent Challenge in POPODecKeyChallContent (if
                             -- omitted, then the owf used in the immediately preceding
                             -- Challenge is to be used).
            
                             witness             OCTET STRING,
                             -- the result of applying the one-way function (owf) to a
                             -- randomly-generated INTEGER, A.  [Note that a different
                             -- INTEGER MUST be used for each Challenge.]
                             challenge           OCTET STRING
                             -- the encryption (under the public key for which the cert.
                             -- request is being made) of Rand, where Rand is specified as
                             --   Rand ::= SEQUENCE {
                             --      int      INTEGER,
                             --       - the randomly-generated INTEGER A (above)
                             --      sender   GeneralName
                             --       - the sender's name (as included in PKIHeader)
                             --   }
                  }
             </pre>
             @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.Challenge.Rand">
            Rand is the inner type
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpCertificate.#ctor(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
             Note: the addition of other certificates is a BC extension. If you use this constructor they
             will be added with an explicit tag value of type.
            
             @param type      the type of the certificate (used as a tag value).
             @param otherCert the object representing the certificate
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpCertificate.ToAsn1Object">
             <pre>
             CMPCertificate ::= CHOICE {
                        x509v3PKCert        Certificate
                        x509v2AttrCert      [1] AttributeCertificate
              }
             </pre>
             Note: the addition of attribute certificates is a BC extension.
            
             @return a basic ASN.1 object representation.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.passwordBasedMac">
            id-PasswordBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 13}
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.dhBasedMac">
            id-DHBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 30}
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.it_caProtEncCert">
            RFC 4120: it-id: PKIX.4 = 1.3.6.1.5.5.7.4 
            RFC 4120: 1.3.6.1.5.5.7.4.1
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.it_signKeyPairTypes">
            RFC 4120: 1.3.6.1.5.5.7.4.2
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.it_encKeyPairTypes">
            RFC 4120: 1.3.6.1.5.5.7.4.3
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.it_preferredSymAlg">
            RFC 4120: 1.3.6.1.5.5.7.4.4
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.it_caKeyUpdateInfo">
            RFC 4120: 1.3.6.1.5.5.7.4.5
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.it_currentCRL">
            RFC 4120: 1.3.6.1.5.5.7.4.6
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.it_unsupportedOIDs">
            RFC 4120: 1.3.6.1.5.5.7.4.7
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.it_keyPairParamReq">
            RFC 4120: 1.3.6.1.5.5.7.4.10
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.it_keyPairParamRep">
            RFC 4120: 1.3.6.1.5.5.7.4.11
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.it_revPassphrase">
            RFC 4120: 1.3.6.1.5.5.7.4.12
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.it_implicitConfirm">
            RFC 4120: 1.3.6.1.5.5.7.4.13
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.it_confirmWaitTime">
            RFC 4120: 1.3.6.1.5.5.7.4.14
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.it_origPKIMessage">
            RFC 4120: 1.3.6.1.5.5.7.4.15
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.it_suppLangTags">
            RFC 4120: 1.3.6.1.5.5.7.4.16
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.id_it_caCerts">
            Update 16, RFC 4210
            {id-it 17}
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.id_it_rootCaKeyUpdate">
            Update 16, RFC 4210
            GenRep:    {id-it 18}, RootCaKeyUpdateContent
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.id_it_certReqTemplate">
            Update 16, RFC 4210
            {id-it 19}
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.id_it_rootCaCert">
            Update 16, RFC 4210
            GenMsg:    {id-it 20}, RootCaCertValue
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.id_it_certProfile">
            Update-16 to RFC 4210
            id-it-certProfile  OBJECT IDENTIFIER ::= {id-it 21}
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.id_pkip">
            RFC 4211: it-pkip: PKIX.5 = 1.3.6.1.5.5.7.5
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.id_regCtrl">
            RFC 4211: it-regCtrl: 1.3.6.1.5.5.7.5.1
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.id_regInfo">
            RFC 4211: it-regInfo: 1.3.6.1.5.5.7.5.2
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.regCtrl_regToken">
            1.3.6.1.5.5.7.5.1.1
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.regCtrl_authenticator">
            1.3.6.1.5.5.7.5.1.2
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.regCtrl_pkiPublicationInfo">
            1.3.6.1.5.5.7.5.1.3
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.regCtrl_pkiArchiveOptions">
            1.3.6.1.5.5.7.5.1.4
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.regCtrl_oldCertID">
            1.3.6.1.5.5.7.5.1.5
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.regCtrl_protocolEncrKey">
            1.3.6.1.5.5.7.5.1.6
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.regCtrl_altCertTemplate">
            From RFC4210:
            id-regCtrl-altCertTemplate OBJECT IDENTIFIER ::= {id-regCtrl 7}; 1.3.6.1.5.5.7.1.7
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.regInfo_utf8Pairs">
            RFC 4211: it-regInfo-utf8Pairs: 1.3.6.1.5.5.7.5.2.1
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.regInfo_certReq">
            RFC 4211: it-regInfo-certReq: 1.3.6.1.5.5.7.5.2.1
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.ct_encKeyWithID">
            1.2.840.113549.1.9.16.1.21
            <p>
            id-ct   OBJECT IDENTIFIER ::= { id-smime  1 }  -- content types
            </p><p>
            id-ct-encKeyWithID OBJECT IDENTIFIER ::= {id-ct 21}
            </p>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.id_regCtrl_algId">
            id-regCtrl-algId OBJECT IDENTIFIER ::= { iso(1)
            identified-organization(3) dod(6) internet(1) security(5)
            mechanisms(5) pkix(7) pkip(5) regCtrl(1) 11 }
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers.id_regCtrl_rsaKeyLen">
            id-regCtrl-rsaKeyLen OBJECT IDENTIFIER ::= { iso(1)
            identified-organization(3) dod(6) internet(1) security(5)
            mechanisms(5) pkix(7) pkip(5) regCtrl(1) 12 }
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CrlAnnContent.ToAsn1Object">
            <pre>
            CrlAnnContent ::= SEQUENCE OF CertificateList
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CrlSource">
            GenMsg:    {id-it TBD1}, SEQUENCE SIZE (1..MAX) OF CRLStatus
            GenRep:    {id-it TBD2}, SEQUENCE SIZE (1..MAX) OF
            CertificateList  |  &lt; absent &gt;
            <p>
            CRLSource ::= CHOICE {
            dpn          [0] DistributionPointName,
            issuer       [1] GeneralNames }
            </p>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CrlStatus">
            CRLStatus ::= SEQUENCE {
            source       CRLSource,
            thisUpdate   Time OPTIONAL }
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.DhbmParameter">
            DHBMParameter ::= SEQUENCE {
            owf                 AlgorithmIdentifier,
            -- AlgId for a One-Way Function (SHA-1 recommended)
            mac                 AlgorithmIdentifier
            -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
            }   -- or HMAC [RFC2104, RFC2202])
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.ErrorMsgContent">
            <pre>
                 ErrorMsgContent ::= SEQUENCE {
                     pKIStatusInfo          PKIStatusInfo,
                     errorCode              INTEGER           OPTIONAL,
                     -- implementation-specific error codes
                     errorDetails           PKIFreeText       OPTIONAL
                     -- implementation-specific error details
                 }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.ErrorMsgContent.ToAsn1Object">
            <pre>
            ErrorMsgContent ::= SEQUENCE {
                                   pKIStatusInfo          PKIStatusInfo,
                                   errorCode              INTEGER           OPTIONAL,
                                   -- implementation-specific error codes
                                   errorDetails           PKIFreeText       OPTIONAL
                                   -- implementation-specific error details
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.GenMsgContent">
            <pre>GenMsgContent ::= SEQUENCE OF InfoTypeAndValue</pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.GenMsgContent.ToAsn1Object">
            <pre>
            GenMsgContent ::= SEQUENCE OF InfoTypeAndValue
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.GenRepContent.ToAsn1Object">
            <pre>
            GenRepContent ::= SEQUENCE OF InfoTypeAndValue
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.InfoTypeAndValue">
             Example InfoTypeAndValue contents include, but are not limited
             to, the following (un-comment in this ASN.1 module and use as
             appropriate for a given environment):
             <pre>
               id-it-caProtEncCert    OBJECT IDENTIFIER ::= {id-it 1}
                  CAProtEncCertValue      ::= CMPCertificate
               id-it-signKeyPairTypes OBJECT IDENTIFIER ::= {id-it 2}
                 SignKeyPairTypesValue   ::= SEQUENCE OF AlgorithmIdentifier
               id-it-encKeyPairTypes  OBJECT IDENTIFIER ::= {id-it 3}
                 EncKeyPairTypesValue    ::= SEQUENCE OF AlgorithmIdentifier
               id-it-preferredSymmAlg OBJECT IDENTIFIER ::= {id-it 4}
                  PreferredSymmAlgValue   ::= AlgorithmIdentifier
               id-it-caKeyUpdateInfo  OBJECT IDENTIFIER ::= {id-it 5}
                  CAKeyUpdateInfoValue    ::= CAKeyUpdAnnContent
               id-it-currentCRL       OBJECT IDENTIFIER ::= {id-it 6}
                  CurrentCRLValue         ::= CertificateList
               id-it-unsupportedOIDs  OBJECT IDENTIFIER ::= {id-it 7}
                  UnsupportedOIDsValue    ::= SEQUENCE OF OBJECT IDENTIFIER
               id-it-keyPairParamReq  OBJECT IDENTIFIER ::= {id-it 10}
                  KeyPairParamReqValue    ::= OBJECT IDENTIFIER
               id-it-keyPairParamRep  OBJECT IDENTIFIER ::= {id-it 11}
                  KeyPairParamRepValue    ::= AlgorithmIdentifer
               id-it-revPassphrase    OBJECT IDENTIFIER ::= {id-it 12}
                  RevPassphraseValue      ::= EncryptedValue
               id-it-implicitConfirm  OBJECT IDENTIFIER ::= {id-it 13}
                  ImplicitConfirmValue    ::= NULL
               id-it-confirmWaitTime  OBJECT IDENTIFIER ::= {id-it 14}
                  ConfirmWaitTimeValue    ::= GeneralizedTime
               id-it-origPKIMessage   OBJECT IDENTIFIER ::= {id-it 15}
                  OrigPKIMessageValue     ::= PKIMessages
               id-it-suppLangTags     OBJECT IDENTIFIER ::= {id-it 16}
                  SuppLangTagsValue       ::= SEQUENCE OF UTF8String
            
             where
            
               id-pkix OBJECT IDENTIFIER ::= {
                  iso(1) identified-organization(3)
                  dod(6) internet(1) security(5) mechanisms(5) pkix(7)}
             and
                  id-it   OBJECT IDENTIFIER ::= {id-pkix 4}
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.InfoTypeAndValue.ToAsn1Object">
            <pre>
            InfoTypeAndValue ::= SEQUENCE {
                                    infoType               OBJECT IDENTIFIER,
                                    infoValue              ANY DEFINED BY infoType  OPTIONAL
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.KeyRecRepContent.ToAsn1Object">
            <pre>
            KeyRecRepContent ::= SEQUENCE {
                                    status                  PKIStatusInfo,
                                    newSigCert          [0] CMPCertificate OPTIONAL,
                                    caCerts             [1] SEQUENCE SIZE (1..MAX) OF
                                                                      CMPCertificate OPTIONAL,
                                    keyPairHist         [2] SEQUENCE SIZE (1..MAX) OF
                                                                      CertifiedKeyPair OPTIONAL
                         }
            </pre> 
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.NestedMessageContent">
            NestedMessageContent ::= PKIMessages
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.OobCert">
            OOBCert ::= CMPCertificate
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.OobCertHash">
            <pre>
            OOBCertHash ::= SEQUENCE {
            hashAlg     [0] AlgorithmIdentifier     OPTIONAL,
            certId      [1] CertId                  OPTIONAL,
            hashVal         BIT STRING
            -- hashVal is calculated over the DER encoding of the
            -- self-signed certificate with the identifier certID.
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.OobCertHash.ToAsn1Object">
            <pre>
            OobCertHash ::= SEQUENCE {
                                 hashAlg     [0] AlgorithmIdentifier     OPTIONAL,
                                 certId      [1] CertId                  OPTIONAL,
                                 hashVal         BIT STRING
                                 -- hashVal is calculated over the Der encoding of the
                                 -- self-signed certificate with the identifier certID.
                  }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PbmParameter">
            PBMParameter ::= SEQUENCE {
                    salt                OCTET STRING,
                    -- note:  implementations MAY wish to limit acceptable sizes
                    -- of this string to values appropriate for their environment
                    -- in order to reduce the risk of denial-of-service attacks
                    owf                 AlgorithmIdentifier,
                    -- AlgId for a One-Way Function (SHA-1 recommended)
                    iterationCount      INTEGER,
                    -- number of times the OWF is applied
                    -- note:  implementations MAY wish to limit acceptable sizes
                    -- of this integer to values appropriate for their environment
                    -- in order to reduce the risk of denial-of-service attacks
                    mac                 AlgorithmIdentifier
                    -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
                }   -- or HMAC [RFC2104, RFC2202])
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PbmParameter.ToAsn1Object">
            <pre>
             PbmParameter ::= SEQUENCE {
                                   salt                OCTET STRING,
                                   -- note:  implementations MAY wish to limit acceptable sizes
                                   -- of this string to values appropriate for their environment
                                   -- in order to reduce the risk of denial-of-service attacks
                                   owf                 AlgorithmIdentifier,
                                   -- AlgId for a One-Way Function (SHA-1 recommended)
                                   iterationCount      INTEGER,
                                   -- number of times the OWF is applied
                                   -- note:  implementations MAY wish to limit acceptable sizes
                                   -- of this integer to values appropriate for their environment
                                   -- in order to reduce the risk of denial-of-service attacks
                                   mac                 AlgorithmIdentifier
                                   -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
               }   -- or HMAC [RFC2104, RFC2202])
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiBody">
            PKIBody ::= CHOICE {       -- message-specific body elements
                     ir       [0]  CertReqMessages,        --Initialization Request
                     ip       [1]  CertRepMessage,         --Initialization Response
                     cr       [2]  CertReqMessages,        --Certification Request
                     cp       [3]  CertRepMessage,         --Certification Response
                     p10cr    [4]  CertificationRequest,   --imported from [PKCS10]
                     popdecc  [5]  POPODecKeyChallContent, --pop Challenge
                     popdecr  [6]  POPODecKeyRespContent,  --pop Response
                     kur      [7]  CertReqMessages,        --Key Update Request
                     kup      [8]  CertRepMessage,         --Key Update Response
                     krr      [9]  CertReqMessages,        --Key Recovery Request
                     krp      [10] KeyRecRepContent,       --Key Recovery Response
                     rr       [11] RevReqContent,          --Revocation Request
                     rp       [12] RevRepContent,          --Revocation Response
                     ccr      [13] CertReqMessages,        --Cross-Cert. Request
                     ccp      [14] CertRepMessage,         --Cross-Cert. Response
                     ckuann   [15] CAKeyUpdAnnContent,     --CA Key Update Ann.
                     cann     [16] CertAnnContent,         --Certificate Ann.
                     rann     [17] RevAnnContent,          --Revocation Ann.
                     crlann   [18] CRLAnnContent,          --CRL Announcement
                     pkiconf  [19] PKIConfirmContent,      --Confirmation
                     nested   [20] NestedMessageContent,   --Nested Message
                     genm     [21] GenMsgContent,          --General Message
                     genp     [22] GenRepContent,          --General Response
                     error    [23] ErrorMsgContent,        --Error Message
                     certConf [24] CertConfirmContent,     --Certificate confirm
                     pollReq  [25] PollReqContent,         --Polling request
                     pollRep  [26] PollRepContent          --Polling response
                 }
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiBody.#ctor(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            Creates a new PkiBody.
            @param type one of the TYPE_* constants
            @param content message content
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiBody.ToAsn1Object">
            <pre>
            PkiBody ::= CHOICE {       -- message-specific body elements
                   ir       [0]  CertReqMessages,        --Initialization Request
                   ip       [1]  CertRepMessage,         --Initialization Response
                   cr       [2]  CertReqMessages,        --Certification Request
                   cp       [3]  CertRepMessage,         --Certification Response
                   p10cr    [4]  CertificationRequest,   --imported from [PKCS10]
                   popdecc  [5]  POPODecKeyChallContent, --pop Challenge
                   popdecr  [6]  POPODecKeyRespContent,  --pop Response
                   kur      [7]  CertReqMessages,        --Key Update Request
                   kup      [8]  CertRepMessage,         --Key Update Response
                   krr      [9]  CertReqMessages,        --Key Recovery Request
                   krp      [10] KeyRecRepContent,       --Key Recovery Response
                   rr       [11] RevReqContent,          --Revocation Request
                   rp       [12] RevRepContent,          --Revocation Response
                   ccr      [13] CertReqMessages,        --Cross-Cert. Request
                   ccp      [14] CertRepMessage,         --Cross-Cert. Response
                   ckuann   [15] CAKeyUpdAnnContent,     --CA Key Update Ann.
                   cann     [16] CertAnnContent,         --Certificate Ann.
                   rann     [17] RevAnnContent,          --Revocation Ann.
                   crlann   [18] CRLAnnContent,          --CRL Announcement
                   pkiconf  [19] PKIConfirmContent,      --Confirmation
                   nested   [20] NestedMessageContent,   --Nested Message
                   genm     [21] GenMsgContent,          --General Message
                   genp     [22] GenRepContent,          --General Response
                   error    [23] ErrorMsgContent,        --Error Message
                   certConf [24] CertConfirmContent,     --Certificate confirm
                   pollReq  [25] PollReqContent,         --Polling request
                   pollRep  [26] PollRepContent          --Polling response
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiConfirmContent">
            PKIConfirmContent ::= NULL
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiConfirmContent.ToAsn1Object">
            <pre>
            PkiConfirmContent ::= NULL
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiFailureInfo">
            <pre>
            PKIFailureInfo ::= BIT STRING {
            badAlg               (0),
              -- unrecognized or unsupported Algorithm Identifier
            badMessageCheck      (1), -- integrity check failed (e.g., signature did not verify)
            badRequest           (2),
              -- transaction not permitted or supported
            badTime              (3), -- messageTime was not sufficiently close to the system time, as defined by local policy
            badCertId            (4), -- no certificate could be found matching the provided criteria
            badDataFormat        (5),
              -- the data submitted has the wrong format
            wrongAuthority       (6), -- the authority indicated in the request is different from the one creating the response token
            incorrectData        (7), -- the requester's data is incorrect (for notary services)
            missingTimeStamp     (8), -- when the timestamp is missing but should be there (by policy)
            badPOP               (9)  -- the proof-of-possession failed
            certRevoked         (10),
            certConfirmed       (11),
            wrongIntegrity      (12),
            badRecipientNonce   (13),
            timeNotAvailable    (14),
              -- the TSA's time source is not available
            unacceptedPolicy    (15),
              -- the requested TSA policy is not supported by the TSA
            unacceptedExtension (16),
              -- the requested extension is not supported by the TSA
            addInfoNotAvailable (17)
              -- the additional information requested could not be understood
              -- or is not available
            badSenderNonce      (18),
            badCertTemplate     (19),
            signerNotTrusted    (20),
            transactionIdInUse  (21),
            unsupportedVersion  (22),
            notAuthorized       (23),
            systemUnavail       (24),
            systemFailure       (25),
              -- the request cannot be handled due to system failure
            duplicateCertReq    (26)
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiFailureInfo.#ctor(System.Int32)">
            Basic constructor.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiFreeText.Item(System.Int32)">
             Return the UTF8STRING at index.
            
             @param index index of the string of interest
             @return the string at index.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiFreeText.ToAsn1Object">
            <pre>
            PkiFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String
            </pre>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiHeader.NULL_NAME">
            Value for a "null" recipient or sender.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiHeader.ToAsn1Object">
            <pre>
             PkiHeader ::= SEQUENCE {
                       pvno                INTEGER     { cmp1999(1), cmp2000(2) },
                       sender              GeneralName,
                       -- identifies the sender
                       recipient           GeneralName,
                       -- identifies the intended recipient
                       messageTime     [0] GeneralizedTime         OPTIONAL,
                       -- time of production of this message (used when sender
                       -- believes that the transport will be "suitable"; i.e.,
                       -- that the time will still be meaningful upon receipt)
                       protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,
                       -- algorithm used for calculation of protection bits
                       senderKID       [2] KeyIdentifier           OPTIONAL,
                       recipKID        [3] KeyIdentifier           OPTIONAL,
                       -- to identify specific keys used for protection
                       transactionID   [4] OCTET STRING            OPTIONAL,
                       -- identifies the transaction; i.e., this will be the same in
                       -- corresponding request, response, certConf, and PKIConf
                       -- messages
                       senderNonce     [5] OCTET STRING            OPTIONAL,
                       recipNonce      [6] OCTET STRING            OPTIONAL,
                       -- nonces used to provide replay protection, senderNonce
                       -- is inserted by the creator of this message; recipNonce
                       -- is a nonce previously inserted in a related message by
                       -- the intended recipient of this message
                       freeText        [7] PKIFreeText             OPTIONAL,
                       -- this may be used to indicate context-specific instructions
                       -- (this field is intended for human consumption)
                       generalInfo     [8] SEQUENCE SIZE (1..MAX) OF
                                            InfoTypeAndValue     OPTIONAL
                       -- this may be used to convey context-specific information
                       -- (this field not primarily intended for human consumption)
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiHeaderBuilder.Build">
            <pre>
             PKIHeader ::= SEQUENCE {
                       pvno                INTEGER     { cmp1999(1), cmp2000(2) },
                       sender              GeneralName,
                       -- identifies the sender
                       recipient           GeneralName,
                       -- identifies the intended recipient
                       messageTime     [0] GeneralizedTime         OPTIONAL,
                       -- time of production of this message (used when sender
                       -- believes that the transport will be "suitable"; i.e.,
                       -- that the time will still be meaningful upon receipt)
                       protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,
                       -- algorithm used for calculation of protection bits
                       senderKID       [2] KeyIdentifier           OPTIONAL,
                       recipKID        [3] KeyIdentifier           OPTIONAL,
                       -- to identify specific keys used for protection
                       transactionID   [4] OCTET STRING            OPTIONAL,
                       -- identifies the transaction; i.e., this will be the same in
                       -- corresponding request, response, certConf, and PKIConf
                       -- messages
                       senderNonce     [5] OCTET STRING            OPTIONAL,
                       recipNonce      [6] OCTET STRING            OPTIONAL,
                       -- nonces used to provide replay protection, senderNonce
                       -- is inserted by the creator of this message; recipNonce
                       -- is a nonce previously inserted in a related message by
                       -- the intended recipient of this message
                       freeText        [7] PKIFreeText             OPTIONAL,
                       -- this may be used to indicate context-specific instructions
                       -- (this field is intended for human consumption)
                       generalInfo     [8] SEQUENCE SIZE (1..MAX) OF
                                            InfoTypeAndValue     OPTIONAL
                       -- this may be used to convey context-specific information
                       -- (this field not primarily intended for human consumption)
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiMessage.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiHeader,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiBody,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBitString,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.CmpCertificate[])">
             Creates a new PkiMessage.
            
             @param header message header
             @param body message body
             @param protection message protection (may be null)
             @param extraCerts extra certificates (may be null)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiMessage.ToAsn1Object">
            <pre>
            PkiMessage ::= SEQUENCE {
                             header           PKIHeader,
                             body             PKIBody,
                             protection   [0] PKIProtection OPTIONAL,
                             extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
                                                                                OPTIONAL
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiMessages.ToAsn1Object">
            <pre>
            PkiMessages ::= SEQUENCE SIZE (1..MAX) OF PkiMessage
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiStatusInfo.#ctor(System.Int32)">
            @param status
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiStatusInfo.#ctor(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiFreeText)">
            @param status
            @param statusString
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiStatusInfo.ToAsn1Object">
             <pre>
             PkiStatusInfo ::= SEQUENCE {
                 status        PKIStatus,                (INTEGER)
                 statusString  PkiFreeText     OPTIONAL,
                 failInfo      PkiFailureInfo  OPTIONAL  (BIT STRING)
             }
            
             PKIStatus:
               granted                (0), -- you got exactly what you asked for
               grantedWithMods        (1), -- you got something like what you asked for
               rejection              (2), -- you don't get it, more information elsewhere in the message
               waiting                (3), -- the request body part has not yet been processed, expect to hear more later
               revocationWarning      (4), -- this message contains a warning that a revocation is imminent
               revocationNotification (5), -- notification that a revocation has occurred
               keyUpdateWarning       (6)  -- update already done for the oldCertId specified in CertReqMsg
            
             PkiFailureInfo:
               badAlg           (0), -- unrecognized or unsupported Algorithm Identifier
               badMessageCheck  (1), -- integrity check failed (e.g., signature did not verify)
               badRequest       (2), -- transaction not permitted or supported
               badTime          (3), -- messageTime was not sufficiently close to the system time, as defined by local policy
               badCertId        (4), -- no certificate could be found matching the provided criteria
               badDataFormat    (5), -- the data submitted has the wrong format
               wrongAuthority   (6), -- the authority indicated in the request is different from the one creating the response token
               incorrectData    (7), -- the requester's data is incorrect (for notary services)
               missingTimeStamp (8), -- when the timestamp is missing but should be there (by policy)
               badPOP           (9)  -- the proof-of-possession failed
            
             </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PollRepContent">
            PollRepContent ::= SEQUENCE OF SEQUENCE {
            certReqId    INTEGER,
            checkAfter   INTEGER,  -- time in seconds
            reason       PKIFreeText OPTIONAL }
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PollRepContent.ToAsn1Object">
            <pre>
            PollRepContent ::= SEQUENCE OF SEQUENCE {
                    certReqId              INTEGER,
                    checkAfter             INTEGER,  -- time in seconds
                    reason                 PKIFreeText OPTIONAL
                }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PollReqContent.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerInteger)">
             Create a pollReqContent for a single certReqId.
            
             @param certReqId the certificate request ID.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PollReqContent.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerInteger[])">
             Create a pollReqContent for a multiple certReqIds.
            
             @param certReqIds the certificate request IDs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PollReqContent.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
             Create a pollReqContent for a single certReqId.
            
             @param certReqId the certificate request ID.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PollReqContent.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger[])">
             Create a pollReqContent for a multiple certReqIds.
            
             @param certReqIds the certificate request IDs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PollReqContent.ToAsn1Object">
            <pre>
            PollReqContent ::= SEQUENCE OF SEQUENCE {
                                   certReqId              INTEGER
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PopoDecKeyChallContent.ToAsn1Object">
            <pre>
            PopoDecKeyChallContent ::= SEQUENCE OF Challenge
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PopoDecKeyRespContent.ToAsn1Object">
            <pre>
            PopoDecKeyRespContent ::= SEQUENCE OF INTEGER
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.ProtectedPart.ToAsn1Object">
            <pre>
            ProtectedPart ::= SEQUENCE {
                               header    PKIHeader,
                               body      PKIBody
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.RevAnnContent.ToAsn1Object">
            <pre>
            RevAnnContent ::= SEQUENCE {
                  status              PKIStatus,
                  certId              CertId,
                  willBeRevokedAt     GeneralizedTime,
                  badSinceDate        GeneralizedTime,
                  crlDetails          Extensions  OPTIONAL
                   -- extra CRL details (e.g., crl number, reason, location, etc.)
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.RevDetails">
            <pre>
            RevDetails ::= SEQUENCE {
                     certDetails         CertTemplate,
                     -- allows requester to specify as much as they can about
                     -- the cert. for which revocation is requested
                     -- (e.g., for cases in which serialNumber is not available)
                     crlEntryDetails     Extensions       OPTIONAL
                     -- requested crlEntryExtensions
                 }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.RevDetails.ToAsn1Object">
            <pre>
            RevDetails ::= SEQUENCE {
                             certDetails         CertTemplate,
                              -- allows requester to specify as much as they can about
                              -- the cert. for which revocation is requested
                              -- (e.g., for cases in which serialNumber is not available)
                              crlEntryDetails     Extensions       OPTIONAL
                              -- requested crlEntryExtensions
                        }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.RevRepContent">
             <pre>
             RevRepContent ::= SEQUENCE {
                      status       SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,
                      -- in same order as was sent in RevReqContent
                      revCerts [0] SEQUENCE SIZE (1..MAX) OF CertId
                                                          OPTIONAL,
                      -- IDs for which revocation was requested
                      -- (same order as status)
                      crls     [1] SEQUENCE SIZE (1..MAX) OF CertificateList OPTIONAL
                      -- the resulting CRLs (there may be more than one)
                  }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.RevRepContent.ToAsn1Object">
            <pre>
            RevRepContent ::= SEQUENCE {
                   status       SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,
                   -- in same order as was sent in RevReqContent
                   revCerts [0] SEQUENCE SIZE (1..MAX) OF CertId OPTIONAL,
                   -- IDs for which revocation was requested
                   -- (same order as status)
                   crls     [1] SEQUENCE SIZE (1..MAX) OF CertificateList OPTIONAL
                   -- the resulting CRLs (there may be more than one)
              }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.RevReqContent.ToAsn1Object">
            <pre>
            RevReqContent ::= SEQUENCE OF RevDetails
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.RootCaKeyUpdateContent">
            GenMsg:    {id-it 20}, RootCaCertValue | &lt; absent &gt;
            GenRep:    {id-it 18}, RootCaKeyUpdateContent | &lt; absent &gt;
            <p>
            RootCaCertValue ::= CMPCertificate
            </p><p>
            RootCaKeyUpdateValue ::= RootCaKeyUpdateContent
            </p><p>
            RootCaKeyUpdateContent ::= SEQUENCE {
            newWithNew       CMPCertificate,
            newWithOld   [0] CMPCertificate OPTIONAL,
            oldWithNew   [1] CMPCertificate OPTIONAL
            }
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.Attribute.GetInstance(System.Object)">
             return an Attribute object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.Attribute.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Attribute ::= SEQUENCE {
                attrType OBJECT IDENTIFIER,
                attrValues SET OF AttributeValue
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.Attributes.ToAsn1Object">
            <pre>
            Attributes ::=
              SET SIZE(1..MAX) OF Attribute -- according to RFC 5652
            </pre>
            @return
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable.Item(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Return the first attribute matching the given OBJECT IDENTIFIER</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable.GetAll(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             Return all the attributes matching the OBJECT IDENTIFIER oid. The vector will be
             empty if there are no attributes of the required type present.
            
             @param oid type of attribute required.
             @return a vector of all the attributes found of type oid.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable.Add(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
             Return a new table with the passed in attribute added.
            
             @param attrType
             @param attrValue
             @return
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AuthenticatedData.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an AuthenticatedData object from a tagged object.
            
             @param obj      the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                             tagged false otherwise.
             @throws ArgumentException if the object held by the
                                              tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AuthenticatedData.GetInstance(System.Object)">
             return an AuthenticatedData object from the given object.
            
             @param obj the object we want converted.
             @throws ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AuthenticatedData.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             AuthenticatedData ::= SEQUENCE {
                   version CMSVersion,
                   originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
                   recipientInfos RecipientInfos,
                   macAlgorithm MessageAuthenticationCodeAlgorithm,
                   digestAlgorithm [1] DigestAlgorithmIdentifier OPTIONAL,
                   encapContentInfo EncapsulatedContentInfo,
                   authAttrs [2] IMPLICIT AuthAttributes OPTIONAL,
                   mac MessageAuthenticationCode,
                   unauthAttrs [3] IMPLICIT UnauthAttributes OPTIONAL }
            
             AuthAttributes ::= SET SIZE (1..MAX) OF Attribute
            
             UnauthAttributes ::= SET SIZE (1..MAX) OF Attribute
            
             MessageAuthenticationCode ::= OCTET STRING
             </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AuthenticatedDataParser">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             AuthenticatedData ::= SEQUENCE {
                   version CMSVersion,
                   originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
                   recipientInfos RecipientInfos,
                   macAlgorithm MessageAuthenticationCodeAlgorithm,
                   digestAlgorithm [1] DigestAlgorithmIdentifier OPTIONAL,
                   encapContentInfo EncapsulatedContentInfo,
                   authAttrs [2] IMPLICIT AuthAttributes OPTIONAL,
                   mac MessageAuthenticationCode,
                   unauthAttrs [3] IMPLICIT UnauthAttributes OPTIONAL }
            
             AuthAttributes ::= SET SIZE (1..MAX) OF Attribute
            
             UnauthAttributes ::= SET SIZE (1..MAX) OF Attribute
            
             MessageAuthenticationCode ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AuthEnvelopedData.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an AuthEnvelopedData object from a tagged object.
            
             @param obj      the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                             tagged false otherwise.
             @throws ArgumentException if the object held by the
                                              tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AuthEnvelopedData.GetInstance(System.Object)">
             return an AuthEnvelopedData object from the given object.
            
             @param obj the object we want converted.
             @throws ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AuthEnvelopedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            AuthEnvelopedData ::= SEQUENCE {
              version CMSVersion,
              originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
              recipientInfos RecipientInfos,
              authEncryptedContentInfo EncryptedContentInfo,
              authAttrs [1] IMPLICIT AuthAttributes OPTIONAL,
              mac MessageAuthenticationCode,
              unauthAttrs [2] IMPLICIT UnauthAttributes OPTIONAL }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AuthEnvelopedDataParser">
            Produce an object suitable for an Asn1OutputStream.
            
            <pre>
            AuthEnvelopedData ::= SEQUENCE {
              version CMSVersion,
              originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
              recipientInfos RecipientInfos,
              authEncryptedContentInfo EncryptedContentInfo,
              authAttrs [1] IMPLICIT AuthAttributes OPTIONAL,
              mac MessageAuthenticationCode,
              unauthAttrs [2] IMPLICIT UnauthAttributes OPTIONAL }
            </pre>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.CmsObjectIdentifiers.id_ri">
            The other Revocation Info arc
            id-ri OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
                                              dod(6) internet(1) security(5) mechanisms(5) pkix(7) ri(16) }
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.CompressedData">
            RFC 3274 - CMS Compressed Data.
            <pre>
            CompressedData ::= Sequence {
             version CMSVersion,
             compressionAlgorithm CompressionAlgorithmIdentifier,
             encapContentInfo EncapsulatedContentInfo
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.CompressedData.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a CompressedData object from a tagged object.
            
             @param ato the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.CompressedData.GetInstance(System.Object)">
             return a CompressedData object from the given object.
            
             @param _obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.CompressedDataParser">
            RFC 3274 - CMS Compressed Data.
            <pre>
            CompressedData ::= SEQUENCE {
             version CMSVersion,
             compressionAlgorithm CompressionAlgorithmIdentifier,
             encapContentInfo EncapsulatedContentInfo
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.ContentInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ContentInfo ::= Sequence {
                     contentType ContentType,
                     content
                     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.ContentInfoParser">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ContentInfo ::= SEQUENCE {
                     contentType ContentType,
                     content
                     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an AuthEnvelopedData object from a tagged object.
            
             @param obj      the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                             tagged false otherwise.
             @throws ArgumentException if the object held by the
                                              tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial.GetInstance(System.Object)">
             return an AuthEnvelopedData object from the given object.
            
             @param obj the object we want converted.
             @throws ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            MQVuserKeyingMaterial ::= SEQUENCE {
              ephemeralPublicKey OriginatorPublicKey,
              addedukm [0] EXPLICIT UserKeyingMaterial OPTIONAL  }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.EncryptedContentInfo.GetInstance(System.Object)">
             return an EncryptedContentInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.EncryptedContentInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            EncryptedContentInfo ::= Sequence {
                contentType ContentType,
                contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,
                encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.EncryptedContentInfoParser">
            <pre>
            EncryptedContentInfo ::= SEQUENCE {
                contentType ContentType,
                contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,
                encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.EncryptedData.ToAsn1Object">
            <pre>
                  EncryptedData ::= SEQUENCE {
                                version CMSVersion,
                                encryptedContentInfo EncryptedContentInfo,
                                unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.EnvelopedData.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an EnvelopedData object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.EnvelopedData.GetInstance(System.Object)">
             return an EnvelopedData object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.EnvelopedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            EnvelopedData ::= Sequence {
                version CMSVersion,
                originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
                recipientInfos RecipientInfos,
                encryptedContentInfo EncryptedContentInfo,
                unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.EnvelopedDataParser">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            EnvelopedData ::= SEQUENCE {
                version CMSVersion,
                originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
                recipientInfos RecipientInfos,
                encryptedContentInfo EncryptedContentInfo,
                unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.KekIdentifier.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a KekIdentifier object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.KekIdentifier.GetInstance(System.Object)">
             return a KekIdentifier object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.KekIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KekIdentifier ::= Sequence {
                keyIdentifier OCTET STRING,
                date GeneralizedTime OPTIONAL,
                other OtherKeyAttribute OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.KekRecipientInfo.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a KekRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.KekRecipientInfo.GetInstance(System.Object)">
             return a KekRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.KekRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KekRecipientInfo ::= Sequence {
                version CMSVersion,  -- always set to 4
                kekID KekIdentifier,
                keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                encryptedKey EncryptedKey
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an KeyAgreeRecipientIdentifier object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier.GetInstance(System.Object)">
             return an KeyAgreeRecipientIdentifier object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KeyAgreeRecipientIdentifier ::= CHOICE {
                issuerAndSerialNumber IssuerAndSerialNumber,
                rKeyId [0] IMPLICIT RecipientKeyIdentifier
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a KeyAgreeRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo.GetInstance(System.Object)">
             return a KeyAgreeRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo.ToAsn1Object">
                     * Produce an object suitable for an Asn1OutputStream.
                     * <pre>
                     * KeyAgreeRecipientInfo ::= Sequence {
                     *     version CMSVersion,  -- always set to 3
                     *     originator [0] EXPLICIT OriginatorIdentifierOrKey,
                     *     ukm [1] EXPLICIT UserKeyingMaterial OPTIONAL,
                     *     keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                     *     recipientEncryptedKeys RecipientEncryptedKeys
                     * }
            		 *
            		 * UserKeyingMaterial ::= OCTET STRING
                     * </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.KeyTransRecipientInfo.GetInstance(System.Object)">
             return a KeyTransRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.KeyTransRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KeyTransRecipientInfo ::= Sequence {
                version CMSVersion,  -- always set to 0 or 2
                rid RecipientIdentifier,
                keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                encryptedKey EncryptedKey
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.MetaData.ToAsn1Object">
            <pre>
            MetaData ::= SEQUENCE {
              hashProtected        BOOLEAN,
              fileName             UTF8String OPTIONAL,
              mediaType            IA5String OPTIONAL,
              otherMetaData        Attributes OPTIONAL
            }
            </pre>
            @return
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an OriginatorIdentifierOrKey object from a tagged object.
            
             @param o the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey.GetInstance(System.Object)">
             return an OriginatorIdentifierOrKey object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             OriginatorIdentifierOrKey ::= CHOICE {
                 issuerAndSerialNumber IssuerAndSerialNumber,
                 subjectKeyIdentifier [0] SubjectKeyIdentifier,
                 originatorKey [1] OriginatorPublicKey
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OriginatorInfo.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an OriginatorInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OriginatorInfo.GetInstance(System.Object)">
             return an OriginatorInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OriginatorInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OriginatorInfo ::= Sequence {
                certs [0] IMPLICIT CertificateSet OPTIONAL,
                crls [1] IMPLICIT CertificateRevocationLists OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an OriginatorPublicKey object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey.GetInstance(System.Object)">
             return an OriginatorPublicKey object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OriginatorPublicKey ::= Sequence {
                algorithm AlgorithmIdentifier,
                publicKey BIT STRING
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OtherKeyAttribute.GetInstance(System.Object)">
             return an OtherKeyAttribute object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OtherKeyAttribute.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OtherKeyAttribute ::= Sequence {
                keyAttrId OBJECT IDENTIFIER,
                keyAttr ANY DEFINED BY keyAttrId OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a OtherRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo.GetInstance(System.Object)">
             return a OtherRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OtherRecipientInfo ::= Sequence {
               oriType OBJECT IDENTIFIER,
               oriValue ANY DEFINED BY oriType }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a OtherRevocationInfoFormat object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception IllegalArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat.GetInstance(System.Object)">
             return a OtherRevocationInfoFormat object from the given object.
            
             @param obj the object we want converted.
             @exception IllegalArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat.ToAsn1Object">
            Produce an object suitable for an ASN1OutputStream.
            <pre>
            OtherRevocationInfoFormat ::= SEQUENCE {
                 otherRevInfoFormat OBJECT IDENTIFIER,
                 otherRevInfo ANY DEFINED BY otherRevInfoFormat }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a PasswordRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo.GetInstance(System.Object)">
             return a PasswordRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            PasswordRecipientInfo ::= Sequence {
              version CMSVersion,   -- Always set to 0
              keyDerivationAlgorithm [0] KeyDerivationAlgorithmIdentifier
                                        OPTIONAL,
             keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
             encryptedKey EncryptedKey }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an RecipientEncryptedKey object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey.GetInstance(System.Object)">
             return a RecipientEncryptedKey object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            RecipientEncryptedKey ::= SEQUENCE {
                rid KeyAgreeRecipientIdentifier,
                encryptedKey EncryptedKey
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.RecipientIdentifier.GetInstance(System.Object)">
             return a RecipientIdentifier object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.RecipientIdentifier.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             RecipientIdentifier ::= CHOICE {
                 issuerAndSerialNumber IssuerAndSerialNumber,
                 subjectKeyIdentifier [0] SubjectKeyIdentifier
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.RecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            RecipientInfo ::= CHOICE {
                ktri KeyTransRecipientInfo,
                kari [1] KeyAgreeRecipientInfo,
                kekri [2] KekRecipientInfo,
                pwri [3] PasswordRecipientInfo,
                ori [4] OtherRecipientInfo }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a RecipientKeyIdentifier object from a tagged object.
            
             @param _ato the tagged object holding the object we want.
             @param _explicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier.GetInstance(System.Object)">
             return a RecipientKeyIdentifier object from the given object.
            
             @param _obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             RecipientKeyIdentifier ::= Sequence {
                 subjectKeyIdentifier SubjectKeyIdentifier,
                 date GeneralizedTime OPTIONAL,
                 other OtherKeyAttribute OPTIONAL
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.ScvpReqRes.ToAsn1Object">
            <pre>
               ScvpReqRes ::= SEQUENCE {
               request  [0] EXPLICIT ContentInfo OPTIONAL,
               response     ContentInfo }
            </pre>
            @return  the ASN.1 primitive representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.SignedData">
            a signed data object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.SignedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SignedData ::= Sequence {
                version CMSVersion,
                digestAlgorithms DigestAlgorithmIdentifiers,
                encapContentInfo EncapsulatedContentInfo,
                certificates [0] IMPLICIT CertificateSet OPTIONAL,
                crls [1] IMPLICIT CertificateRevocationLists OPTIONAL,
                signerInfos SignerInfos
              }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.SignedDataParser">
            <pre>
            SignedData ::= SEQUENCE {
                version CMSVersion,
                digestAlgorithms DigestAlgorithmIdentifiers,
                encapContentInfo EncapsulatedContentInfo,
                certificates [0] IMPLICIT CertificateSet OPTIONAL,
                crls [1] IMPLICIT CertificateRevocationLists OPTIONAL,
                signerInfos SignerInfos
              }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.SignerIdentifier.GetInstance(System.Object)">
             return a SignerIdentifier object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.SignerIdentifier.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             SignerIdentifier ::= CHOICE {
                 issuerAndSerialNumber IssuerAndSerialNumber,
                 subjectKeyIdentifier [0] SubjectKeyIdentifier
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.SignerInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
              SignerInfo ::= Sequence {
                  version Version,
                  SignerIdentifier sid,
                  digestAlgorithm DigestAlgorithmIdentifier,
                  authenticatedAttributes [0] IMPLICIT Attributes OPTIONAL,
                  digestEncryptionAlgorithm DigestEncryptionAlgorithmIdentifier,
                  encryptedDigest EncryptedDigest,
                  unauthenticatedAttributes [1] IMPLICIT Attributes OPTIONAL
              }
            
              EncryptedDigest ::= OCTET STRING
            
              DigestAlgorithmIdentifier ::= AlgorithmIdentifier
            
              DigestEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.Time.#ctor(System.DateTime)">
            creates a time object from a given date - if the date is between 1950
            and 2049 a UTCTime object is Generated, otherwise a GeneralizedTime
            is used.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.Time.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Time ::= CHOICE {
                        utcTime        UTCTime,
                        generalTime    GeneralizedTime }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.TimeStampAndCrl.ToAsn1Object">
            <pre>
            TimeStampAndCRL ::= SEQUENCE {
                timeStamp   TimeStampToken,          -- according to RFC 3161
                crl         CertificateList OPTIONAL -- according to RFC 5280
             }
            </pre>
            @return
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.TimeStampedData.ToAsn1Object">
            <pre>
            TimeStampedData ::= SEQUENCE {
              version              INTEGER { v1(1) },
              dataUri              IA5String OPTIONAL,
              metaData             MetaData OPTIONAL,
              content              OCTET STRING OPTIONAL,
              temporalEvidence     Evidence
            }
            </pre>
            @return
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.TimeStampTokenEvidence.ToAsn1Object">
            <pre>
            TimeStampTokenEvidence ::=
               SEQUENCE SIZE(1..MAX) OF TimeStampAndCrl
            </pre>
            @return
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.AttributeTypeAndValue.ToAsn1Object">
            <pre>
            AttributeTypeAndValue ::= SEQUENCE {
                      type         OBJECT IDENTIFIER,
                      value        ANY DEFINED BY type }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.CertId.ToAsn1Object">
            <pre>
            CertId ::= SEQUENCE {
                            issuer           GeneralName,
                            serialNumber     INTEGER }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.CertReqMessages.ToAsn1Object">
            <pre>
            CertReqMessages ::= SEQUENCE SIZE (1..MAX) OF CertReqMsg
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.CertReqMsg.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.CertRequest,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.ProofOfPossession,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.AttributeTypeAndValue[])">
            Creates a new CertReqMsg.
            @param certReq CertRequest
            @param popo may be null
            @param regInfo may be null
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.CertReqMsg.ToAsn1Object">
            <pre>
            CertReqMsg ::= SEQUENCE {
                               certReq   CertRequest,
                               pop       ProofOfPossession  OPTIONAL,
                               -- content depends upon key type
                               regInfo   SEQUENCE SIZE(1..MAX) OF AttributeTypeAndValue OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.CertRequest.ToAsn1Object">
            <pre>
            CertRequest ::= SEQUENCE {
                                 certReqId     INTEGER,          -- ID for matching request and reply
                                 certTemplate  CertTemplate,  -- Selected fields of cert to be issued
                                 controls      Controls OPTIONAL }   -- Attributes affecting issuance
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.CertTemplate.ToAsn1Object">
            <pre>
             CertTemplate ::= SEQUENCE {
                 version      [0] Version               OPTIONAL,
                 serialNumber [1] INTEGER               OPTIONAL,
                 signingAlg   [2] AlgorithmIdentifier   OPTIONAL,
                 issuer       [3] Name                  OPTIONAL,
                 validity     [4] OptionalValidity      OPTIONAL,
                 subject      [5] Name                  OPTIONAL,
                 publicKey    [6] SubjectPublicKeyInfo  OPTIONAL,
                 issuerUID    [7] UniqueIdentifier      OPTIONAL,
                 subjectUID   [8] UniqueIdentifier      OPTIONAL,
                 extensions   [9] Extensions            OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder.SetVersion(System.Int32)">
            Sets the X.509 version. Note: for X509v3, use 2 here. 
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder.SetIssuerUID(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBitString)">
            Sets the issuer unique ID (deprecated in X.509v3) 
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder.SetSubjectUID(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBitString)">
            Sets the subject unique ID (deprecated in X.509v3) 
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder.Build">
            <pre>
             CertTemplate ::= SEQUENCE {
                 version      [0] Version               OPTIONAL,
                 serialNumber [1] INTEGER               OPTIONAL,
                 signingAlg   [2] AlgorithmIdentifier   OPTIONAL,
                 issuer       [3] Name                  OPTIONAL,
                 validity     [4] OptionalValidity      OPTIONAL,
                 subject      [5] Name                  OPTIONAL,
                 publicKey    [6] SubjectPublicKeyInfo  OPTIONAL,
                 issuerUID    [7] UniqueIdentifier      OPTIONAL,
                 subjectUID   [8] UniqueIdentifier      OPTIONAL,
                 extensions   [9] Extensions            OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.Controls.ToAsn1Object">
            <pre>
            Controls  ::= SEQUENCE SIZE(1..MAX) OF AttributeTypeAndValue
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.EncKeyWithID.ToAsn1Object">
            <pre>
            EncKeyWithID ::= SEQUENCE {
                 privateKey           PrivateKeyInfo,
                 identifier CHOICE {
                    string               UTF8String,
                    generalName          GeneralName
                } OPTIONAL
            }
            </pre>
            @return
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.EncryptedKey.ToAsn1Object">
            <pre>
               EncryptedKey ::= CHOICE {
                   encryptedValue        EncryptedValue, -- deprecated
                   envelopedData     [0] EnvelopedData }
                   -- The encrypted private key MUST be placed in the envelopedData
                   -- encryptedContentInfo encryptedContent OCTET STRING.
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.EncryptedValue.ToAsn1Object">
            <pre>
            (IMPLICIT TAGS)
            EncryptedValue ::= SEQUENCE {
                                intendedAlg   [0] AlgorithmIdentifier  OPTIONAL,
                                -- the intended algorithm for which the value will be used
                                symmAlg       [1] AlgorithmIdentifier  OPTIONAL,
                                -- the symmetric algorithm used to encrypt the value
                                encSymmKey    [2] BIT STRING           OPTIONAL,
                                -- the (encrypted) symmetric key used to encrypt the value
                                keyAlg        [3] AlgorithmIdentifier  OPTIONAL,
                                -- algorithm used to encrypt the symmetric key
                                valueHint     [4] OCTET STRING         OPTIONAL,
                                -- a brief description or identifier of the encValue content
                                -- (may be meaningful only to the sending entity, and used only
                                -- if EncryptedValue might be re-examined by the sending entity
                                -- in the future)
                                encValue       BIT STRING }
                                -- the encrypted value itself
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.OptionalValidity.ToAsn1Object">
            <pre>
            OptionalValidity ::= SEQUENCE {
                                   notBefore  [0] Time OPTIONAL,
                                   notAfter   [1] Time OPTIONAL } --at least one MUST be present
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PkiArchiveOptions.ToAsn1Object">
            <pre>
             PkiArchiveOptions ::= CHOICE {
                 encryptedPrivKey     [0] EncryptedKey,
                 -- the actual value of the private key
                 keyGenParameters     [1] KeyGenParameters,
                 -- parameters which allow the private key to be re-generated
                 archiveRemGenPrivKey [2] BOOLEAN }
                 -- set to TRUE if sender wishes receiver to archive the private
                 -- key of a key pair that the receiver generates in response to
                 -- this request; set to FALSE if no archival is desired.
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PkiPublicationInfo">
            <pre>
            PKIPublicationInfo ::= SEQUENCE {
                             action     INTEGER {
                                            dontPublish (0),
                                            pleasePublish (1) },
                             pubInfos  SEQUENCE SIZE (1..MAX) OF SinglePubInfo OPTIONAL }
            -- pubInfos MUST NOT be present if action is "dontPublish"
            -- (if action is "pleasePublish" and pubInfos is omitted,
            -- "dontCare" is assumed)
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PkiPublicationInfo.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.SinglePubInfo)">
             Constructor with a single pubInfo, assumes pleasePublish as the action.
            
             @param pubInfo the pubInfo to be published (can be null if don't care is required).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PkiPublicationInfo.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.SinglePubInfo[])">
             Constructor with multiple pubInfo, assumes pleasePublish as the action.
            
             @param pubInfos the pubInfos to be published (can be null if don't care is required).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PkiPublicationInfo.ToAsn1Object">
            <pre>
            PkiPublicationInfo ::= SEQUENCE {
                             action     INTEGER {
                                            dontPublish (0),
                                            pleasePublish (1) },
                             pubInfos  SEQUENCE SIZE (1..MAX) OF SinglePubInfo OPTIONAL }
            -- pubInfos MUST NOT be present if action is "dontPublish"
            -- (if action is "pleasePublish" and pubInfos is omitted,
            -- "dontCare" is assumed)
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PKMacValue">
            Password-based MAC value for use with POPOSigningKeyInput.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PKMacValue.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PbmParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBitString)">
            Creates a new PKMACValue.
            @param params parameters for password-based MAC
            @param value MAC of the DER-encoded SubjectPublicKeyInfo
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PKMacValue.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBitString)">
            Creates a new PKMACValue.
            @param aid CMPObjectIdentifiers.passwordBasedMAC, with PBMParameter
            @param value MAC of the DER-encoded SubjectPublicKeyInfo
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PKMacValue.ToAsn1Object">
            <pre>
            PKMACValue ::= SEQUENCE {
                 algId  AlgorithmIdentifier,
                 -- algorithm value shall be PasswordBasedMac 1.2.840.113533.7.66.13
                 -- parameter value is PBMParameter
                 value  BIT STRING }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PopoPrivKey.ToAsn1Object">
            <pre>
            PopoPrivKey ::= CHOICE {
                   thisMessage       [0] BIT STRING,         -- Deprecated
                    -- possession is proven in this message (which contains the private
                    -- key itself (encrypted for the CA))
                   subsequentMessage [1] SubsequentMessage,
                    -- possession will be proven in a subsequent message
                   dhMAC             [2] BIT STRING,         -- Deprecated
                   agreeMAC          [3] PKMACValue,
                   encryptedKey      [4] EnvelopedData }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PopoSigningKey.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBitString)">
            Creates a new Proof of Possession object for a signing key.
            @param poposkIn the PopoSigningKeyInput structure, or null if the
                CertTemplate includes both subject and publicKey values.
            @param aid the AlgorithmIdentifier used to sign the proof of possession.
            @param signature a signature over the DER-encoded value of poposkIn,
                or the DER-encoded value of certReq if poposkIn is null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PopoSigningKey.ToAsn1Object">
            <pre>
            PopoSigningKey ::= SEQUENCE {
                                 poposkInput           [0] PopoSigningKeyInput OPTIONAL,
                                 algorithmIdentifier   AlgorithmIdentifier,
                                 signature             BIT STRING }
             -- The signature (using "algorithmIdentifier") is on the
             -- DER-encoded value of poposkInput.  NOTE: If the CertReqMsg
             -- certReq CertTemplate contains the subject and publicKey values,
             -- then poposkInput MUST be omitted and the signature MUST be
             -- computed on the DER-encoded value of CertReqMsg certReq.  If
             -- the CertReqMsg certReq CertTemplate does not contain the public
             -- key and subject values, then poposkInput MUST be present and
             -- MUST be signed.  This strategy ensures that the public key is
             -- not present in both the poposkInput and CertReqMsg certReq
             -- CertTemplate fields.
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Creates a new PopoSigningKeyInput with sender name as authInfo. 
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PKMacValue,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Creates a new PopoSigningKeyInput using password-based MAC. 
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.Sender">
            Returns the sender field, or null if authInfo is publicKeyMac 
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.PublicKeyMac">
            Returns the publicKeyMac field, or null if authInfo is sender 
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.ToAsn1Object">
            <pre>
            PopoSigningKeyInput ::= SEQUENCE {
                   authInfo             CHOICE {
                                            sender              [0] GeneralName,
                                            -- used only if an authenticated identity has been
                                            -- established for the sender (e.g., a DN from a
                                            -- previously-issued and currently-valid certificate
                                            publicKeyMac        PKMacValue },
                                            -- used if no authenticated GeneralName currently exists for
                                            -- the sender; publicKeyMac contains a password-based MAC
                                            -- on the DER-encoded value of publicKey
                   publicKey           SubjectPublicKeyInfo }  -- from CertTemplate
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.ProofOfPossession.#ctor">
            Creates a ProofOfPossession with type raVerified. 
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.ProofOfPossession.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PopoSigningKey)">
            Creates a ProofOfPossession for a signing key. 
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.ProofOfPossession.#ctor(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PopoPrivKey)">
            Creates a ProofOfPossession for key encipherment or agreement.
            @param type one of TYPE_KEY_ENCIPHERMENT or TYPE_KEY_AGREEMENT
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.ProofOfPossession.ToAsn1Object">
            <pre>
            ProofOfPossession ::= CHOICE {
                                      raVerified        [0] NULL,
                                      -- used if the RA has already verified that the requester is in
                                      -- possession of the private key
                                      signature         [1] PopoSigningKey,
                                      keyEncipherment   [2] PopoPrivKey,
                                      keyAgreement      [3] PopoPrivKey }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.SinglePubInfo.ToAsn1Object">
            <pre>
            SinglePubInfo ::= SEQUENCE {
                   pubMethod    INTEGER {
                      dontCare    (0),
                      x500        (1),
                      web         (2),
                      ldap        (3) },
                  pubLocation  GeneralName OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves">
            <summary>Elliptic curve registry for GOST 3410-2001 / 2012.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetByName(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetByOid(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetByOidLazy(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetName(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetOid(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.Names">
            <summary>Enumerate the available curve names in this registry.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.CryptoPro.Gost28147Parameters.ToAsn1Object">
             <pre>
             Gost28147-89-Parameters ::=
                           SEQUENCE {
                                   iv                   Gost28147-89-IV,
                                   encryptionParamSet   OBJECT IDENTIFIER
                            }
            
               Gost28147-89-IV ::= OCTET STRING (SIZE (8))
             </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters">
            <summary>Registry of available named parameters for GOST 3410-94.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters.GetByName(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.CryptoPro.Gost3410ParamSetParameters"/> for the parameter set with the given name.
            </summary>
            <param name="name">The name of the parameter set.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters.GetByOid(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.CryptoPro.Gost3410ParamSetParameters"/> for the parameter set with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the parameter set.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters.GetOid(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the parameter set with the given name.
            </summary>
            <param name="name">The name of the parameter set.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters.Names">
            <summary>Enumerate the available parameter set names in this registry.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBitString.GetInstance(System.Object)">
             return a Bit string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBitString.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Bit string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBitString.#ctor(System.Byte[],System.Int32)">
            @param data the octets making up the bit string.
            @param padBits the number of extra bits at the end of the string.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBitString.GetOctets">
             Return the octets contained in this BIT STRING, checking that this BIT STRING really
             does represent an octet aligned string. Only use this method when the standard you are
             following dictates that the BIT STRING will be octet aligned.
            
             @return a copy of the octet aligned data.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBitString.IntValue">
            @return the value of the bit string as an int (truncating if necessary)
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBmpString">
            Der BMPString object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBmpString.GetInstance(System.Object)">
             return a BMP string from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBmpString.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a BMP string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBmpString.#ctor(System.String)">
            basic constructor
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBoolean.GetInstance(System.Object)">
             return a bool from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerBoolean.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Boolean from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerEnumerated.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerEnumerated.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Enumerated from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerExternal">
            Class representing the DER-type External
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerExternal.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1ObjectDescriptor,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerTaggedObject)">
            Creates a new instance of DerExternal
            See X.690 for more informations about the meaning of these parameters
            @param directReference The direct reference or <code>null</code> if not set.
            @param indirectReference The indirect reference or <code>null</code> if not set.
            @param dataValueDescriptor The data value descriptor or <code>null</code> if not set.
            @param externalData The external data in its encoded form.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerExternal.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1ObjectDescriptor,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Object)">
            Creates a new instance of DerExternal.
            See X.690 for more informations about the meaning of these parameters
            @param directReference The direct reference or <code>null</code> if not set.
            @param indirectReference The indirect reference or <code>null</code> if not set.
            @param dataValueDescriptor The data value descriptor or <code>null</code> if not set.
            @param encoding The encoding to be used for the external data
            @param externalData The external data
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerExternal.Encoding">
            The encoding of the content. Valid values are
            <ul>
            <li><code>0</code> single-ASN1-type</li>
            <li><code>1</code> OCTET STRING</li>
            <li><code>2</code> BIT STRING</li>
            </ul>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerGraphicString.GetInstance(System.Object)">
             return a Graphic String from the passed in object
            
             @param obj a DerGraphicString or an object that can be converted into one.
             @exception IllegalArgumentException if the object cannot be converted.
             @return a DerGraphicString instance, or null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerGraphicString.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Graphic String from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception IllegalArgumentException if the tagged object cannot be converted.
             @return a DerGraphicString instance, or null.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerIA5String">
            IA5String object - this is an Ascii string.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerIA5String.GetInstance(System.Object)">
             return an IA5 string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerIA5String.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an IA5 string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in an IA5String.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerIA5String.IsIA5String(System.String)">
             return true if the passed in String can be represented without
             loss as an IA5String, false otherwise.
            
             @return true if in printable set, false otherwise.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerInteger.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerInteger.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Integer from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot  be converted.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerInteger.PositiveValue">
            in some cases positive values Get crammed into a space,
            that's not quite big enough...
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerInteger.IsMalformed(System.Byte[])">
             Apply the correct validation for an INTEGER primitive following the BER rules.
            
             @param bytes The raw encoding of the integer.
             @return true if the (in)put fails this validation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerNull">
            A Null object.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerNumericString">
            Der NumericString object - this is an ascii string of characters {0,1,2,3,4,5,6,7,8,9, }.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerNumericString.GetInstance(System.Object)">
             return a numeric string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerNumericString.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a numeric string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in a NumericString.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerNumericString.IsNumericString(System.String)">
             Return true if the string can be represented as a NumericString ('0'..'9', ' ')
            
             @param str string to validate.
             @return true if numeric, fale otherwise.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier.GetInstance(System.Object)">
             return an OID from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier.On(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return  true if this oid is an extension of the passed in branch, stem.
            @param stem the arc or branch that is a possible parent.
            @return  true if the branch is on the passed in stem, false otherwise.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerOctetString.#ctor(System.Byte[])">
            <param name="contents">The octets making up the octet string.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerPrintableString">
            Der PrintableString object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerPrintableString.GetInstance(System.Object)">
             return a printable string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerPrintableString.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a printable string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in a PrintableString.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerPrintableString.IsPrintableString(System.String)">
             return true if the passed in String can be represented without
             loss as a PrintableString, false otherwise.
            
             @return true if in printable set, false otherwise.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerSequence.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerSequence.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing two objects
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerSequence.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerSet">
            A Der encoded set object
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerSet.#ctor">
            create an empty set
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerSet.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param obj - a single object that makes up the set.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerSet.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            @param v - a vector of objects making up the set.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerT61String">
            Der T61String (also the teletex string) - 8-bit characters
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerT61String.GetInstance(System.Object)">
             return a T61 string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerT61String.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a T61 string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerTaggedObject">
            DER TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Boolean,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param isExplicit true if an explicitly tagged object.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerUniversalString">
            UniversalString object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerUniversalString.GetInstance(System.Object)">
             return a universal string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerUniversalString.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a universal string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerUtf8String">
            Der UTF8String object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerUtf8String.GetInstance(System.Object)">
             return an UTF8 string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerUtf8String.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a UTF8 string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerVideotexString.GetInstance(System.Object)">
             return a videotex string from the passed in object
            
             @param obj a DERVideotexString or an object that can be converted into one.
             @exception IllegalArgumentException if the object cannot be converted.
             @return a DERVideotexString instance, or null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerVideotexString.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a videotex string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception IllegalArgumentException if the tagged object cannot be converted.
             @return a DERVideotexString instance, or null.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerVisibleString">
            VisibleString object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerVisibleString.GetInstance(System.Object)">
             return a visible string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerVisibleString.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a visible string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DLBitString">
            <summary>A Definite length BIT STRING</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DLBitStringParser">
            <summary>Parser for a DL encoded BIT STRING.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DLSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DLSequence.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DLSequence.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing two objects
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DLSequence.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DLSet.#ctor">
            create an empty set
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DLSet.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a set containing one object
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DLSet.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a set containing a vector of objects.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DLTaggedObjectParser">
            Parser for definite-length tagged objects.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.EdEC.EdECObjectIdentifiers">
            Edwards Elliptic Curve Object Identifiers (RFC 8410)
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.CertificateValues">
            <remarks>
            RFC 3126: 4.3.1 Certificate Values Attribute Definition
            <code>
            CertificateValues ::= SEQUENCE OF Certificate
            </code>
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.CommitmentTypeIndication.ToAsn1Object">
            <pre>
            CommitmentTypeIndication ::= SEQUENCE {
                 commitmentTypeId   CommitmentTypeIdentifier,
                 commitmentTypeQualifier   SEQUENCE SIZE (1..MAX) OF
                         CommitmentTypeQualifier OPTIONAL }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier">
             Commitment type qualifiers, used in the Commitment-Type-Indication attribute (RFC3126).
            
             <pre>
               CommitmentTypeQualifier ::= SEQUENCE {
                   commitmentTypeIdentifier  CommitmentTypeIdentifier,
                   qualifier          ANY DEFINED BY commitmentTypeIdentifier OPTIONAL }
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             Creates a new <code>CommitmentTypeQualifier</code> instance.
            
             @param commitmentTypeIdentifier a <code>CommitmentTypeIdentifier</code> value
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
             Creates a new <code>CommitmentTypeQualifier</code> instance.
            
             @param commitmentTypeIdentifier a <code>CommitmentTypeIdentifier</code> value
             @param qualifier the qualifier, defined by the above field.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>CommitmentTypeQualifier</code> instance.
            
             @param as <code>CommitmentTypeQualifier</code> structure
             encoded as an Asn1Sequence.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier.ToAsn1Object">
             Returns a DER-encodable representation of this instance.
            
             @return a <code>Asn1Object</code> value
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.CompleteCertificateRefs">
            <remarks>
            RFC 3126: 4.2.1 Complete Certificate Refs Attribute Definition
            <code>
            CompleteCertificateRefs ::= SEQUENCE OF OtherCertID
            </code>
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.CompleteRevocationRefs">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CompleteRevocationRefs ::= SEQUENCE OF CrlOcspRef
            </code>
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.CrlIdentifier">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CrlIdentifier ::= SEQUENCE 
            {
            	crlissuer		Name,
            	crlIssuedTime	UTCTime,
            	crlNumber		INTEGER OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.CrlListID">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CRLListID ::= SEQUENCE 
            {
            	crls	SEQUENCE OF CrlValidatedID
            }
            </code>
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.CrlOcspRef">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CrlOcspRef ::= SEQUENCE {
            	crlids		[0] CRLListID		OPTIONAL,
            	ocspids		[1] OcspListID		OPTIONAL,
            	otherRev	[2] OtherRevRefs	OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.CrlValidatedID">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CrlValidatedID ::= SEQUENCE {
            	crlHash			OtherHash,
            	crlIdentifier	CrlIdentifier OPTIONAL}
            </code>
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.OcspIdentifier">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            OcspIdentifier ::= SEQUENCE {
            	ocspResponderID		ResponderID,
            		-- As in OCSP response data
            	producedAt			GeneralizedTime
            		-- As in OCSP response data
            }
            </code>
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.OcspListID">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            OcspListID ::=  SEQUENCE {
            	ocspResponses	SEQUENCE OF OcspResponsesID
            }
            </code>
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.OcspResponsesID">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            OcspResponsesID ::= SEQUENCE {
            	ocspIdentifier	OcspIdentifier,
            	ocspRepHash		OtherHash OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.OtherCertID">
            <remarks>
            <code>
            OtherCertID ::= SEQUENCE {
            	otherCertHash	OtherHash,
            	issuerSerial	IssuerSerial OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.OtherHash">
            <remarks>
            <code>
            OtherHash ::= CHOICE {
            	sha1Hash	OtherHashValue, -- This contains a SHA-1 hash
            	otherHash	OtherHashAlgAndValue
            }
            
            OtherHashValue ::= OCTET STRING
            </code>
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.OtherHashAlgAndValue">
            <summary>
            Summary description for OtherHashAlgAndValue.
            </summary>
            <remarks>
            <code>
            OtherHashAlgAndValue ::= SEQUENCE {
            	hashAlgorithm	AlgorithmIdentifier,
            	hashValue		OtherHashValue
            }
            
            OtherHashValue ::= OCTET STRING
            </code>
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.OtherRevRefs">
             <remarks>
             RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
             <code>
             OtherRevRefs ::= SEQUENCE 
             {
            		otherRevRefType      OtherRevRefType,
            		otherRevRefs         ANY DEFINED BY otherRevRefType
             }
            
             OtherRevRefType ::= OBJECT IDENTIFIER
             </code>
             </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.OtherRevVals">
             <remarks>
             RFC 3126: 4.3.2 Revocation Values Attribute Definition
             <code>
             OtherRevVals ::= SEQUENCE 
             {
            		otherRevValType      OtherRevValType,
            		otherRevVals         ANY DEFINED BY otherRevValType
             }
            
             OtherRevValType ::= OBJECT IDENTIFIER
             </code>
             </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.OtherSigningCertificate">
            <remarks>
            <code>
            OtherSigningCertificate ::= SEQUENCE {
            	certs		SEQUENCE OF OtherCertID,
            	policies	SEQUENCE OF PolicyInformation OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.RevocationValues">
            <remarks>
            RFC 5126: 6.3.4.  revocation-values Attribute Definition
            <code>
            RevocationValues ::=  SEQUENCE {
            	crlVals			[0] SEQUENCE OF CertificateList     OPTIONAL,
            	ocspVals		[1] SEQUENCE OF BasicOCSPResponse   OPTIONAL,
            	otherRevVals	[2] OtherRevVals OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.SignaturePolicyId">
            <remarks>
            <code>
            SignaturePolicyId ::= SEQUENCE {
            	sigPolicyIdentifier		SigPolicyId,
            	sigPolicyHash			SigPolicyHash,
            	sigPolicyQualifiers		SEQUENCE SIZE (1..MAX) OF SigPolicyQualifierInfo OPTIONAL
            }
            
            SigPolicyId ::= OBJECT IDENTIFIER
            
            SigPolicyHash ::= OtherHashAlgAndValue
            </code>
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.SignaturePolicyIdentifier">
            <remarks>
            <code>
            SignaturePolicyIdentifier ::= CHOICE {
            	SignaturePolicyId		SignaturePolicyId,
            	SignaturePolicyImplied	SignaturePolicyImplied
            }
            
            SignaturePolicyImplied ::= NULL
            </code>
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.SignerAttribute.ToAsn1Object">
            
             <pre>
              SignerAttribute ::= SEQUENCE OF CHOICE {
                  claimedAttributes   [0] ClaimedAttributes,
                  certifiedAttributes [1] CertifiedAttributes }
            
              ClaimedAttributes ::= SEQUENCE OF Attribute
              CertifiedAttributes ::= AttributeCertificate -- as defined in RFC 3281: see clause 4.1.
             </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.SignerLocation">
             Signer-Location attribute (RFC3126).
            
             <pre>
               SignerLocation ::= SEQUENCE {
                   countryName        [0] DirectoryString OPTIONAL,
                   localityName       [1] DirectoryString OPTIONAL,
                   postalAddress      [2] PostalAddress OPTIONAL }
            
               PostalAddress ::= SEQUENCE SIZE(1..6) OF DirectoryString
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.SignerLocation.ToAsn1Object">
             <pre>
               SignerLocation ::= SEQUENCE {
                   countryName        [0] DirectoryString OPTIONAL,
                   localityName       [1] DirectoryString OPTIONAL,
                   postalAddress      [2] PostalAddress OPTIONAL }
            
               PostalAddress ::= SEQUENCE SIZE(1..6) OF DirectoryString
            
               DirectoryString ::= CHOICE {
                     teletexString           TeletexString (SIZE (1..MAX)),
                     printableString         PrintableString (SIZE (1..MAX)),
                     universalString         UniversalString (SIZE (1..MAX)),
                     utf8String              UTF8String (SIZE (1.. MAX)),
                     bmpString               BMPString (SIZE (1..MAX)) }
             </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Esf.SigPolicyQualifierInfo">
            <remarks>
            <code>
            SigPolicyQualifierInfo ::= SEQUENCE {
            	sigPolicyQualifierId  SigPolicyQualifierId,
            	sigQualifier          ANY DEFINED BY sigPolicyQualifierId
            }
            
            SigPolicyQualifierId ::= OBJECT IDENTIFIER
            </code>
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ess.ContentHints.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
            constructor
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ess.ContentHints.ToAsn1Object">
            <pre>
            ContentHints ::= SEQUENCE {
              contentDescription UTF8String (SIZE (1..MAX)) OPTIONAL,
              contentType ContentType }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ess.ContentIdentifier.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1OctetString)">
            Create from OCTET STRING whose octets represent the identifier.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ess.ContentIdentifier.#ctor(System.Byte[])">
            Create from byte array representing the identifier.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ess.ContentIdentifier.ToAsn1Object">
            The definition of ContentIdentifier is
            <pre>
            ContentIdentifier ::=  OCTET STRING
            </pre>
            id-aa-contentIdentifier OBJECT IDENTIFIER ::= { iso(1)
             member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)
             smime(16) id-aa(2) 7 }
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ess.EssCertID.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
            constructor
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ess.EssCertID.ToAsn1Object">
            <pre>
            EssCertID ::= SEQUENCE {
                certHash Hash,
                issuerSerial IssuerSerial OPTIONAL }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ess.EssCertIDv2.ToAsn1Object">
             <pre>
             EssCertIDv2 ::=  SEQUENCE {
                 hashAlgorithm     AlgorithmIdentifier
                          DEFAULT {algorithm id-sha256},
                 certHash          Hash,
                 issuerSerial      IssuerSerial OPTIONAL
             }
            
             Hash ::= OCTET STRING
            
             IssuerSerial ::= SEQUENCE {
                 issuer         GeneralNames,
                 serialNumber   CertificateSerialNumber
             }
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ess.SigningCertificate.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
            constructors
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ess.SigningCertificate.ToAsn1Object">
            The definition of SigningCertificate is
            <pre>
            SigningCertificate ::=  SEQUENCE {
                 certs        SEQUENCE OF EssCertID,
                 policies     SEQUENCE OF PolicyInformation OPTIONAL
            }
            </pre>
            id-aa-signingCertificate OBJECT IDENTIFIER ::= { iso(1)
             member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)
             smime(16) id-aa(2) 12 }
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ess.SigningCertificateV2.ToAsn1Object">
            The definition of SigningCertificateV2 is
            <pre>
            SigningCertificateV2 ::=  SEQUENCE {
                 certs        SEQUENCE OF EssCertIDv2,
                 policies     SEQUENCE OF PolicyInformation OPTIONAL
            }
            </pre>
            id-aa-signingCertificateV2 OBJECT IDENTIFIER ::= { iso(1)
               member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)
               smime(16) id-aa(2) 47 }
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.GM.GMNamedCurves">
            <summary>Elliptic curve registry for GM.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.GM.GMNamedCurves.GetByName(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.GM.GMNamedCurves.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.GM.GMNamedCurves.GetByOid(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.GM.GMNamedCurves.GetByOidLazy(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.GM.GMNamedCurves.GetName(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.GM.GMNamedCurves.GetOid(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.GM.GMNamedCurves.Names">
            <summary>Enumerate the available curve names in this registry.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Gnu.GnuObjectIdentifiers.EllipticCurve">
            1.3.6.1.4.1.11591.15 - ellipticCurve 
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IAsn1Choice">
            Marker interface for CHOICE objects - if you implement this in a roll-your-own
            object, any attempt to tag the object implicitly will convert the tag to an
            explicit one as the encoding rules require.
            <p>
            If you use this interface your class should also implement the getInstance
            pattern which takes a tag object and the tagging mode used. 
            </p>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IAsn1String">
            basic interface for Der string objects.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Icao.CscaMasterList">
             The CscaMasterList object. This object can be wrapped in a
             CMSSignedData to be published in LDAP.
            
             <pre>
             CscaMasterList ::= SEQUENCE {
               version                CscaMasterListVersion,
               certList               SET OF Certificate }
               
             CscaMasterListVersion :: INTEGER {v0(0)}
             </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Icao.DataGroupHash">
             The DataGroupHash object.
             <pre>
             DataGroupHash  ::=  SEQUENCE {
                  dataGroupNumber         DataGroupNumber,
                  dataGroupHashValue     OCTET STRING }
            
             DataGroupNumber ::= INTEGER {
                     dataGroup1    (1),
                     dataGroup1    (2),
                     dataGroup1    (3),
                     dataGroup1    (4),
                     dataGroup1    (5),
                     dataGroup1    (6),
                     dataGroup1    (7),
                     dataGroup1    (8),
                     dataGroup1    (9),
                     dataGroup1    (10),
                     dataGroup1    (11),
                     dataGroup1    (12),
                     dataGroup1    (13),
                     dataGroup1    (14),
                     dataGroup1    (15),
                     dataGroup1    (16) }
            
             </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Icao.LdsSecurityObject">
             The LDSSecurityObject object (V1.8).
             <pre>
             LDSSecurityObject ::= SEQUENCE {
               version                LDSSecurityObjectVersion,
               hashAlgorithm          DigestAlgorithmIdentifier,
               dataGroupHashValues    SEQUENCE SIZE (2..ub-DataGroups) OF DataHashGroup,
               ldsVersionInfo         LDSVersionInfo OPTIONAL
                 -- if present, version MUST be v1 }
            
             DigestAlgorithmIdentifier ::= AlgorithmIdentifier,
            
             LDSSecurityObjectVersion :: INTEGER {V0(0)}
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Icao.LdsVersionInfo.ToAsn1Object">
            <pre>
            LDSVersionInfo ::= SEQUENCE {
               ldsVersion PRINTABLE STRING
               unicodeVersion PRINTABLE STRING
             }
            </pre>
            @return
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttCPAccredited">
            The id-isismtt-cp-accredited OID indicates that the certificate is a
            qualified certificate according to Directive 1999/93/EC of the European
            Parliament and of the Council of 13 December 1999 on a Community
            Framework for Electronic Signatures, which additionally conforms the
            special requirements of the SigG and has been issued by an accredited CA.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATDateOfCertGen">
             Certificate extensionDate of certificate generation
             
             <pre>
            		DateOfCertGenSyntax ::= GeneralizedTime
             </pre>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATProcuration">
            Attribute to indicate that the certificate holder may sign in the name of
            a third person. May also be used as extension in a certificate.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATAdmission">
            Attribute to indicate admissions to certain professions. May be used as
            attribute in attribute certificate or as extension in a certificate
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATMonetaryLimit">
            Monetary limit for transactions. The QcEuMonetaryLimit QC statement MUST
            be used in new certificates in place of the extension/attribute
            MonetaryLimit since January 1, 2004. For the sake of backward
            compatibility with certificates already in use, SigG conforming
            components MUST support MonetaryLimit (as well as QcEuLimitValue).
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATDeclarationOfMajority">
            A declaration of majority. May be used as attribute in attribute
            certificate or as extension in a certificate
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATIccsn">
             
             Serial number of the smart card containing the corresponding private key
             
             <pre>
            		ICCSNSyntax ::= OCTET STRING (SIZE(8..20))
             </pre>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATPKReference">
             
             Reference for a file of a smartcard that stores the public key of this
             certificate and that is used as security anchor.
             
             <pre>
            		PKReferenceSyntax ::= OCTET STRING (SIZE(20))
             </pre>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATRestriction">
             Some other restriction regarding the usage of this certificate. May be
             used as attribute in attribute certificate or as extension in a
             certificate.
             
             <pre>
            		RestrictionSyntax ::= DirectoryString (SIZE(1..1024))
             </pre>
             
             @see Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATRetrieveIfAllowed">
             
             (Single)Request extension: Clients may include this extension in a
             (single) Request to request the responder to send the certificate in the
             response message along with the status information. Besides the LDAP
             service, this extension provides another mechanism for the distribution
             of certificates, which MAY optionally be provided by certificate
             repositories.
             
             <pre>
            		RetrieveIfAllowed ::= BOOLEAN
             </pre>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATRequestedCertificate">
            SingleOCSPResponse extension: The certificate requested by the client by
            inserting the RetrieveIfAllowed extension in the request, will be
            returned in this extension.
            
            @see Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATNamingAuthorities">
            Base ObjectIdentifier for naming authorities
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATCertInDirSince">
             SingleOCSPResponse extension: Date, when certificate has been published
             in the directory and status information has become available. Currently,
             accrediting authorities enforce that SigG-conforming OCSP servers include
             this extension in the responses.
             
             <pre>
            		CertInDirSince ::= GeneralizedTime
             </pre>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATCertHash">
             Hash of a certificate in OCSP.
            
             @see Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATNameAtBirth">
             <pre>
            		NameAtBirth ::= DirectoryString(SIZE(1..64)
             </pre>
             
             Used in
             {@link Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes SubjectDirectoryAttributes}
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATAdditionalInformation">
            Some other information of non-restrictive nature regarding the usage of
            this certificate. May be used as attribute in atribute certificate or as
            extension in a certificate.
            
            <pre>
                          AdditionalInformationSyntax ::= DirectoryString (SIZE(1..2048))
            </pre>
            
            @see Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATLiabilityLimitationFlag">
             Indicates that an attribute certificate exists, which limits the
             usability of this public key certificate. Whenever verifying a signature
             with the help of this certificate, the content of the corresponding
             attribute certificate should be concerned. This extension MUST be
             included in a PKC, if a corresponding attribute certificate (having the
             PKC as base certificate) contains some attribute that restricts the
             usability of the PKC too. Attribute certificates with restricting content
             MUST always be included in the signed document.
             
             <pre>
            		LiabilityLimitationFlagSyntax ::= BOOLEAN
             </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash">
            ISIS-MTT PROFILE: The responder may include this extension in a response to
            send the hash of the requested certificate to the responder. This hash is
            cryptographically bound to the certificate and serves as evidence that the
            certificate is known to the responder (i.e. it has been issued and is present
            in the directory). Hence, this extension is a means to provide a positive
            statement of availability as described in T8.[8]. As explained in T13.[1],
            clients may rely on this information to be able to validate signatures after
            the expiry of the corresponding certificate. Hence, clients MUST support this
            extension. If a positive statement of availability is to be delivered, this
            extension syntax and OID MUST be used.
            <p/>
            <p/>
            <pre>
                CertHash ::= SEQUENCE {
                  hashAlgorithm AlgorithmIdentifier,
                  certificateHash OCTET STRING
                }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type CertHash:
             <p/>
             <pre>
                 CertHash ::= SEQUENCE {
                   hashAlgorithm AlgorithmIdentifier,
                   certificateHash OCTET STRING
                 }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,System.Byte[])">
             Constructor from a given details.
            
             @param hashAlgorithm   The hash algorithm identifier.
             @param certificateHash The hash of the whole DER encoding of the certificate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                 CertHash ::= SEQUENCE {
                   hashAlgorithm AlgorithmIdentifier,
                   certificateHash OCTET STRING
                 }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate">
            ISIS-MTT-Optional: The certificate requested by the client by inserting the
            RetrieveIfAllowed extension in the request, will be returned in this
            extension.
            <p/>
            ISIS-MTT-SigG: The signature act allows publishing certificates only then,
            when the certificate owner gives his isExplicit permission. Accordingly, there
            may be nondownloadable certificates, about which the responder must provide
            status information, but MUST NOT include them in the response. Clients may
            get therefore the following three kind of answers on a single request
            including the RetrieveIfAllowed extension:
            <ul>
            <li> a) the responder supports the extension and is allowed to publish the
            certificate: RequestedCertificate returned including the requested
            certificate</li>
            <li>b) the responder supports the extension but is NOT allowed to publish
            the certificate: RequestedCertificate returned including an empty OCTET
            STRING</li>
            <li>c) the responder does not support the extension: RequestedCertificate is
            not included in the response</li>
            </ul>
            Clients requesting RetrieveIfAllowed MUST be able to handle these cases. If
            any of the OCTET STRING options is used, it MUST contain the DER encoding of
            the requested certificate.
            <p/>
            <pre>
                       RequestedCertificate ::= CHOICE {
                         Certificate Certificate,
                         publicKeyCertificate [0] EXPLICIT OCTET STRING,
                         attributeCertificate [1] EXPLICIT OCTET STRING
                       }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509CertificateStructure)">
             Constructor from a given details.
             <p/>
             Only one parameter can be given. All other must be <code>null</code>.
            
             @param certificate Given as Certificate
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                        RequestedCertificate ::= CHOICE {
                          Certificate Certificate,
                          publicKeyCertificate [0] EXPLICIT OCTET STRING,
                          attributeCertificate [1] EXPLICIT OCTET STRING
                        }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax">
            Some other information of non-restrictive nature regarding the usage of this
            certificate.
            
            <pre>
               AdditionalInformationSyntax ::= DirectoryString (SIZE(1..2048))
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax.#ctor(System.String)">
             Constructor from a given details.
            
             @param information The describtion of the information.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
               AdditionalInformationSyntax ::= DirectoryString (SIZE(1..2048))
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions">
             An Admissions structure.
             <p/>
             <pre>
                        Admissions ::= SEQUENCE
                        {
                          admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                          namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                          professionInfos SEQUENCE OF ProfessionInfo
                        }
             <p/>
             </pre>
            
             @see Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax
             @see Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo
             @see Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type ProcurationSyntax:
             <p/>
             <pre>
                        Admissions ::= SEQUENCE
                        {
                          admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                          namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                          professionInfos SEQUENCE OF ProfessionInfo
                        }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo[])">
             Constructor from a given details.
             <p/>
             Parameter <code>professionInfos</code> is mandatory.
            
             @param admissionAuthority The admission authority.
             @param namingAuthority    The naming authority.
             @param professionInfos    The profession infos.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                   Admissions ::= SEQUENCE
                   {
                     admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                     namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                     professionInfos SEQUENCE OF ProfessionInfo
                   }
             <p/>
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax">
             Attribute to indicate admissions to certain professions.
             <p/>
             <pre>
                 AdmissionSyntax ::= SEQUENCE
                 {
                   admissionAuthority GeneralName OPTIONAL,
                   contentsOfAdmissions SEQUENCE OF Admissions
                 }
             <p/>
                 Admissions ::= SEQUENCE
                 {
                   admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                   namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                   professionInfos SEQUENCE OF ProfessionInfo
                 }
             <p/>
                 NamingAuthority ::= SEQUENCE
                 {
                   namingAuthorityId OBJECT IDENTIFIER OPTIONAL,
                   namingAuthorityUrl IA5String OPTIONAL,
                   namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                 }
             <p/>
                 ProfessionInfo ::= SEQUENCE
                 {
                   namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                   professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                   professionOIDs SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                   registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                   addProfessionInfo OCTET STRING OPTIONAL
                 }
             </pre>
             <p/>
             <p/>
             ISIS-MTT PROFILE: The relatively complex structure of AdmissionSyntax
             supports the following concepts and requirements:
             <ul>
             <li> External institutions (e.g. professional associations, chambers, unions,
             administrative bodies, companies, etc.), which are responsible for granting
             and verifying professional admissions, are indicated by means of the data
             field admissionAuthority. An admission authority is indicated by a
             GeneralName object. Here an X.501 directory name (distinguished name) can be
             indicated in the field directoryName, a URL address can be indicated in the
             field uniformResourceIdentifier, and an object identifier can be indicated in
             the field registeredId.</li>
             <li> The names of authorities which are responsible for the administration of
             title registers are indicated in the data field namingAuthority. The name of
             the authority can be identified by an object identifier in the field
             namingAuthorityId, by means of a text string in the field
             namingAuthorityText, by means of a URL address in the field
             namingAuthorityUrl, or by a combination of them. For example, the text string
             can contain the name of the authority, the country and the name of the title
             register. The URL-option refers to a web page which contains lists with
             officially registered professions (text and possibly OID) as well as
             further information on these professions. Object identifiers for the
             component namingAuthorityId are grouped under the OID-branch
             id-isis-at-namingAuthorities and must be applied for.</li>
             <li>See http://www.teletrust.de/anwend.asp?Id=30200&amp;Sprache=E_&amp;HomePG=0
             for an application form and http://www.teletrust.de/links.asp?id=30220,11
             for an overview of registered naming authorities.</li>
             <li> By means of the data type ProfessionInfo certain professions,
             specializations, disciplines, fields of activity, etc. are identified. A
             profession is represented by one or more text strings, resp. profession OIDs
             in the fields professionItems and professionOIDs and by a registration number
             in the field registrationNumber. An indication in text form must always be
             present, whereas the other indications are optional. The component
             addProfessionInfo may contain additional applicationspecific information in
             DER-encoded form.</li>
             </ul>
             <p/>
             By means of different namingAuthority-OIDs or profession OIDs hierarchies of
             professions, specializations, disciplines, fields of activity, etc. can be
             expressed. The issuing admission authority should always be indicated (field
             admissionAuthority), whenever a registration number is presented. Still,
             information on admissions can be given without indicating an admission or a
             naming authority by the exclusive use of the component professionItems. In
             this case the certification authority is responsible for the verification of
             the admission information.
             <p/>
             <p/>
             <p/>
             This attribute is single-valued. Still, several admissions can be captured in
             the sequence structure of the component contentsOfAdmissions of
             AdmissionSyntax or in the component professionInfos of Admissions. The
             component admissionAuthority of AdmissionSyntax serves as default value for
             the component admissionAuthority of Admissions. Within the latter component
             the default value can be overwritten, in case that another authority is
             responsible. The component namingAuthority of Admissions serves as a default
             value for the component namingAuthority of ProfessionInfo. Within the latter
             component the default value can be overwritten, in case that another naming
             authority needs to be recorded.
             <p/>
             The length of the string objects is limited to 128 characters. It is
             recommended to indicate a namingAuthorityURL in all issued attribute
             certificates. If a namingAuthorityURL is indicated, the field professionItems
             of ProfessionInfo should contain only registered titles. If the field
             professionOIDs exists, it has to contain the OIDs of the professions listed
             in professionItems in the same order. In general, the field professionInfos
             should contain only one entry, unless the admissions that are to be listed
             are logically connected (e.g. they have been issued under the same admission
             number).
            
             @see Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions
             @see Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo
             @see Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type ProcurationSyntax:
             <p/>
             <pre>
                 AdmissionSyntax ::= SEQUENCE
                 {
                   admissionAuthority GeneralName OPTIONAL,
                   contentsOfAdmissions SEQUENCE OF Admissions
                 }
             <p/>
                 Admissions ::= SEQUENCE
                 {
                   admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                   namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                   professionInfos SEQUENCE OF ProfessionInfo
                 }
             <p/>
                 NamingAuthority ::= SEQUENCE
                 {
                   namingAuthorityId OBJECT IDENTIFIER OPTIONAL,
                   namingAuthorityUrl IA5String OPTIONAL,
                   namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                 }
             <p/>
                 ProfessionInfo ::= SEQUENCE
                 {
                   namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                   professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                   professionOIDs SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                   registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                   addProfessionInfo OCTET STRING OPTIONAL
                 }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from given details.
            
             @param admissionAuthority   The admission authority.
             @param contentsOfAdmissions The admissions.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                 AdmissionSyntax ::= SEQUENCE
                 {
                   admissionAuthority GeneralName OPTIONAL,
                   contentsOfAdmissions SEQUENCE OF Admissions
                 }
             <p/>
                 Admissions ::= SEQUENCE
                 {
                   admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                   namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                   professionInfos SEQUENCE OF ProfessionInfo
                 }
             <p/>
                 NamingAuthority ::= SEQUENCE
                 {
                   namingAuthorityId OBJECT IDENTIFIER OPTIONAL,
                   namingAuthorityUrl IA5String OPTIONAL,
                   namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                 }
             <p/>
                 ProfessionInfo ::= SEQUENCE
                 {
                   namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                   professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                   professionOIDs SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                   registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                   addProfessionInfo OCTET STRING OPTIONAL
                 }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.AdmissionAuthority">
            @return Returns the admissionAuthority if present, null otherwise.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.GetContentsOfAdmissions">
            @return Returns the contentsOfAdmissions.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.DeclarationOfMajority">
            A declaration of majority.
            <p/>
            <pre>
                      DeclarationOfMajoritySyntax ::= CHOICE
                      {
                        notYoungerThan [0] IMPLICIT INTEGER,
                        fullAgeAtCountry [1] IMPLICIT SEQUENCE
                        {
                          fullAge BOOLEAN DEFAULT TRUE,
                          country PrintableString (SIZE(2))
                        }
                        dateOfBirth [2] IMPLICIT GeneralizedTime
                      }
            </pre>
            <p/>
            fullAgeAtCountry indicates the majority of the owner with respect to the laws
            of a specific country.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.DeclarationOfMajority.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                       DeclarationOfMajoritySyntax ::= CHOICE
                       {
                         notYoungerThan [0] IMPLICIT INTEGER,
                         fullAgeAtCountry [1] IMPLICIT SEQUENCE
                         {
                           fullAge BOOLEAN DEFAULT TRUE,
                           country PrintableString (SIZE(2))
                         }
                         dateOfBirth [2] IMPLICIT GeneralizedTime
                       }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.DeclarationOfMajority.NotYoungerThan">
            @return notYoungerThan if that's what we are, -1 otherwise
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.MonetaryLimit">
            Monetary limit for transactions. The QcEuMonetaryLimit QC statement MUST be
            used in new certificates in place of the extension/attribute MonetaryLimit
            since January 1, 2004. For the sake of backward compatibility with
            certificates already in use, components SHOULD support MonetaryLimit (as well
            as QcEuLimitValue).
            <p/>
            Indicates a monetary limit within which the certificate holder is authorized
            to act. (This value DOES NOT express a limit on the liability of the
            certification authority).
            <p/>
            <pre>
               MonetaryLimitSyntax ::= SEQUENCE
               {
                 currency PrintableString (SIZE(3)),
                 amount INTEGER,
                 exponent INTEGER
               }
            </pre>
            <p/>
            currency must be the ISO code.
            <p/>
            value = amount10*exponent
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.MonetaryLimit.#ctor(System.String,System.Int32,System.Int32)">
             Constructor from a given details.
             <p/>
             <p/>
             value = amount10^exponent
            
             @param currency The currency. Must be the ISO code.
             @param amount   The amount
             @param exponent The exponent
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.MonetaryLimit.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                MonetaryLimitSyntax ::= SEQUENCE
                {
                  currency PrintableString (SIZE(3)),
                  amount INTEGER,
                  exponent INTEGER
                }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority">
            Names of authorities which are responsible for the administration of title
            registers.
            
            <pre>
                        NamingAuthority ::= SEQUENCE 
                        {
                          namingAuthorityID OBJECT IDENTIFIER OPTIONAL,
                          namingAuthorityUrl IA5String OPTIONAL,
                          namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                        }
            </pre>
            @see Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax
            
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.IdIsisMttATNamingAuthoritiesRechtWirtschaftSteuern">
            Profession OIDs should always be defined under the OID branch of the
            responsible naming authority. At the time of this writing, the work group
            Recht, Wirtschaft, Steuern (Law, Economy, Taxes) is registered as the
            first naming authority under the OID id-isismtt-at-namingAuthorities.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             <p/>
             <pre>
                         NamingAuthority ::= SEQUENCE
                         {
                           namingAuthorityID OBJECT IDENTIFIER OPTIONAL,
                           namingAuthorityUrl IA5String OPTIONAL,
                           namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                         }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.NamingAuthorityID">
            @return Returns the namingAuthorityID.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.NamingAuthorityText">
            @return Returns the namingAuthorityText.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.NamingAuthorityUrl">
            @return Returns the namingAuthorityUrl.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.DirectoryString)">
             Constructor from given details.
             <p/>
             All parameters can be combined.
            
             @param namingAuthorityID   ObjectIdentifier for naming authority.
             @param namingAuthorityUrl  URL for naming authority.
             @param namingAuthorityText Textual representation of naming authority.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                         NamingAuthority ::= SEQUENCE
                         {
                           namingAuthorityID OBJECT IDENTIFIER OPTIONAL,
                           namingAuthorityUrl IA5String OPTIONAL,
                           namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                         }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax">
            Attribute to indicate that the certificate holder may sign in the name of a
            third person.
            <p>
            ISIS-MTT PROFILE: The corresponding ProcurationSyntax contains either the
            name of the person who is represented (subcomponent thirdPerson) or a
            reference to his/her base certificate (in the component signingFor,
            subcomponent certRef), furthermore the optional components country and
            typeSubstitution to indicate the country whose laws apply, and respectively
            the type of procuration (e.g. manager, procuration, custody).
            </p>
            <p>
            ISIS-MTT PROFILE: The GeneralName MUST be of type directoryName and MAY only
            contain: - RFC3039 attributes, except pseudonym (countryName, commonName,
            surname, givenName, serialNumber, organizationName, organizationalUnitName,
            stateOrProvincename, localityName, postalAddress) and - SubjectDirectoryName
            attributes (title, dateOfBirth, placeOfBirth, gender, countryOfCitizenship,
            countryOfResidence and NameAtBirth).
            </p>
            <pre>
                          ProcurationSyntax ::= SEQUENCE {
                            country [1] EXPLICIT PrintableString(SIZE(2)) OPTIONAL,
                            typeOfSubstitution [2] EXPLICIT DirectoryString (SIZE(1..128)) OPTIONAL,
                            signingFor [3] EXPLICIT SigningFor 
                          }
                          
                          SigningFor ::= CHOICE 
                          { 
                            thirdPerson GeneralName,
                            certRef IssuerSerial 
                          }
            </pre>
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type ProcurationSyntax:
             <p/>
             <pre>
                           ProcurationSyntax ::= SEQUENCE {
                             country [1] EXPLICIT PrintableString(SIZE(2)) OPTIONAL,
                             typeOfSubstitution [2] EXPLICIT DirectoryString (SIZE(1..128)) OPTIONAL,
                             signingFor [3] EXPLICIT SigningFor
                           }
             <p/>
                           SigningFor ::= CHOICE
                           {
                             thirdPerson GeneralName,
                             certRef IssuerSerial
                           }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax.#ctor(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.DirectoryString,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.IssuerSerial)">
             Constructor from a given details.
             <p/>
             <p/>
             Either <code>generalName</code> or <code>certRef</code> MUST be
             <code>null</code>.
            
             @param country            The country code whose laws apply.
             @param typeOfSubstitution The type of procuration.
             @param certRef            Reference to certificate of the person who is represented.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax.#ctor(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.DirectoryString,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName)">
             Constructor from a given details.
             <p/>
             <p/>
             Either <code>generalName</code> or <code>certRef</code> MUST be
             <code>null</code>.
            
             @param country            The country code whose laws apply.
             @param typeOfSubstitution The type of procuration.
             @param thirdPerson        The GeneralName of the person who is represented.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                           ProcurationSyntax ::= SEQUENCE {
                             country [1] EXPLICIT PrintableString(SIZE(2)) OPTIONAL,
                             typeOfSubstitution [2] EXPLICIT DirectoryString (SIZE(1..128)) OPTIONAL,
                             signingFor [3] EXPLICIT SigningFor
                           }
             <p/>
                           SigningFor ::= CHOICE
                           {
                             thirdPerson GeneralName,
                             certRef IssuerSerial
                           }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo">
            Professions, specializations, disciplines, fields of activity, etc.
            
            <pre>
                          ProfessionInfo ::= SEQUENCE 
                          {
                            namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                            professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                            professionOids SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                            registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                            addProfessionInfo OCTET STRING OPTIONAL 
                          }
            </pre>
            
            @see Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Rechtsanwltin">
            Rechtsanwltin
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Rechtsanwalt">
            Rechtsanwalt
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Rechtsbeistand">
            Rechtsbeistand
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Steuerberaterin">
            Steuerberaterin
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Steuerberater">
            Steuerberater
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Steuerbevollmchtigte">
            Steuerbevollmchtigte
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Steuerbevollmchtigter">
            Steuerbevollmchtigter
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notarin">
            Notarin
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notar">
            Notar
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notarvertreterin">
            Notarvertreterin
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notarvertreter">
            Notarvertreter
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notariatsverwalterin">
            Notariatsverwalterin
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notariatsverwalter">
            Notariatsverwalter
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Wirtschaftsprferin">
            Wirtschaftsprferin
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Wirtschaftsprfer">
            Wirtschaftsprfer
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.VereidigteBuchprferin">
            Vereidigte Buchprferin
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.VereidigterBuchprfer">
            Vereidigter Buchprfer
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Patentanwltin">
            Patentanwltin
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Patentanwalt">
            Patentanwalt
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             <p/>
             <pre>
                           ProfessionInfo ::= SEQUENCE
                           {
                             namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                             professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                             professionOids SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                             registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                             addProfessionInfo OCTET STRING OPTIONAL
                           }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.DirectoryString[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier[],System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1OctetString)">
             Constructor from given details.
             <p/>
             <code>professionItems</code> is mandatory, all other parameters are
             optional.
            
             @param namingAuthority    The naming authority.
             @param professionItems    Directory strings of the profession.
             @param professionOids     DERObjectIdentfier objects for the
                                       profession.
             @param registrationNumber Registration number.
             @param addProfessionInfo  Additional infos in encoded form.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                           ProfessionInfo ::= SEQUENCE
                           {
                             namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                             professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                             professionOids SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                             registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                             addProfessionInfo OCTET STRING OPTIONAL
                           }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.AddProfessionInfo">
            @return Returns the addProfessionInfo.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.NamingAuthority">
            @return Returns the namingAuthority.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.GetProfessionItems">
            @return Returns the professionItems.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.GetProfessionOids">
            @return Returns the professionOids.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.RegistrationNumber">
            @return Returns the registrationNumber.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction">
            Some other restriction regarding the usage of this certificate.
            <p/>
            <pre>
             RestrictionSyntax ::= DirectoryString (SIZE(1..1024))
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.DirectoryString)">
             Constructor from DirectoryString.
             <p/>
             The DirectoryString is of type RestrictionSyntax:
             <p/>
             <pre>
                  RestrictionSyntax ::= DirectoryString (SIZE(1..1024))
             </pre>
            
             @param restriction A IAsn1String.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction.#ctor(System.String)">
             Constructor from a given details.
            
             @param restriction The description of the restriction.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                  RestrictionSyntax ::= DirectoryString (SIZE(1..1024))
             <p/>
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Misc.Cast5CbcParameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            cast5CBCParameters ::= Sequence {
                                      iv         OCTET STRING DEFAULT 0,
                                             -- Initialization vector
                                      keyLength  Integer
                                             -- Key length, in bits
                                 }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Misc.IdeaCbcPar.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            IDEA-CBCPar ::= Sequence {
                                 iv    OCTET STRING OPTIONAL -- exactly 8 octets
                             }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Misc.NetscapeCertType">
            The NetscapeCertType object.
            <pre>
               NetscapeCertType ::= BIT STRING {
                    SSLClient               (0),
                    SSLServer               (1),
                    S/MIME                  (2),
                    Object Signing          (3),
                    Reserved                (4),
                    SSL CA                  (5),
                    S/MIME CA               (6),
                    Object Signing CA       (7) }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Misc.NetscapeCertType.#ctor(System.Int32)">
             Basic constructor.
            
             @param usage - the bitwise OR of the Key Usage flags giving the
             allowed uses for the key.
             e.g. (X509NetscapeCertType.sslCA | X509NetscapeCertType.smimeCA)
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Mozilla.PublicKeyAndChallenge">
             This is designed to parse
             the PublicKeyAndChallenge created by the KEYGEN tag included by
             Mozilla based browsers.
              <pre>
              PublicKeyAndChallenge ::= SEQUENCE {
                spki SubjectPublicKeyInfo,
                challenge IA5STRING
              }
            
              </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.KMacWithShake128Params">
            <summary>
            KMACwithSHAKE128-params ::= SEQUENCE {
                kMACOutputLength     INTEGER DEFAULT 256, -- Output length in bits
                customizationString  OCTET STRING DEFAULT ''H
            } 
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.KMacWithShake256Params">
            <summary>
            KMACwithSHAKE256-params ::= SEQUENCE {
                kMACOutputLength     INTEGER DEFAULT 512, -- Output length in bits
                customizationString  OCTET STRING DEFAULT ''H
            } 
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistNamedCurves">
            <summary>Elliptic curve registry for NIST curves.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetByName(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of
            the full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetByOid(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetByOidLazy(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of
            the full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetName(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetOid(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistNamedCurves.Names">
            <summary>Enumerate the available curve names in this registry.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdDsaWithSha3_224">
            2.16.840.1.101.3.4.3.5 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdDsaWithSha3_256">
            2.16.840.1.101.3.4.3.6 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdDsaWithSha3_384">
            2.16.840.1.101.3.4.3.7 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdDsaWithSha3_512">
            2.16.840.1.101.3.4.3.8 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdEcdsaWithSha3_224">
            2.16.840.1.101.3.4.3.9 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdEcdsaWithSha3_256">
            2.16.840.1.101.3.4.3.10 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdEcdsaWithSha3_384">
            2.16.840.1.101.3.4.3.11 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdEcdsaWithSha3_512">
            2.16.840.1.101.3.4.3.12 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdRsassaPkcs1V15WithSha3_224">
            2.16.840.1.101.3.4.3.9 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdRsassaPkcs1V15WithSha3_256">
            2.16.840.1.101.3.4.3.10 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdRsassaPkcs1V15WithSha3_384">
            2.16.840.1.101.3.4.3.11 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdRsassaPkcs1V15WithSha3_512">
            2.16.840.1.101.3.4.3.12 
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ntt.NttObjectIdentifiers">
            <summary>From RFC 3657</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.BasicOcspResponse.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            BasicOcspResponse       ::= Sequence {
                 tbsResponseData      ResponseData,
                 signatureAlgorithm   AlgorithmIdentifier,
                 signature            BIT STRING,
                 certs                [0] EXPLICIT Sequence OF Certificate OPTIONAL }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.CertID.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            CertID          ::=     Sequence {
                hashAlgorithm       AlgorithmIdentifier,
                issuerNameHash      OCTET STRING, -- Hash of Issuer's DN
                issuerKeyHash       OCTET STRING, -- Hash of Issuers public key
                serialNumber        CertificateSerialNumber }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.CertStatus.#ctor">
            create a CertStatus object with a tag of zero.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.CertStatus.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             CertStatus ::= CHOICE {
                             good        [0]     IMPLICIT Null,
                             revoked     [1]     IMPLICIT RevokedInfo,
                             unknown     [2]     IMPLICIT UnknownInfo }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.CrlID.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            CrlID ::= Sequence {
                crlUrl               [0]     EXPLICIT IA5String OPTIONAL,
                crlNum               [1]     EXPLICIT Integer OPTIONAL,
                crlTime              [2]     EXPLICIT GeneralizedTime OPTIONAL }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.OcspRequest.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OcspRequest     ::=     Sequence {
                tbsRequest                  TBSRequest,
                optionalSignature   [0]     EXPLICIT Signature OPTIONAL }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.OcspResponse.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OcspResponse ::= Sequence {
                responseStatus         OcspResponseStatus,
                responseBytes          [0] EXPLICIT ResponseBytes OPTIONAL }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.OcspResponseStatus.#ctor(System.Int32)">
            The OcspResponseStatus enumeration.
            <pre>
            OcspResponseStatus ::= Enumerated {
                successful            (0),  --Response has valid confirmations
                malformedRequest      (1),  --Illegal confirmation request
                internalError         (2),  --Internal error in issuer
                tryLater              (3),  --Try again later
                                            --(4) is not used
                sigRequired           (5),  --Must sign the request
                unauthorized          (6)   --Request unauthorized
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.Request.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Request         ::=     Sequence {
                reqCert                     CertID,
                singleRequestExtensions     [0] EXPLICIT Extensions OPTIONAL }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.ResponderID.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ResponderID ::= CHOICE {
                 byName          [1] Name,
                 byKey           [2] KeyHash }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.ResponseBytes.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ResponseBytes ::=       Sequence {
                responseType   OBJECT IDENTIFIER,
                response       OCTET STRING }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.ResponseData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ResponseData ::= Sequence {
                version              [0] EXPLICIT Version DEFAULT v1,
                responderID              ResponderID,
                producedAt               GeneralizedTime,
                responses                Sequence OF SingleResponse,
                responseExtensions   [1] EXPLICIT Extensions OPTIONAL }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.RevokedInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            RevokedInfo ::= Sequence {
                 revocationTime              GeneralizedTime,
                 revocationReason    [0]     EXPLICIT CRLReason OPTIONAL }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.ServiceLocator.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ServiceLocator ::= Sequence {
                issuer    Name,
                locator   AuthorityInfoAccessSyntax OPTIONAL }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.Signature.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Signature       ::=     Sequence {
                signatureAlgorithm      AlgorithmIdentifier,
                signature               BIT STRING,
                certs               [0] EXPLICIT Sequence OF Certificate OPTIONAL}
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.SingleResponse.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             SingleResponse ::= Sequence {
                     certID                       CertID,
                     certStatus                   CertStatus,
                     thisUpdate                   GeneralizedTime,
                     nextUpdate         [0]       EXPLICIT GeneralizedTime OPTIONAL,
                     singleExtensions   [1]       EXPLICIT Extensions OPTIONAL }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.TbsRequest.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            TBSRequest      ::=     Sequence {
                version             [0]     EXPLICIT Version DEFAULT v1,
                requestorName       [1]     EXPLICIT GeneralName OPTIONAL,
                requestList                 Sequence OF Request,
                requestExtensions   [2]     EXPLICIT Extensions OPTIONAL }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.OidTokenizer">
            class for breaking up an Oid into it's component tokens, ala
            java.util.StringTokenizer. We need this class as some of the
            lightweight Java environment don't support classes like
            StringTokenizer.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.AttributePkcs.GetInstance(System.Object)">
             return an Attribute object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.AttributePkcs.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Attr ::= Sequence {
                attrType OBJECT IDENTIFIER,
                attrValues Set OF AttributeValue
            }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.CertificationRequest">
            Pkcs10 Certfication request object.
            <pre>
            CertificationRequest ::= Sequence {
              certificationRequestInfo  CertificationRequestInfo,
              signatureAlgorithm        AlgorithmIdentifier{{ SignatureAlgorithms }},
              signature                 BIT STRING
            }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.CertificationRequestInfo">
             Pkcs10 CertificationRequestInfo object.
             <pre>
              CertificationRequestInfo ::= Sequence {
               version             Integer { v1(0) } (v1,...),
               subject             Name,
               subjectPKInfo   SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
               attributes          [0] Attributes{{ CRIAttributes }}
              }
            
              Attributes { ATTRIBUTE:IOSet } ::= Set OF Attr{{ IOSet }}
            
              Attr { ATTRIBUTE:IOSet } ::= Sequence {
                type    ATTRIBUTE.&amp;id({IOSet}),
                values  Set SIZE(1..MAX) OF ATTRIBUTE.&amp;Type({IOSet}{\@type})
              }
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.ContentInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ContentInfo ::= Sequence {
                     contentType ContentType,
                     content
                     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.EncryptedData">
             The EncryptedData object.
             <pre>
                  EncryptedData ::= Sequence {
                       version Version,
                       encryptedContentInfo EncryptedContentInfo
                  }
            
            
                  EncryptedContentInfo ::= Sequence {
                      contentType ContentType,
                      contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,
                      encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL
                }
            
                EncryptedContent ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.EncryptedPrivateKeyInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             EncryptedPrivateKeyInfo ::= Sequence {
                  encryptionAlgorithm AlgorithmIdentifier {{KeyEncryptionAlgorithms}},
                  encryptedData EncryptedData
             }
            
             EncryptedData ::= OCTET STRING
            
             KeyEncryptionAlgorithms ALGORITHM-IDENTIFIER ::= {
                      ... -- For local profiles
             }
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.MacData.ToAsn1Object">
            <pre>
            MacData ::= SEQUENCE {
                mac      DigestInfo,
                macSalt  OCTET STRING,
                iterations INTEGER DEFAULT 1
                -- Note: The default is for historic reasons and its use is deprecated. A
                -- higher value, like 1024 is recommended.
            </pre>
            @return the basic DERObject construction.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.Pfx">
            the infamous Pfx from Pkcs12
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.Sha512_224WithRSAEncryption">
            PKCS#1: 1.2.840.113549.1.1.15 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.Sha512_256WithRSAEncryption">
            PKCS#1: 1.2.840.113549.1.1.16 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.IdAlgAeadChaCha20Poly1305">
             <pre>
             id-alg-AEADChaCha20Poly1305 OBJECT IDENTIFIER ::=
             { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
                pkcs9(9) smime(16) alg(3) 18 }
            
             AEADChaCha20Poly1305Nonce ::= OCTET STRING (SIZE(12))
             </pre>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.IdAlgHssLmsHashsig">
            id-alg-hss-lms-hashsig OBJECT IDENTIFIER ::= { iso(1)
                member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)
               smime(16) alg(3) 17 }
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.IdAADecryptKeyID">
            PKCS#9: 1.2.840.113549.1.9.16.2.37 - <a href="https://tools.ietf.org/html/rfc4108#section-2.2.5">RFC 4108</a> 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.IdAAImplCryptoAlgs">
            PKCS#9: 1.2.840.113549.1.9.16.2.38 - <a href="https://tools.ietf.org/html/rfc4108#section-2.2.6">RFC 4108</a> 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.IdAAAsymmDecryptKeyID">
            PKCS#9: 1.2.840.113549.1.9.16.2.54 <a href="https://tools.ietf.org/html/rfc7030">RFC7030</a>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.IdAAImplCompressAlgs">
            PKCS#9: 1.2.840.113549.1.9.16.2.43   <a href="https://tools.ietf.org/html/rfc7030">RFC7030</a>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.IdAACommunityIdentifiers">
            PKCS#9: 1.2.840.113549.1.9.16.2.40   <a href="https://tools.ietf.org/html/rfc7030">RFC7030</a>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo">
              RFC 5958
            
              <pre>
              [IMPLICIT TAGS]
            
              OneAsymmetricKey ::= SEQUENCE {
                  version                   Version,
                  privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
                  privateKey                PrivateKey,
                  attributes            [0] Attributes OPTIONAL,
                  ...,
                  [[2: publicKey        [1] PublicKey OPTIONAL ]],
                  ...
              }
            
              PrivateKeyInfo ::= OneAsymmetricKey
            
              Version ::= INTEGER { v1(0), v2(1) } (v1, ..., v2)
            
              PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
                                                 { PUBLIC-KEY,
                                                   { PrivateKeyAlgorithms } }
            
              PrivateKey ::= OCTET STRING
                                 -- Content varies based on type of key.  The
                                 -- algorithm identifier dictates the format of
                                 -- the key.
            
              PublicKey ::= BIT STRING
                                 -- Content varies based on type of key.  The
                                 -- algorithm identifier dictates the format of
                                 -- the key.
            
              Attributes ::= SET OF Attribute { { OneAsymmetricKeyAttributes } }
              </pre>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo.HasPublicKey">
            <summary>Return true if a public key is present, false otherwise.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo.ParsePublicKey">
            <summary>For when the public key is an ASN.1 encoding.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo.PublicKeyData">
            <summary>Return the public key as a raw bit string.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.RsaesOaepParameters.#ctor">
            The default version
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.RsaesOaepParameters.ToAsn1Object">
             <pre>
              RSAES-OAEP-params ::= SEQUENCE {
                 hashAlgorithm      [0] OAEP-PSSDigestAlgorithms     DEFAULT sha1,
                 maskGenAlgorithm   [1] PKCS1MGFAlgorithms  DEFAULT mgf1SHA1,
                 pSourceAlgorithm   [2] PKCS1PSourceAlgorithms  DEFAULT pSpecifiedEmpty
               }
            
               OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
                 { OID id-sha1 PARAMETERS NULL   }|
                 { OID id-sha256 PARAMETERS NULL }|
                 { OID id-sha384 PARAMETERS NULL }|
                 { OID id-sha512 PARAMETERS NULL },
                 ...  -- Allows for future expansion --
               }
               PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
                 { OID id-mgf1 PARAMETERS OAEP-PSSDigestAlgorithms },
                ...  -- Allows for future expansion --
               }
               PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {
                 { OID id-pSpecified PARAMETERS OCTET STRING },
                 ...  -- Allows for future expansion --
              }
             </pre>
             @return the asn1 primitive representing the parameters.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.RsaPrivateKeyStructure.ToAsn1Object">
             This outputs the key in Pkcs1v2 format.
             <pre>
                  RsaPrivateKey ::= Sequence {
                                      version Version,
                                      modulus Integer, -- n
                                      publicExponent Integer, -- e
                                      privateExponent Integer, -- d
                                      prime1 Integer, -- p
                                      prime2 Integer, -- q
                                      exponent1 Integer, -- d mod (p-1)
                                      exponent2 Integer, -- d mod (q-1)
                                      coefficient Integer -- (inverse of q) mod p
                                  }
            
                  Version ::= Integer
             </pre>
             <p>This routine is written to output Pkcs1 version 0, private keys.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters.#ctor">
            The default version
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters.ToAsn1Object">
             <pre>
             RSASSA-PSS-params ::= SEQUENCE {
               hashAlgorithm      [0] OAEP-PSSDigestAlgorithms  DEFAULT sha1,
                maskGenAlgorithm   [1] PKCS1MGFAlgorithms  DEFAULT mgf1SHA1,
                saltLength         [2] INTEGER  DEFAULT 20,
                trailerField       [3] TrailerField  DEFAULT trailerFieldBC
              }
            
             OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
                { OID id-sha1 PARAMETERS NULL   }|
                { OID id-sha256 PARAMETERS NULL }|
                { OID id-sha384 PARAMETERS NULL }|
                { OID id-sha512 PARAMETERS NULL },
                ...  -- Allows for future expansion --
             }
            
             PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
               { OID id-mgf1 PARAMETERS OAEP-PSSDigestAlgorithms },
                ...  -- Allows for future expansion --
             }
            
             TrailerField ::= INTEGER { trailerFieldBC(1) }
             </pre>
             @return the asn1 primitive representing the parameters.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.SignedData">
            a Pkcs#7 signed data object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.SignedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             SignedData ::= Sequence {
                 version Version,
                 digestAlgorithms DigestAlgorithmIdentifiers,
                 contentInfo ContentInfo,
                 certificates
                     [0] IMPLICIT ExtendedCertificatesAndCertificates
                              OPTIONAL,
                 crls
                     [1] IMPLICIT CertificateRevocationLists OPTIONAL,
                 signerInfos SignerInfos }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.SignerInfo">
            a Pkcs#7 signer info object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.SignerInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
              SignerInfo ::= Sequence {
                  version Version,
                  issuerAndSerialNumber IssuerAndSerialNumber,
                  digestAlgorithm DigestAlgorithmIdentifier,
                  authenticatedAttributes [0] IMPLICIT Attributes OPTIONAL,
                  digestEncryptionAlgorithm DigestEncryptionAlgorithmIdentifier,
                  encryptedDigest EncryptedDigest,
                  unauthenticatedAttributes [1] IMPLICIT Attributes OPTIONAL
              }
            
              EncryptedDigest ::= OCTET STRING
            
              DigestAlgorithmIdentifier ::= AlgorithmIdentifier
            
              DigestEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
             </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Sec.ECPrivateKeyStructure">
            the elliptic curve private key object from SEC 1
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Sec.ECPrivateKeyStructure.ToAsn1Object">
            ECPrivateKey ::= SEQUENCE {
                version INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
                privateKey OCTET STRING,
                parameters [0] Parameters OPTIONAL,
                publicKey [1] BIT STRING OPTIONAL }
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Sec.SecNamedCurves">
            <summary>Elliptic curve registry for the SEC standard.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByName(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByOid(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByOidLazy(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetName(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetOid(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Sec.SecNamedCurves.Names">
            <summary>Enumerate the available curve names in this registry.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Sec.SecObjectIdentifiers.EllipticCurve">
            EllipticCurve OBJECT IDENTIFIER ::= {
                  iso(1) identified-organization(3) certicom(132) curve(0)
            }
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Smime.SmimeCapabilities">
            Handler class for dealing with S/MIME Capabilities
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.PreferSignedData">
            general preferences
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.Aes256Cbc">
            encryption algorithms preferences
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.GetInstance(System.Object)">
             return an Attr object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.GetCapabilitiesForOid(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            returns an ArrayList with 0 or more objects of all the capabilities
            matching the passed in capability Oid. If the Oid passed is null the
            entire set is returned.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SMIMECapabilities ::= Sequence OF SMIMECapability
            </pre>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Smime.SmimeCapability.PreferSignedData">
            general preferences
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Smime.SmimeCapability.DesCbc">
            encryption algorithms preferences
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Smime.SmimeCapability.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SMIMECapability ::= Sequence {
                capabilityID OBJECT IDENTIFIER,
                parameters ANY DEFINED BY capabilityID OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Smime.SmimeCapabilityVector">
            Handler for creating a vector S/MIME Capabilities
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Smime.SmimeEncryptionKeyPreferenceAttribute">
            The SmimeEncryptionKeyPreference object.
            <pre>
            SmimeEncryptionKeyPreference ::= CHOICE {
                issuerAndSerialNumber   [0] IssuerAndSerialNumber,
                receipentKeyId          [1] RecipientKeyIdentifier,
                subjectAltKeyIdentifier [2] SubjectKeyIdentifier
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Smime.SmimeEncryptionKeyPreferenceAttribute.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1OctetString)">
            @param sKeyId the subjectKeyIdentifier value (normally the X.509 one)
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves">
            <summary>Elliptic curve registry for curves defined in "ECC Brainpool Standard Curves and Curve Generation"
            http://www.ecc-brainpool.org/download/draft_pkix_additional_ecc_dp.txt .</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetByName(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetByOid(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetByOidLazy(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetName(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetOid(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.Names">
            <summary>Enumerate the available curve names in this registry.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Tsp.Accuracy.ToAsn1Object">
            <pre>
            Accuracy ::= SEQUENCE {
                        seconds        INTEGER              OPTIONAL,
                        millis     [0] INTEGER  (1..999)    OPTIONAL,
                        micros     [1] INTEGER  (1..999)    OPTIONAL
                        }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Tsp.MessageImprint.ToAsn1Object">
            <pre>
               MessageImprint ::= SEQUENCE  {
                  hashAlgorithm                AlgorithmIdentifier,
                  hashedMessage                OCTET STRING  }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Tsp.TimeStampReq.ToAsn1Object">
            <pre>
            TimeStampReq ::= SEQUENCE  {
             version                      INTEGER  { v1(1) },
             messageImprint               MessageImprint,
               --a hash algorithm OID and the hash value of the data to be
               --time-stamped
             reqPolicy             TSAPolicyId              OPTIONAL,
             nonce                 INTEGER                  OPTIONAL,
             certReq               BOOLEAN                  DEFAULT FALSE,
             extensions            [0] IMPLICIT Extensions  OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Tsp.TimeStampResp.ToAsn1Object">
            <pre>
            TimeStampResp ::= SEQUENCE  {
              status                  PkiStatusInfo,
              timeStampToken          TimeStampToken     OPTIONAL  }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Tsp.TstInfo.ToAsn1Object">
             <pre>
            
                 TstInfo ::= SEQUENCE  {
                    version                      INTEGER  { v1(1) },
                    policy                       TSAPolicyId,
                    messageImprint               MessageImprint,
                      -- MUST have the same value as the similar field in
                      -- TimeStampReq
                    serialNumber                 INTEGER,
                     -- Time-Stamping users MUST be ready to accommodate integers
                     -- up to 160 bits.
                    genTime                      GeneralizedTime,
                    accuracy                     Accuracy                 OPTIONAL,
                    ordering                     BOOLEAN             DEFAULT FALSE,
                    nonce                        INTEGER                  OPTIONAL,
                      -- MUST be present if the similar field was present
                      -- in TimeStampReq.  In that case it MUST have the same value.
                    tsa                          [0] GeneralName          OPTIONAL,
                    extensions                   [1] IMPLICIT Extensions   OPTIONAL  }
            
             </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers">
            Ukrainian object identifiers
            <p/>
            {iso(1) member-body(2) Ukraine(804) root(2) security(1) cryptography(1) pki(1)}
            <p/>
            { ...  pki-alg(1) pki-alg-sym(3) Dstu4145WithGost34311(1) PB(1)}
            <p/>
            DSTU4145 in polynomial basis has 2 oids, one for little-endian representation and one for big-endian
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.UaOid">
            Base OID: 1.2.804.2.1.1.1 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu4145le">
            DSTU4145 Little Endian presentation.  OID: 1.2.804.2.1.1.1.1.3.1.1 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu4145be">
            DSTU4145 Big Endian presentation.  OID: 1.2.804.2.1.1.1.1.3.1.1.1 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7564digest_256">
            DSTU7564 256-bit digest presentation. 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7564digest_384">
            DSTU7564 384-bit digest presentation. 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7564digest_512">
            DSTU7564 512-bit digest presentation. 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7564mac_256">
            DSTU7564 256-bit mac presentation. 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7564mac_384">
            DSTU7564 384-bit mac presentation. 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7564mac_512">
            DSTU7564 512-bit mac presentation. 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ecb_128">
            DSTU7624 in ECB mode with 128 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ecb_256">
            DSTU7624 in ECB mode with 256 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ecb_512">
            DSTU7624 in ECB mode with 512 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ctr_128">
            DSTU7624 in CTR mode with 128 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ctr_256">
            DSTU7624 in CTR mode with 256 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ctr_512">
            DSTU7624 in CTR mode with 512 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cfb_128">
            DSTU7624 in CFB mode with 128 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cfb_256">
            DSTU7624 in CFB mode with 256 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cfb_512">
            DSTU7624 in CFB mode with 512 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cmac_128">
            DSTU7624 in MAC mode with 128 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cmac_256">
            DSTU7624 in MAC mode with 256 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cmac_512">
            DSTU7624 in MAC mode with 512 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cbc_128">
            DSTU7624 in CBC mode with 128 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cbc_256">
            DSTU7624 in CBC mode with 256 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cbc_512">
            DSTU7624 in CBC mode with 512 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ofb_128">
            DSTU7624 in OFB mode with 128 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ofb_256">
            DSTU7624 in OFB mode with 256 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ofb_512">
            DSTU7624 in OFB mode with 512 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624gmac_128">
            DSTU7624 in GMAC (GCM witout encryption) mode with 128 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624gmac_256">
            DSTU7624 in GMAC (GCM witout encryption) mode with 256 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624gmac_512">
            DSTU7624 in GMAC (GCM witout encryption) mode with 512 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ccm_128">
            DSTU7624 in CCM mode with 128 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ccm_256">
            DSTU7624 in CCM mode with 256 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ccm_512">
            DSTU7624 in CCM mode with 512 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624xts_128">
            DSTU7624 in XTS mode with 128 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624xts_256">
            DSTU7624 in XTS mode with 256 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624xts_512">
            DSTU7624 in XTS mode with 512 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624kw_128">
            DSTU7624 in key wrap (KW) mode with 128 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624kw_256">
            DSTU7624 in key wrap (KW) mode with 256 bit block/key presentation 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624kw_512">
            DSTU7624 in key wrap (KW) mode with 512 bit block/key presentation 
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Utilities.Asn1Dump.AsString(System.String,System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Object,System.Text.StringBuilder)">
             dump a Der object as a formatted string with indentation
            
             @param obj the Asn1Object to be dumped out.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Utilities.Asn1Dump.Dump(System.IO.Stream,System.IO.TextWriter)">
            <summary>Parse ASN.1 objects from input <see cref="T:System.IO.Stream"/>, and write them to the output.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Utilities.Asn1Dump.DumpAsString(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
             dump out a DER object as a formatted string, in non-verbose mode
            
             @param obj the Asn1Encodable to be dumped out.
             @return  the resulting string.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Utilities.Asn1Dump.DumpAsString(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable,System.Boolean)">
             Dump out the object as a string
            
             @param obj the Asn1Encodable to be dumped out.
             @param verbose  if true, dump out the contents of octet and bit strings.
             @return  the resulting string.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.AttributeTypeAndValue">
            Holding class for the AttributeTypeAndValue structures that make up an RDN.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.AttributeTypeAndValue.ToAsn1Object">
            <pre>
            AttributeTypeAndValue ::= SEQUENCE {
                      type         OBJECT IDENTIFIER,
                      value        ANY DEFINED BY type }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.DirectoryString.ToAsn1Object">
            <pre>
             DirectoryString ::= CHOICE {
               teletexString               TeletexString (SIZE (1..MAX)),
               printableString             PrintableString (SIZE (1..MAX)),
               universalString             UniversalString (SIZE (1..MAX)),
               utf8String                  UTF8String (SIZE (1..MAX)),
               bmpString                   BMPString (SIZE (1..MAX))  }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.Rdn">
            Holding class for a single Relative Distinguished Name (RDN).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.Rdn.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
             Create a single valued RDN.
            
             @param oid RDN type.
             @param value RDN value.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.Rdn.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.AttributeTypeAndValue[])">
             Create a multi-valued RDN.
            
             @param aAndVs attribute type/value pairs making up the RDN
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.Rdn.Count">
             Return the number of AttributeTypeAndValue objects in this RDN,
            
             @return size of RDN, greater than 1 if multi-valued.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.Rdn.ToAsn1Object">
                     * <pre>
                     * RelativeDistinguishedName ::=
                     *                     SET OF AttributeTypeAndValue
            
                     * AttributeTypeAndValue ::= SEQUENCE {
                     *        type     AttributeType,
                     *        value    AttributeValue }
                     * </pre>
                     * @return this object as its ASN1Primitive type
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AccessDescription">
            The AccessDescription object.
            <pre>
            AccessDescription  ::=  SEQUENCE {
                  accessMethod          OBJECT IDENTIFIER,
                  accessLocation        GeneralName  }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AccessDescription.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName)">
            create an AccessDescription with the oid and location provided.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AccessDescription.AccessMethod">
            
             @return the access method.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AccessDescription.AccessLocation">
            
             @return the access location
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.Algorithm">
            <summary>
            Return the OID in the Algorithm entry of this identifier.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.Parameters">
            <summary>
            Return the parameters structure in the Parameters entry of this identifier.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
                 AlgorithmIdentifier ::= Sequence {
                                       algorithm OBJECT IDENTIFIER,
                                       parameters ANY DEFINED BY algorithm OPTIONAL }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AttCertIssuer.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralNames)">
            <summary>
            Don't use this one if you are trying to be RFC 3281 compliant.
            Use it for v1 attribute certificates only.
            </summary>
            <param name="names">Our GeneralNames structure</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AttCertIssuer.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             AttCertIssuer ::= CHOICE {
                  v1Form   GeneralNames,  -- MUST NOT be used in this
                                          -- profile
                  v2Form   [0] V2Form     -- v2 only
             }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AttCertValidityPeriod.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             AttCertValidityPeriod  ::= Sequence {
                  notBeforeTime  GeneralizedTime,
                  notAfterTime   GeneralizedTime
             }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AttributeX509.GetInstance(System.Object)">
             return an Attr object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AttributeX509.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Attr ::= Sequence {
                attrType OBJECT IDENTIFIER,
                attrValues Set OF AttributeValue
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AttributeCertificate.GetInstance(System.Object)">
            @param obj
            @return
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AttributeCertificate.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             AttributeCertificate ::= Sequence {
                  acinfo               AttributeCertificateInfo,
                  signatureAlgorithm   AlgorithmIdentifier,
                  signatureValue       BIT STRING
             }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AttributeCertificateInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
              AttributeCertificateInfo ::= Sequence {
                   version              AttCertVersion -- version is v2,
                   holder               Holder,
                   issuer               AttCertIssuer,
                   signature            AlgorithmIdentifier,
                   serialNumber         CertificateSerialNumber,
                   attrCertValidityPeriod   AttCertValidityPeriod,
                   attributes           Sequence OF Attr,
                   issuerUniqueID       UniqueIdentifier OPTIONAL,
                   extensions           Extensions OPTIONAL
              }
            
              AttCertVersion ::= Integer { v2(1) }
             </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AuthorityInformationAccess">
             The AuthorityInformationAccess object.
             <pre>
             id-pe-authorityInfoAccess OBJECT IDENTIFIER ::= { id-pe 1 }
            
             AuthorityInfoAccessSyntax  ::=
                  Sequence SIZE (1..MAX) OF AccessDescription
             AccessDescription  ::=  Sequence {
                   accessMethod          OBJECT IDENTIFIER,
                   accessLocation        GeneralName  }
            
             id-ad OBJECT IDENTIFIER ::= { id-pkix 48 }
             id-ad-caIssuers OBJECT IDENTIFIER ::= { id-ad 2 }
             id-ad-ocsp OBJECT IDENTIFIER ::= { id-ad 1 }
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AuthorityInformationAccess.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName)">
            create an AuthorityInformationAccess with the oid and location provided.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier">
             The AuthorityKeyIdentifier object.
             <pre>
             id-ce-authorityKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 35 }
            
               AuthorityKeyIdentifier ::= Sequence {
                  keyIdentifier             [0] IMPLICIT KeyIdentifier           OPTIONAL,
                  authorityCertIssuer       [1] IMPLICIT GeneralNames            OPTIONAL,
                  authorityCertSerialNumber [2] IMPLICIT CertificateSerialNumber OPTIONAL  }
            
               KeyIdentifier ::= OCTET STRING
             </pre>
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
                     *
                     * Calulates the keyidentifier using a SHA1 hash over the BIT STRING
                     * from SubjectPublicKeyInfo as defined in RFC2459.
                     *
                     * Example of making a AuthorityKeyIdentifier:
                     * <pre>
            	     *   SubjectPublicKeyInfo apki = new SubjectPublicKeyInfo((ASN1Sequence)new ASN1InputStream(
            		 *       publicKey.getEncoded()).readObject());
                     *   AuthorityKeyIdentifier aki = new AuthorityKeyIdentifier(apki);
                     * </pre>
                     *
                     *
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralNames,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            create an AuthorityKeyIdentifier with the GeneralNames tag and
            the serial number provided as well.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralNames,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            create an AuthorityKeyIdentifier with the GeneralNames tag and
            the serial number provided.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(System.Byte[])">
            create an AuthorityKeyIdentifier with a precomputed key identifier
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(System.Byte[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralNames,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            create an AuthorityKeyIdentifier with a precomupted key identifier
            and the GeneralNames tag and the serial number provided as well.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.BasicConstraints.#ctor(System.Int32)">
             create a cA=true object for the given path length constraint.
            
             @param pathLenConstraint
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.BasicConstraints.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            BasicConstraints := Sequence {
               cA                  Boolean DEFAULT FALSE,
               pathLenConstraint   Integer (0..MAX) OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.CertificateList">
             PKIX RFC-2459
            
             The X.509 v2 CRL syntax is as follows.  For signature calculation,
             the data that is to be signed is ASN.1 Der encoded.
            
             <pre>
             CertificateList  ::=  Sequence  {
                  tbsCertList          TbsCertList,
                  signatureAlgorithm   AlgorithmIdentifier,
                  signatureValue       BIT STRING  }
             </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.CertificatePair">
             This class helps to support crossCerfificatePairs in a LDAP directory
             according RFC 2587
            
             <pre>
                 crossCertificatePairATTRIBUTE::={
                   WITH SYNTAX   CertificatePair
                   EQUALITY MATCHING RULE certificatePairExactMatch
                   ID joint-iso-ccitt(2) ds(5) attributeType(4) crossCertificatePair(40)}
             </pre>
            
             <blockquote> The forward elements of the crossCertificatePair attribute of a
             CA's directory entry shall be used to store all, except self-issued
             certificates issued to this CA. Optionally, the reverse elements of the
             crossCertificatePair attribute, of a CA's directory entry may contain a
             subset of certificates issued by this CA to other CAs. When both the forward
             and the reverse elements are present in a single attribute value, issuer name
             in one certificate shall match the subject name in the other and vice versa,
             and the subject public key in one certificate shall be capable of verifying
             the digital signature on the other certificate and vice versa.
            
             When a reverse element is present, the forward element value and the reverse
             element value need not be stored in the same attribute value; in other words,
             they can be stored in either a single attribute value or two attribute
             values. </blockquote>
            
             <pre>
                   CertificatePair ::= SEQUENCE {
                     forward		[0]	Certificate OPTIONAL,
                     reverse		[1]	Certificate OPTIONAL,
                     -- at least one of the pair shall be present -- }
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.CertificatePair.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type CertificatePair:
             <p/>
             <pre>
                   CertificatePair ::= SEQUENCE {
                     forward		[0]	Certificate OPTIONAL,
                     reverse		[1]	Certificate OPTIONAL,
                     -- at least one of the pair shall be present -- }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.CertificatePair.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509CertificateStructure,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509CertificateStructure)">
             Constructor from a given details.
            
             @param forward Certificates issued to this CA.
             @param reverse Certificates issued by this CA to other CAs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.CertificatePair.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                   CertificatePair ::= SEQUENCE {
                     forward		[0]	Certificate OPTIONAL,
                     reverse		[1]	Certificate OPTIONAL,
                     -- at least one of the pair shall be present -- }
             </pre>
            
             @return a DERObject
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.CertificatePair.Forward">
            @return Returns the forward.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.CertificatePair.Reverse">
            @return Returns the reverse.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.CertificatePolicies.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.PolicyInformation)">
            Construct a CertificatePolicies object containing one PolicyInformation.
            
            @param name the name to be contained.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.CertificatePolicies.ToAsn1Object">
            Produce an object suitable for an ASN1OutputStream.
            <pre>
            CertificatePolicies ::= SEQUENCE SIZE {1..MAX} OF PolicyInformation
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.CertPolicyID">
             CertPolicyId, used in the CertificatePolicies and PolicyMappings
             X509V3 Extensions.
            
             <pre>
                 CertPolicyId ::= OBJECT IDENTIFIER
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.CrlDistPoint.GetDistributionPoints">
             Return the distribution points making up the sequence.
            
             @return DistributionPoint[]
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.CrlDistPoint.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            CrlDistPoint ::= Sequence SIZE {1..MAX} OF DistributionPoint
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.CrlNumber">
            The CRLNumber object.
            <pre>
            CRLNumber::= Integer(0..MAX)
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.CrlReason">
            The CRLReason enumeration.
            <pre>
            CRLReason ::= Enumerated {
             unspecified             (0),
             keyCompromise           (1),
             cACompromise            (2),
             affiliationChanged      (3),
             superseded              (4),
             cessationOfOperation    (5),
             certificateHold         (6),
             removeFromCRL           (8),
             privilegeWithdrawn      (9),
             aACompromise           (10)
            }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DigestInfo">
            The DigestInfo object.
            <pre>
            DigestInfo::=Sequence{
                     digestAlgorithm  AlgorithmIdentifier,
                     digest OCTET STRING }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DisplayText">
             <code>DisplayText</code> class, used in
             <code>CertificatePolicies</code> X509 V3 extensions (in policy qualifiers).
            
             <p>It stores a string in a chosen encoding.
             <pre>
             DisplayText ::= CHOICE {
                  ia5String        IA5String      (SIZE (1..200)),
                  visibleString    VisibleString  (SIZE (1..200)),
                  bmpString        BMPString      (SIZE (1..200)),
                  utf8String       UTF8String     (SIZE (1..200)) }
             </pre></p>
             @see PolicyQualifierInfo
             @see PolicyInformation
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DisplayText.ContentTypeIA5String">
             Constant corresponding to ia5String encoding.
            
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DisplayText.ContentTypeBmpString">
             Constant corresponding to bmpString encoding.
            
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DisplayText.ContentTypeUtf8String">
             Constant corresponding to utf8String encoding.
            
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DisplayText.ContentTypeVisibleString">
             Constant corresponding to visibleString encoding.
            
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DisplayText.DisplayTextMaximumSize">
             Describe constant <code>DisplayTextMaximumSize</code> here.
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DisplayText.#ctor(System.Int32,System.String)">
             Creates a new <code>DisplayText</code> instance.
            
             @param type the desired encoding type for the text.
             @param text the text to store. Strings longer than 200
             characters are truncated.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DisplayText.#ctor(System.String)">
             Creates a new <code>DisplayText</code> instance.
            
             @param text the text to encapsulate. Strings longer than 200
             characters are truncated.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DisplayText.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.IAsn1String)">
             Creates a new <code>DisplayText</code> instance.
             <p>Useful when reading back a <code>DisplayText</code> class
             from it's Asn1Encodable form.</p>
            
             @param contents an <code>Asn1Encodable</code> instance.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DisplayText.GetString">
             Returns the stored <code>string</code> object.
            
             @return the stored text as a <code>string</code>.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DistributionPoint">
            The DistributionPoint object.
            <pre>
            DistributionPoint ::= Sequence {
                 distributionPoint [0] DistributionPointName OPTIONAL,
                 reasons           [1] ReasonFlags OPTIONAL,
                 cRLIssuer         [2] GeneralNames OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DistributionPointName">
            The DistributionPointName object.
            <pre>
            DistributionPointName ::= CHOICE {
                fullName                 [0] GeneralNames,
                nameRelativeToCRLIssuer  [1] RDN
            }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.ExtendedKeyUsage">
            The extendedKeyUsage object.
            <pre>
                 extendedKeyUsage ::= Sequence SIZE (1..MAX) OF KeyPurposeId
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.ExtendedKeyUsage.GetAllUsages">
            Returns all extended key usages.
            The returned ArrayList contains DerObjectIdentifier instances.
            @return An ArrayList with all key purposes.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName">
             The GeneralName object.
             <pre>
             GeneralName ::= CHOICE {
                  otherName                       [0]     OtherName,
                  rfc822Name                      [1]     IA5String,
                  dNSName                         [2]     IA5String,
                  x400Address                     [3]     ORAddress,
                  directoryName                   [4]     Name,
                  ediPartyName                    [5]     EDIPartyName,
                  uniformResourceIdentifier       [6]     IA5String,
                  iPAddress                       [7]     OCTET STRING,
                  registeredID                    [8]     OBJECT IDENTIFIER}
            
             OtherName ::= Sequence {
                  type-id    OBJECT IDENTIFIER,
                  value      [0] EXPLICIT ANY DEFINED BY type-id }
            
             EDIPartyName ::= Sequence {
                  nameAssigner            [0]     DirectoryString OPTIONAL,
                  partyName               [1]     DirectoryString }
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Object,System.Int32)">
             When the subjectAltName extension contains an Internet mail address,
             the address MUST be included as an rfc822Name. The format of an
             rfc822Name is an "addr-spec" as defined in RFC 822 [RFC 822].
            
             When the subjectAltName extension contains a domain name service
             label, the domain name MUST be stored in the dNSName (an IA5String).
             The name MUST be in the "preferred name syntax," as specified by RFC
             1034 [RFC 1034].
            
             When the subjectAltName extension contains a URI, the name MUST be
             stored in the uniformResourceIdentifier (an IA5String). The name MUST
             be a non-relative URL, and MUST follow the URL syntax and encoding
             rules specified in [RFC 1738].  The name must include both a scheme
             (e.g., "http" or "ftp") and a scheme-specific-part.  The scheme-
             specific-part must include a fully qualified domain name or IP
             address as the host.
            
             When the subjectAltName extension contains a iPAddress, the address
             MUST be stored in the octet string in "network byte order," as
             specified in RFC 791 [RFC 791]. The least significant bit (LSB) of
             each octet is the LSB of the corresponding byte in the network
             address. For IP Version 4, as specified in RFC 791, the octet string
             MUST contain exactly four octets.  For IP Version 6, as specified in
             RFC 1883, the octet string MUST contain exactly sixteen octets [RFC
             1883].
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName.#ctor(System.Int32,System.String)">
             Create a GeneralName for the given tag from the passed in string.
             <p>
             This constructor can handle:
             <ul>
             <li>rfc822Name</li>
             <li>iPAddress</li>
             <li>directoryName</li>
             <li>dNSName</li>
             <li>uniformResourceIdentifier</li>
             <li>registeredID</li>
             </ul>
             For x400Address, otherName and ediPartyName there is no common string
             format defined.
             </p><p>
             Note: A directory name can be encoded in different ways into a byte
             representation. Be aware of this if the byte representation is used for
             comparing results.
             </p>
            
             @param tag tag number
             @param name string representation of name
             @throws ArgumentException if the string encoding is not correct or
                         not supported.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralNames.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName)">
            <summary>Construct a GeneralNames object containing one GeneralName.</summary>
            <param name="name">The name to be contained.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralNames.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            GeneralNames ::= Sequence SIZE {1..MAX} OF GeneralName
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralSubtree">
             Class for containing a restriction object subtrees in NameConstraints. See
             RFC 3280.
            
             <pre>
            
                   GeneralSubtree ::= SEQUENCE
                   {
                     baseName                    GeneralName,
                     minimum         [0]     BaseDistance DEFAULT 0,
                     maximum         [1]     BaseDistance OPTIONAL
                   }
             </pre>
            
             @see org.bouncycastle.asn1.x509.NameConstraints
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralSubtree.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
             Constructor from a given details.
            
             According RFC 3280, the minimum and maximum fields are not used with any
             name forms, thus minimum MUST be zero, and maximum MUST be absent.
             <p>
             If minimum is <code>null</code>, zero is assumed, if
             maximum is <code>null</code>, maximum is absent.</p>
            
             @param baseName
                        A restriction.
             @param minimum
                        Minimum
            
             @param maximum
                        Maximum
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralSubtree.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
            
             Returns:
            
             <pre>
                   GeneralSubtree ::= SEQUENCE
                   {
                     baseName                    GeneralName,
                     minimum         [0]     BaseDistance DEFAULT 0,
                     maximum         [1]     BaseDistance OPTIONAL
                   }
             </pre>
            
             @return a DERObject
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Holder">
            The Holder object.
            <p>
            For an v2 attribute certificate this is:
            
            <pre>
                       Holder ::= SEQUENCE {
                             baseCertificateID   [0] IssuerSerial OPTIONAL,
                                      -- the issuer and serial number of
                                      -- the holder's Public Key Certificate
                             entityName          [1] GeneralNames OPTIONAL,
                                      -- the name of the claimant or role
                             objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
                                      -- used to directly authenticate the holder,
                                      -- for example, an executable
                       }
            </pre>
            </p>
            <p>
            For an v1 attribute certificate this is:
            
            <pre>
                    subject CHOICE {
                     baseCertificateID [0] EXPLICIT IssuerSerial,
                     -- associated with a Public Key Certificate
                     subjectName [1] EXPLICIT GeneralNames },
                     -- associated with a name
            </pre>
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Holder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject)">
            Constructor for a holder for an v1 attribute certificate.
            
            @param tagObj The ASN.1 tagged holder object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Holder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor for a holder for an v2 attribute certificate. *
            
            @param seq The ASN.1 sequence.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Holder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.IssuerSerial,System.Int32)">
            Constructs a holder from a IssuerSerial.
            @param baseCertificateID The IssuerSerial.
            @param version The version of the attribute certificate. 
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Holder.Version">
            Returns 1 for v2 attribute certificates or 0 for v1 attribute
            certificates. 
            @return The version of the attribute certificate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Holder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralNames)">
            Constructs a holder with an entityName for v2 attribute certificates or
            with a subjectName for v1 attribute certificates.
            
            @param entityName The entity or subject name.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Holder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralNames,System.Int32)">
            Constructs a holder with an entityName for v2 attribute certificates or
            with a subjectName for v1 attribute certificates.
            
            @param entityName The entity or subject name.
            @param version The version of the attribute certificate. 
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Holder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.ObjectDigestInfo)">
            Constructs a holder from an object digest info.
            
            @param objectDigestInfo The object digest info object.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Holder.EntityName">
            Returns the entityName for an v2 attribute certificate or the subjectName
            for an v1 attribute certificate.
            
            @return The entityname or subjectname.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Holder.ToAsn1Object">
            The Holder object.
            <pre>
             Holder ::= Sequence {
                   baseCertificateID   [0] IssuerSerial OPTIONAL,
                            -- the issuer and serial number of
                            -- the holder's Public Key Certificate
                   entityName          [1] GeneralNames OPTIONAL,
                            -- the name of the claimant or role
                   objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
                            -- used to directly authenticate the holder,
                            -- for example, an executable
             }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.IetfAttrSyntax">
            Implementation of <code>IetfAttrSyntax</code> as specified by RFC3281.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.IetfAttrSyntax.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.IetfAttrSyntax.ToAsn1Object">
            
             <pre>
            
              IetfAttrSyntax ::= Sequence {
                policyAuthority [0] GeneralNames OPTIONAL,
                values Sequence OF CHOICE {
                  octets OCTET STRING,
                  oid OBJECT IDENTIFIER,
                  string UTF8String
                }
              }
            
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.IssuerSerial.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             IssuerSerial  ::=  Sequence {
                  issuer         GeneralNames,
                  serial         CertificateSerialNumber,
                  issuerUid      UniqueIdentifier OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint">
            <pre>
            IssuingDistributionPoint ::= SEQUENCE { 
              distributionPoint          [0] DistributionPointName OPTIONAL, 
              onlyContainsUserCerts      [1] BOOLEAN DEFAULT FALSE, 
              onlyContainsCACerts        [2] BOOLEAN DEFAULT FALSE, 
              onlySomeReasons            [3] ReasonFlags OPTIONAL, 
              indirectCRL                [4] BOOLEAN DEFAULT FALSE,
              onlyContainsAttributeCerts [5] BOOLEAN DEFAULT FALSE }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DistributionPointName,System.Boolean,System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.ReasonFlags,System.Boolean,System.Boolean)">
            Constructor from given details.
            
            @param distributionPoint
                       May contain an URI as pointer to most current CRL.
            @param onlyContainsUserCerts Covers revocation information for end certificates.
            @param onlyContainsCACerts Covers revocation information for CA certificates.
            
            @param onlySomeReasons
                       Which revocation reasons does this point cover.
            @param indirectCRL
                       If <code>true</code> then the CRL contains revocation
                       information about certificates ssued by other CAs.
            @param onlyContainsAttributeCerts Covers revocation information for attribute certificates.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor from Asn1Sequence
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.DistributionPoint">
            @return Returns the distributionPoint.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.OnlySomeReasons">
            @return Returns the onlySomeReasons.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.KeyPurposeID">
            The KeyPurposeID object.
            <pre>
                KeyPurposeID ::= OBJECT IDENTIFIER
            </pre>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.KeyPurposeID.id_kp_msSGC">
            <summary>Microsoft Server Gated Crypto (msSGC).</summary>
            <remarks>see https://www.alvestrand.no/objectid/1.3.6.1.4.1.311.10.3.3.html</remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.KeyPurposeID.id_kp_nsSGC">
            <summary>Netscape Server Gated Crypto (nsSGC).</summary>
            <remarks>see https://www.alvestrand.no/objectid/2.16.840.1.113730.4.1.html</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.KeyUsage">
             The KeyUsage object.
             <pre>
                id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
            
                KeyUsage ::= BIT STRING {
                     digitalSignature        (0),
                     nonRepudiation          (1),
                     keyEncipherment         (2),
                     dataEncipherment        (3),
                     keyAgreement            (4),
                     keyCertSign             (5),
                     cRLSign                 (6),
                     encipherOnly            (7),
                     decipherOnly            (8) }
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.KeyUsage.#ctor(System.Int32)">
             Basic constructor.
            
             @param usage - the bitwise OR of the Key Usage flags giving the
             allowed uses for the key.
             e.g. (KeyUsage.keyEncipherment | KeyUsage.dataEncipherment)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.NameConstraints.#ctor(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralSubtree},System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralSubtree})">
             Constructor from a given details.
            
             <p>permitted and excluded are Vectors of GeneralSubtree objects.</p>
            
             @param permitted Permitted subtrees
             @param excluded Excluded subtrees
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.NoticeReference">
             <code>NoticeReference</code> class, used in
             <code>CertificatePolicies</code> X509 V3 extensions
             (in policy qualifiers).
            
             <pre>
              NoticeReference ::= Sequence {
                  organization     DisplayText,
                  noticeNumbers    Sequence OF Integer }
            
             </pre>
            
             @see PolicyQualifierInfo
             @see PolicyInformation
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.NoticeReference.#ctor(System.String,System.Collections.Generic.IList{System.Object})">
             Creates a new <code>NoticeReference</code> instance.
            
             @param organization a <code>String</code> value
             @param numbers a <code>Vector</code> value
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.NoticeReference.#ctor(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1EncodableVector)">
             Creates a new <code>NoticeReference</code> instance.
            
             @param organization a <code>String</code> value
             @param noticeNumbers an <code>ASN1EncodableVector</code> value
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.NoticeReference.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DisplayText,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1EncodableVector)">
             Creates a new <code>NoticeReference</code> instance.
            
             @param organization displayText
             @param noticeNumbers an <code>ASN1EncodableVector</code> value
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.NoticeReference.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>NoticeReference</code> instance.
             <p>Useful for reconstructing a <code>NoticeReference</code>
             instance from its encodable/encoded form.</p>
            
             @param as an <code>Asn1Sequence</code> value obtained from either
             calling @{link ToAsn1Object()} for a <code>NoticeReference</code>
             instance or from parsing it from a Der-encoded stream.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.NoticeReference.ToAsn1Object">
             Describe <code>ToAsn1Object</code> method here.
            
             @return a <code>Asn1Object</code> value
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.ObjectDigestInfo">
            ObjectDigestInfo ASN.1 structure used in v2 attribute certificates.
            
            <pre>
             
               ObjectDigestInfo ::= SEQUENCE {
                    digestedObjectType  ENUMERATED {
                            publicKey            (0),
                            publicKeyCert        (1),
                            otherObjectTypes     (2) },
                                    -- otherObjectTypes MUST NOT
                                    -- be used in this profile
                    otherObjectTypeID   OBJECT IDENTIFIER OPTIONAL,
                    digestAlgorithm     AlgorithmIdentifier,
                    objectDigest        BIT STRING
               }
              
            </pre>
            
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.PublicKey">
            The public key is hashed.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.PublicKeyCert">
            The public key certificate is hashed.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.OtherObjectDigest">
            An other object is hashed.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.#ctor(System.Int32,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,System.Byte[])">
            Constructor from given details.
            <p>
            If <code>digestedObjectType</code> is not {@link #publicKeyCert} or
            {@link #publicKey} <code>otherObjectTypeID</code> must be given,
            otherwise it is ignored.</p>
            
            @param digestedObjectType The digest object type.
            @param otherObjectTypeID The object type ID for
                       <code>otherObjectDigest</code>.
            @param digestAlgorithm The algorithm identifier for the hash.
            @param objectDigest The hash value.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            <pre>
             
               ObjectDigestInfo ::= SEQUENCE {
                    digestedObjectType  ENUMERATED {
                            publicKey            (0),
                            publicKeyCert        (1),
                            otherObjectTypes     (2) },
                                    -- otherObjectTypes MUST NOT
                                    -- be used in this profile
                    otherObjectTypeID   OBJECT IDENTIFIER OPTIONAL,
                    digestAlgorithm     AlgorithmIdentifier,
                    objectDigest        BIT STRING
               }
              
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.OtherName">
            The OtherName object.
            <pre>
            OtherName ::= SEQUENCE {
                 type-id    OBJECT IDENTIFIER,
                 value      [0] EXPLICIT ANY DEFINED BY type-id }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.OtherName.GetInstance(System.Object)">
            OtherName factory method.
            @param obj the object used to construct an instance of <code>
            OtherName</code>. It must be an instance of <code>OtherName
            </code> or <code>ASN1Sequence</code>.
            @return the instance of <code>OtherName</code> built from the
            supplied object.
            @throws java.lang.IllegalArgumentException if the object passed
            to the factory is not an instance of <code>OtherName</code> or something that
            can be converted into an appropriate <code>ASN1Sequence</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.OtherName.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            Base constructor.
            @param typeID the type of the other name.
            @param value the ANY object that represents the value.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.PolicyMappings">
             PolicyMappings V3 extension, described in RFC3280.
             <pre>
                PolicyMappings ::= Sequence SIZE (1..MAX) OF Sequence {
                  issuerDomainPolicy      CertPolicyId,
                  subjectDomainPolicy     CertPolicyId }
             </pre>
            
             @see <a href="http://www.faqs.org/rfc/rfc3280.txt">RFC 3280, section 4.2.1.6</a>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.PolicyMappings.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>PolicyMappings</code> instance.
            
             @param seq an <code>Asn1Sequence</code> constructed as specified
             in RFC 3280
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.PolicyMappings.#ctor(System.Collections.Generic.IDictionary{System.String,System.String})">
             Creates a new <code>PolicyMappings</code> instance.
            
             @param mappings a <code>HashMap</code> value that maps
             <code>string</code> oids
             to other <code>string</code> oids.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.PolicyQualifierID">
             PolicyQualifierId, used in the CertificatePolicies
             X509V3 extension.
            
             <pre>
                id-qt          OBJECT IDENTIFIER ::=  { id-pkix 2 }
                id-qt-cps      OBJECT IDENTIFIER ::=  { id-qt 1 }
                id-qt-unotice  OBJECT IDENTIFIER ::=  { id-qt 2 }
              PolicyQualifierId ::=
                   OBJECT IDENTIFIER ( id-qt-cps | id-qt-unotice )
             </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo">
             Policy qualifiers, used in the X509V3 CertificatePolicies
             extension.
            
             <pre>
               PolicyQualifierInfo ::= Sequence {
                   policyQualifierId  PolicyQualifierId,
                   qualifier          ANY DEFINED BY policyQualifierId }
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
             Creates a new <code>PolicyQualifierInfo</code> instance.
            
             @param policyQualifierId a <code>PolicyQualifierId</code> value
             @param qualifier the qualifier, defined by the above field.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo.#ctor(System.String)">
             Creates a new <code>PolicyQualifierInfo</code> containing a
             cPSuri qualifier.
            
             @param cps the CPS (certification practice statement) uri as a
             <code>string</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>PolicyQualifierInfo</code> instance.
            
             @param as <code>PolicyQualifierInfo</code> X509 structure
             encoded as an Asn1Sequence.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo.ToAsn1Object">
             Returns a Der-encodable representation of this instance.
            
             @return a <code>Asn1Object</code> value
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.PrivateKeyUsagePeriod">
            <remarks>
            <pre>
            PrivateKeyUsagePeriod ::= SEQUENCE
            {
            notBefore       [0]     GeneralizedTime OPTIONAL,
            notAfter        [1]     GeneralizedTime OPTIONAL }
            </pre>
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Qualified.BiometricData">
            The BiometricData object.
            <pre>
            BiometricData  ::=  SEQUENCE {
                  typeOfBiometricData  TypeOfBiometricData,
                  hashAlgorithm        AlgorithmIdentifier,
                  biometricDataHash    OCTET STRING,
                  sourceDataUri        IA5String OPTIONAL  }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Qualified.Iso4217CurrencyCode">
            The Iso4217CurrencyCode object.
            <pre>
            Iso4217CurrencyCode  ::=  CHOICE {
                  alphabetic              PrintableString (SIZE 3), --Recommended
                  numeric              INTEGER (1..999) }
            -- Alphabetic or numeric currency code as defined in ISO 4217
            -- It is recommended that the Alphabetic form is used
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Qualified.MonetaryValue">
            The MonetaryValue object.
            <pre>
            MonetaryValue  ::=  SEQUENCE {
                  currency              Iso4217CurrencyCode,
                  amount               INTEGER,
                  exponent             INTEGER }
            -- value = amount * 10^exponent
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Qualified.QCStatement">
            The QCStatement object.
            <pre>
            QCStatement ::= SEQUENCE {
              statementId        OBJECT IDENTIFIER,
              statementInfo      ANY DEFINED BY statementId OPTIONAL}
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Qualified.SemanticsInformation">
             The SemanticsInformation object.
             <pre>
                   SemanticsInformation ::= SEQUENCE {
                     semanticsIdentifier        OBJECT IDENTIFIER   OPTIONAL,
                     nameRegistrationAuthorities NameRegistrationAuthorities
                                                                     OPTIONAL }
                     (WITH COMPONENTS {..., semanticsIdentifier PRESENT}|
                      WITH COMPONENTS {..., nameRegistrationAuthorities PRESENT})
            
                 NameRegistrationAuthorities ::=  SEQUENCE SIZE (1..MAX) OF
                     GeneralName
             </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Qualified.TypeOfBiometricData">
             The TypeOfBiometricData object.
             <pre>
             TypeOfBiometricData ::= CHOICE {
               predefinedBiometricType   PredefinedBiometricType,
               biometricDataOid          OBJECT IDENTIFIER }
            
             PredefinedBiometricType ::= INTEGER {
               picture(0),handwritten-signature(1)}
               (picture|handwritten-signature)
             </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.ReasonFlags">
            The ReasonFlags object.
            <pre>
            ReasonFlags ::= BIT STRING {
               unused(0),
               keyCompromise(1),
               cACompromise(2),
               affiliationChanged(3),
               superseded(4),
               cessationOfOperation(5),
               certficateHold(6)
            }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.ReasonFlags.#ctor(System.Int32)">
            @param reasons - the bitwise OR of the Key Reason flags giving the
            allowed uses for the key.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.RoleSyntax">
             Implementation of the RoleSyntax object as specified by the RFC3281.
            
             <pre>
             RoleSyntax ::= SEQUENCE {
                             roleAuthority  [0] GeneralNames OPTIONAL,
                             roleName       [1] GeneralName
                       }
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.RoleSyntax.GetInstance(System.Object)">
            RoleSyntax factory method.
            @param obj the object used to construct an instance of <code>
            RoleSyntax</code>. It must be an instance of <code>RoleSyntax
            </code> or <code>Asn1Sequence</code>.
            @return the instance of <code>RoleSyntax</code> built from the
            supplied object.
            @throws java.lang.ArgumentException if the object passed
            to the factory is not an instance of <code>RoleSyntax</code> or
            <code>Asn1Sequence</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.RoleSyntax.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralNames,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName)">
            Constructor.
            @param roleAuthority the role authority of this RoleSyntax.
            @param roleName    the role name of this RoleSyntax.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.RoleSyntax.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName)">
            Constructor. Invoking this constructor is the same as invoking
            <code>new RoleSyntax(null, roleName)</code>.
            @param roleName    the role name of this RoleSyntax.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.RoleSyntax.#ctor(System.String)">
            Utility constructor. Takes a <code>string</code> argument representing
            the role name, builds a <code>GeneralName</code> to hold the role name
            and calls the constructor that takes a <code>GeneralName</code>.
            @param roleName
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.RoleSyntax.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor that builds an instance of <code>RoleSyntax</code> by
            extracting the encoded elements from the <code>Asn1Sequence</code>
            object supplied.
            @param seq    an instance of <code>Asn1Sequence</code> that holds
            the encoded elements used to build this <code>RoleSyntax</code>.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.RoleSyntax.RoleAuthority">
            Gets the role authority of this RoleSyntax.
            @return    an instance of <code>GeneralNames</code> holding the
            role authority of this RoleSyntax.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.RoleSyntax.RoleName">
            Gets the role name of this RoleSyntax.
            @return    an instance of <code>GeneralName</code> holding the
            role name of this RoleSyntax.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.RoleSyntax.GetRoleNameAsString">
            Gets the role name as a <code>java.lang.string</code> object.
            @return    the role name of this RoleSyntax represented as a
            <code>string</code> object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.RoleSyntax.GetRoleAuthorityAsString">
            Gets the role authority as a <code>string[]</code> object.
            @return the role authority of this RoleSyntax represented as a
            <code>string[]</code> array.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.RoleSyntax.ToAsn1Object">
             Implementation of the method <code>ToAsn1Object</code> as
             required by the superclass <code>ASN1Encodable</code>.
            
             <pre>
             RoleSyntax ::= SEQUENCE {
                             roleAuthority  [0] GeneralNames OPTIONAL,
                             roleName       [1] GeneralName
                       }
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.RsaPublicKeyStructure.ToAsn1Object">
            This outputs the key in Pkcs1v2 format.
            <pre>
                 RSAPublicKey ::= Sequence {
                                     modulus Integer, -- n
                                     publicExponent Integer, -- e
                                 }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym">
            Structure for a name or pseudonym.
            
            <pre>
                  NameOrPseudonym ::= CHOICE {
                	   surAndGivenName SEQUENCE {
                	     surName DirectoryString,
                	     givenName SEQUENCE OF DirectoryString 
                    },
                	   pseudonym DirectoryString 
                  }
            </pre>
            
            @see org.bouncycastle.asn1.x509.sigi.PersonalData
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.DirectoryString)">
            Constructor from DERString.
            <p/>
            The sequence is of type NameOrPseudonym:
            <p/>
            <pre>
                  NameOrPseudonym ::= CHOICE {
                	   surAndGivenName SEQUENCE {
                	     surName DirectoryString,
                	     givenName SEQUENCE OF DirectoryString
                    },
                	   pseudonym DirectoryString
                  }
            </pre>
            @param pseudonym pseudonym value to use.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type NameOrPseudonym:
             <p/>
             <pre>
                   NameOrPseudonym ::= CHOICE {
                 	   surAndGivenName SEQUENCE {
                 	     surName DirectoryString,
                 	     givenName SEQUENCE OF DirectoryString
                     },
                 	   pseudonym DirectoryString
                   }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.#ctor(System.String)">
             Constructor from a given details.
            
             @param pseudonym The pseudonym.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.DirectoryString,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from a given details.
            
             @param surname   The surname.
             @param givenName A sequence of directory strings making up the givenName
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                   NameOrPseudonym ::= CHOICE {
                 	   surAndGivenName SEQUENCE {
                 	     surName DirectoryString,
                 	     givenName SEQUENCE OF DirectoryString
                     },
                 	   pseudonym DirectoryString
                   }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.PersonalData">
             Contains personal data for the otherName field in the subjectAltNames
             extension.
             <p/>
             <pre>
                 PersonalData ::= SEQUENCE {
                   nameOrPseudonym NameOrPseudonym,
                   nameDistinguisher [0] INTEGER OPTIONAL,
                   dateOfBirth [1] GeneralizedTime OPTIONAL,
                   placeOfBirth [2] DirectoryString OPTIONAL,
                   gender [3] PrintableString OPTIONAL,
                   postalAddress [4] DirectoryString OPTIONAL
                   }
             </pre>
            
             @see org.bouncycastle.asn1.x509.sigi.NameOrPseudonym
             @see org.bouncycastle.asn1.x509.sigi.SigIObjectIdentifiers
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.PersonalData.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type NameOrPseudonym:
             <p/>
             <pre>
                 PersonalData ::= SEQUENCE {
                   nameOrPseudonym NameOrPseudonym,
                   nameDistinguisher [0] INTEGER OPTIONAL,
                   dateOfBirth [1] GeneralizedTime OPTIONAL,
                   placeOfBirth [2] DirectoryString OPTIONAL,
                   gender [3] PrintableString OPTIONAL,
                   postalAddress [4] DirectoryString OPTIONAL
                   }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.PersonalData.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1GeneralizedTime,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.DirectoryString,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X500.DirectoryString)">
             Constructor from a given details.
            
             @param nameOrPseudonym  Name or pseudonym.
             @param nameDistinguisher Name distinguisher.
             @param dateOfBirth      Date of birth.
             @param placeOfBirth     Place of birth.
             @param gender           Gender.
             @param postalAddress    Postal Address.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.PersonalData.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                 PersonalData ::= SEQUENCE {
                   nameOrPseudonym NameOrPseudonym,
                   nameDistinguisher [0] INTEGER OPTIONAL,
                   dateOfBirth [1] GeneralizedTime OPTIONAL,
                   placeOfBirth [2] DirectoryString OPTIONAL,
                   gender [3] PrintableString OPTIONAL,
                   postalAddress [4] DirectoryString OPTIONAL
                   }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers">
            Object Identifiers of SigI specifciation (German Signature Law
            Interoperability specification).
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigIKP">
            Key purpose IDs for German SigI (Signature Interoperability
            Specification)
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigICP">
            Certificate policy IDs for German SigI (Signature Interoperability
            Specification)
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigION">
            Other Name IDs for German SigI (Signature Interoperability Specification)
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigIKPDirectoryService">
            To be used for for the generation of directory service certificates.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigIONPersonalData">
            ID for PersonalData
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigICPSigConform">
            Certificate is conform to german signature law.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes">
             This extension may contain further X.500 attributes of the subject. See also
             RFC 3039.
            
             <pre>
                 SubjectDirectoryAttributes ::= Attributes
                 Attributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
                 Attribute ::= SEQUENCE
                 {
                   type AttributeType
                   values SET OF AttributeValue
                 }
            
                 AttributeType ::= OBJECT IDENTIFIER
                 AttributeValue ::= ANY DEFINED BY AttributeType
             </pre>
            
             @see org.bouncycastle.asn1.x509.X509Name for AttributeType ObjectIdentifiers.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
            
             The sequence is of type SubjectDirectoryAttributes:
            
             <pre>
                  SubjectDirectoryAttributes ::= Attributes
                  Attributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
                  Attribute ::= SEQUENCE
                  {
                    type AttributeType
                    values SET OF AttributeValue
                  }
            
                  AttributeType ::= OBJECT IDENTIFIER
                  AttributeValue ::= ANY DEFINED BY AttributeType
             </pre>
            
             @param seq
                        The ASN.1 sequence.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes.#ctor(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AttributeX509})">
             Constructor from an ArrayList of attributes.
            
             The ArrayList consists of attributes of type {@link Attribute Attribute}
            
             @param attributes The attributes.
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
            
             Returns:
            
             <pre>
                  SubjectDirectoryAttributes ::= Attributes
                  Attributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
                  Attribute ::= SEQUENCE
                  {
                    type AttributeType
                    values SET OF AttributeValue
                  }
            
                  AttributeType ::= OBJECT IDENTIFIER
                  AttributeValue ::= ANY DEFINED BY AttributeType
             </pre>
            
             @return a DERObject
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes.Attributes">
            @return Returns the attributes.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier">
            The SubjectKeyIdentifier object.
            <pre>
            SubjectKeyIdentifier::= OCTET STRING
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
             Calculates the keyIdentifier using a SHA1 hash over the BIT STRING
             from SubjectPublicKeyInfo as defined in RFC3280.
            
             @param spki the subject public key info.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier.CreateSha1KeyIdentifier(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Return a RFC 3280 type 1 key identifier. As in:
            <pre>
            (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
            value of the BIT STRING subjectPublicKey (excluding the tag,
            length, and number of unused bits).
            </pre>
            @param keyInfo the key info object containing the subjectPublicKey field.
            @return the key identifier.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier.CreateTruncatedSha1KeyIdentifier(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Return a RFC 3280 type 2 key identifier. As in:
            <pre>
            (2) The keyIdentifier is composed of a four bit type field with
            the value 0100 followed by the least significant 60 bits of the
            SHA-1 hash of the value of the BIT STRING subjectPublicKey.
            </pre>
            @param keyInfo the key info object containing the subjectPublicKey field.
            @return the key identifier.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo">
            The object that contains the public key stored in a certficate.
            <p>
            The GetEncoded() method in the public keys in the JCE produces a DER
            encoded one of these.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.ParsePublicKey">
             for when the public key is an encoded object - if the bitstring
             can't be decoded this routine raises an IOException.
            
             @exception IOException - if the bit string doesn't represent a Der
             encoded object.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.PublicKeyData">
            for when the public key is raw bits...
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SubjectPublicKeyInfo ::= Sequence {
                                     algorithm AlgorithmIdentifier,
                                     publicKey BIT STRING }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Target">
            Target structure used in target information extension for attribute
            certificates from RFC 3281.
            
            <pre>
                Target  ::= CHOICE {
                  targetName          [0] GeneralName,
                  targetGroup         [1] GeneralName,
                  targetCert          [2] TargetCert
                }
            </pre>
            
            <p>
            The targetCert field is currently not supported and must not be used
            according to RFC 3281.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Target.GetInstance(System.Object)">
            Creates an instance of a Target from the given object.
            <p>
            <code>obj</code> can be a Target or a {@link Asn1TaggedObject}</p>
            
            @param obj The object.
            @return A Target instance.
            @throws ArgumentException if the given object cannot be
                        interpreted as Target.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Target.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject)">
            Constructor from Asn1TaggedObject.
            
            @param tagObj The tagged object.
            @throws ArgumentException if the encoding is wrong.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Target.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Target.Choice,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName)">
             Constructor from given details.
             <p>
             Exactly one of the parameters must be not <code>null</code>.</p>
            
             @param type the choice type to apply to the name.
             @param name the general name.
             @throws ArgumentException if type is invalid.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Target.TargetGroup">
            @return Returns the targetGroup.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Target.TargetName">
            @return Returns the targetName.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Target.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            Returns:
            
            <pre>
                Target  ::= CHOICE {
                  targetName          [0] GeneralName,
                  targetGroup         [1] GeneralName,
                  targetCert          [2] TargetCert
                }
            </pre>
            
            @return an Asn1Object
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.TargetInformation">
            Target information extension for attributes certificates according to RFC
            3281.
            
            <pre>
                      SEQUENCE OF Targets
            </pre>
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.TargetInformation.GetInstance(System.Object)">
            Creates an instance of a TargetInformation from the given object.
            <p>
            <code>obj</code> can be a TargetInformation or a {@link Asn1Sequence}</p>
            
            @param obj The object.
            @return A TargetInformation instance.
            @throws ArgumentException if the given object cannot be interpreted as TargetInformation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.TargetInformation.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor from a Asn1Sequence.
            
            @param seq The Asn1Sequence.
            @throws ArgumentException if the sequence does not contain
                        correctly encoded Targets elements.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.TargetInformation.GetTargetsObjects">
            Returns the targets in this target information extension.
            <p>
            The ArrayList is cloned before it is returned.</p>
            
            @return Returns the targets.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.TargetInformation.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Targets)">
            Constructs a target information from a single targets element. 
            According to RFC 3281 only one targets element must be produced.
            
            @param targets A Targets instance.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.TargetInformation.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Target[])">
             According to RFC 3281 only one targets element must be produced. If
             multiple targets are given they must be merged in
             into one targets element.
            
             @param targets An array with {@link Targets}.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.TargetInformation.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            Returns:
            
            <pre>
                     SEQUENCE OF Targets
            </pre>
            
            <p>
            According to RFC 3281 only one targets element must be produced. If
            multiple targets are given in the constructor they are merged into one
            targets element. If this was produced from a
            {@link Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence} the encoding is kept.</p>
            
            @return an Asn1Object
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Targets">
            Targets structure used in target information extension for attribute
            certificates from RFC 3281.
            
            <pre>
                       Targets ::= SEQUENCE OF Target
                      
                       Target  ::= CHOICE {
                         targetName          [0] GeneralName,
                         targetGroup         [1] GeneralName,
                         targetCert          [2] TargetCert
                       }
                      
                       TargetCert  ::= SEQUENCE {
                         targetCertificate    IssuerSerial,
                         targetName           GeneralName OPTIONAL,
                         certDigestInfo       ObjectDigestInfo OPTIONAL
                       }
            </pre>
            
            @see org.bouncycastle.asn1.x509.Target
            @see org.bouncycastle.asn1.x509.TargetInformation
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Targets.GetInstance(System.Object)">
            Creates an instance of a Targets from the given object.
            <p>
            <code>obj</code> can be a Targets or a {@link Asn1Sequence}</p>
            
            @param obj The object.
            @return A Targets instance.
            @throws ArgumentException if the given object cannot be interpreted as Target.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Targets.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor from Asn1Sequence.
            
            @param targets The ASN.1 SEQUENCE.
            @throws ArgumentException if the contents of the sequence are
                        invalid.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Targets.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Target[])">
            Constructor from given targets.
            <p>
            The ArrayList is copied.</p>
            
            @param targets An <code>ArrayList</code> of {@link Target}s.
            @see Target
            @throws ArgumentException if the ArrayList contains not only Targets.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Targets.GetTargets">
            Returns the targets in an <code>ArrayList</code>.
            <p>
            The ArrayList is cloned before it is returned.</p>
            
            @return Returns the targets.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Targets.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            Returns:
            
            <pre>
                       Targets ::= SEQUENCE OF Target
            </pre>
            
            @return an Asn1Object
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.TbsCertificateStructure">
            The TbsCertificate object.
            <pre>
            TbsCertificate ::= Sequence {
                 version          [ 0 ]  Version DEFAULT v1(0),
                 serialNumber            CertificateSerialNumber,
                 signature               AlgorithmIdentifier,
                 issuer                  Name,
                 validity                Validity,
                 subject                 Name,
                 subjectPublicKeyInfo    SubjectPublicKeyInfo,
                 issuerUniqueID    [ 1 ] IMPLICIT UniqueIdentifier OPTIONAL,
                 subjectUniqueID   [ 2 ] IMPLICIT UniqueIdentifier OPTIONAL,
                 extensions        [ 3 ] Extensions OPTIONAL
                 }
            </pre>
            <p>
            Note: issuerUniqueID and subjectUniqueID are both deprecated by the IETF. This class
            will parse them, but you really shouldn't be creating new ones.</p>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.TbsCertificateList">
            PKIX RFC-2459 - TbsCertList object.
            <pre>
            TbsCertList  ::=  Sequence  {
                 version                 Version OPTIONAL,
                                              -- if present, shall be v2
                 signature               AlgorithmIdentifier,
                 issuer                  Name,
                 thisUpdate              Time,
                 nextUpdate              Time OPTIONAL,
                 revokedCertificates     Sequence OF Sequence  {
                      userCertificate         CertificateSerialNumber,
                      revocationDate          Time,
                      crlEntryExtensions      Extensions OPTIONAL
                                                    -- if present, shall be v2
                                           }  OPTIONAL,
                 crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
                                                    -- if present, shall be v2
                                           }
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Time.#ctor(System.DateTime)">
            creates a time object from a given date - if the date is between 1950
            and 2049 a UTCTime object is Generated, otherwise a GeneralizedTime
            is used.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Time.ToDateTime">
            <summary>
            Return our time as DateTime.
            </summary>
            <returns>A date time.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.Time.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Time ::= CHOICE {
                        utcTime        UTCTime,
                        generalTime    GeneralizedTime }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.UserNotice">
             <code>UserNotice</code> class, used in
             <code>CertificatePolicies</code> X509 extensions (in policy
             qualifiers).
             <pre>
             UserNotice ::= Sequence {
                  noticeRef        NoticeReference OPTIONAL,
                  explicitText     DisplayText OPTIONAL}
            
             </pre>
            
             @see PolicyQualifierId
             @see PolicyInformation
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.UserNotice.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.NoticeReference,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DisplayText)">
             Creates a new <code>UserNotice</code> instance.
            
             @param noticeRef a <code>NoticeReference</code> value
             @param explicitText a <code>DisplayText</code> value
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.UserNotice.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.NoticeReference,System.String)">
             Creates a new <code>UserNotice</code> instance.
            
             @param noticeRef a <code>NoticeReference</code> value
             @param str the explicitText field as a string.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.V1TbsCertificateGenerator">
             Generator for Version 1 TbsCertificateStructures.
             <pre>
             TbsCertificate ::= Sequence {
                  version          [ 0 ]  Version DEFAULT v1(0),
                  serialNumber            CertificateSerialNumber,
                  signature               AlgorithmIdentifier,
                  issuer                  Name,
                  validity                Validity,
                  subject                 Name,
                  subjectPublicKeyInfo    SubjectPublicKeyInfo,
                  }
             </pre>
            
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.V2AttributeCertificateInfoGenerator">
             Generator for Version 2 AttributeCertificateInfo
             <pre>
             AttributeCertificateInfo ::= Sequence {
                   version              AttCertVersion -- version is v2,
                   holder               Holder,
                   issuer               AttCertIssuer,
                   signature            AlgorithmIdentifier,
                   serialNumber         CertificateSerialNumber,
                   attrCertValidityPeriod   AttCertValidityPeriod,
                   attributes           Sequence OF Attr,
                   issuerUniqueID       UniqueIdentifier OPTIONAL,
                   extensions           Extensions OPTIONAL
             }
             </pre>
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.V2AttributeCertificateInfoGenerator.AddAttribute(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AttributeX509)">
            @param attribute
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.V2Form.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             V2Form ::= Sequence {
                  issuerName            GeneralNames  OPTIONAL,
                  baseCertificateID     [0] IssuerSerial  OPTIONAL,
                  objectDigestInfo      [1] ObjectDigestInfo  OPTIONAL
                    -- issuerName MUST be present in this profile
                    -- baseCertificateID and objectDigestInfo MUST NOT
                    -- be present in this profile
             }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.V2TbsCertListGenerator">
             Generator for Version 2 TbsCertList structures.
             <pre>
              TbsCertList  ::=  Sequence  {
                   version                 Version OPTIONAL,
                                                -- if present, shall be v2
                   signature               AlgorithmIdentifier,
                   issuer                  Name,
                   thisUpdate              Time,
                   nextUpdate              Time OPTIONAL,
                   revokedCertificates     Sequence OF Sequence  {
                        userCertificate         CertificateSerialNumber,
                        revocationDate          Time,
                        crlEntryExtensions      Extensions OPTIONAL
                                                      -- if present, shall be v2
                                             }  OPTIONAL,
                   crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
                                                      -- if present, shall be v2
                                             }
             </pre>
            
             <b>Note: This class may be subject to change</b>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.V3TbsCertificateGenerator">
             Generator for Version 3 TbsCertificateStructures.
             <pre>
             TbsCertificate ::= Sequence {
                  version          [ 0 ]  Version DEFAULT v1(0),
                  serialNumber            CertificateSerialNumber,
                  signature               AlgorithmIdentifier,
                  issuer                  Name,
                  validity                Validity,
                  subject                 Name,
                  subjectPublicKeyInfo    SubjectPublicKeyInfo,
                  issuerUniqueID    [ 1 ] IMPLICIT UniqueIdentifier OPTIONAL,
                  subjectUniqueID   [ 2 ] IMPLICIT UniqueIdentifier OPTIONAL,
                  extensions        [ 3 ] Extensions OPTIONAL
                  }
             </pre>
            
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509CertificateStructure">
            an X509Certificate structure.
            <pre>
             Certificate ::= Sequence {
                 tbsCertificate          TbsCertificate,
                 signatureAlgorithm      AlgorithmIdentifier,
                 signature               BIT STRING
             }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509DefaultEntryConverter">
            The default converter for X509 DN entries when going from their
            string value to ASN.1 strings.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509DefaultEntryConverter.GetConvertedValue(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String)">
             Apply default conversion for the given value depending on the oid
             and the character range of the value.
            
             @param oid the object identifier for the DN entry
             @param value the value associated with it
             @return the ASN.1 equivalent for the string value.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extension">
            an object for the elements in the X.509 V3 extension block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extension.ConvertValueToObject(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extension)">
            <sumary>Convert the value of the passed in extension to an object.</sumary>
            <param name="ext">The extension to parse.</param>
            <returns>The object the value string contains.</returns>
            <exception cref="T:System.ArgumentException">If conversion is not possible.</exception>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectDirectoryAttributes">
            Subject Directory Attributes
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectKeyIdentifier">
            Subject Key Identifier
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.KeyUsage">
            Key Usage
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.PrivateKeyUsagePeriod">
            Private Key Usage Period
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectAlternativeName">
            Subject Alternative Name
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.IssuerAlternativeName">
            Issuer Alternative Name
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.BasicConstraints">
            Basic Constraints
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.CrlNumber">
            CRL Number
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.ReasonCode">
            Reason code
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.InstructionCode">
            Hold Instruction Code
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.InvalidityDate">
            Invalidity Date
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.DeltaCrlIndicator">
            Delta CRL indicator
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.IssuingDistributionPoint">
            Issuing Distribution Point
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.CertificateIssuer">
            Certificate Issuer
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.NameConstraints">
            Name Constraints
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.CrlDistributionPoints">
            CRL Distribution Points
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.CertificatePolicies">
            Certificate Policies
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.PolicyMappings">
            Policy Mappings
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.AuthorityKeyIdentifier">
            Authority Key Identifier
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.PolicyConstraints">
            Policy Constraints
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.ExtendedKeyUsage">
            Extended Key Usage
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.FreshestCrl">
            Freshest CRL
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.InhibitAnyPolicy">
            Inhibit Any Policy
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.AuthorityInfoAccess">
            Authority Info Access
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectInfoAccess">
            Subject Info Access
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.LogoType">
            Logo Type
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.BiometricInfo">
            BiometricInfo
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.QCStatements">
            QCStatements
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.AuditIdentity">
            Audit identity extension in attribute certificates.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.NoRevAvail">
            NoRevAvail extension in attribute certificates.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.TargetInformation">
            TargetInformation extension in attribute certificates.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.ExpiredCertsOnCrl">
            Expired Certificates on CRL extension
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
            
             the extensions are a list of constructed sequences, either with (Oid, OctetString) or (Oid, Boolean, OctetString)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.Generic.IDictionary{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extension})">
            constructor from a table of extensions.
            <p>
            it's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier},System.Collections.Generic.IDictionary{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extension})">
            Constructor from a table of extensions with ordering.
            <p>
            It's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier},System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extension})">
             Constructor from two vectors
            
             @param objectIDs an ArrayList of the object identifiers.
             @param values an ArrayList of the extension values.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.ExtensionOids">
            return an Enumeration of the extension field's object ids.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.GetExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the extension represented by the object identifier
             passed in.
            
             @return the extension if it's present, null otherwise.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.GetExtensionParsedValue(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the parsed value of the extension represented by the object identifier
             passed in.
            
             @return the parsed value of the extension if it's present, null otherwise.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions.ToAsn1Object">
             <pre>
                 Extensions        ::=   SEQUENCE SIZE (1..MAX) OF Extension
            
                 Extension         ::=   SEQUENCE {
                    extnId            EXTENSION.&amp;id ({ExtensionSet}),
                    critical          BOOLEAN DEFAULT FALSE,
                    extnValue         OCTET STRING }
             </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator">
            <remarks>Generator for X.509 extensions</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.Reset">
            <summary>Reset the generator</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.AddExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>
            Add an extension with the given oid and the passed in value to be included
            in the OCTET STRING associated with the extension.
            </summary>
            <param name="oid">OID for the extension.</param>
            <param name="critical">True if critical, false otherwise.</param>
            <param name="extValue">The ASN.1 object to be included in the extension.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.AddExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,System.Byte[])">
            <summary>
            Add an extension with the given oid and the passed in byte array to be wrapped
            in the OCTET STRING associated with the extension.
            </summary>
            <param name="oid">OID for the extension.</param>
            <param name="critical">True if critical, false otherwise.</param>
            <param name="extValue">The byte array to be wrapped.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.IsEmpty">
            <summary>Return true if there are no extension present in this generator.</summary>
            <returns>True if empty, false otherwise</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.Generate">
            <summary>Generate an X509Extensions object based on the current state of the generator.</summary>
            <returns>An <c>X509Extensions</c> object</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name">
             <pre>
                 RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
            
                 RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue
            
                 AttributeTypeAndValue ::= SEQUENCE {
                                               type  OBJECT IDENTIFIER,
                                               value ANY }
             </pre>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.C">
            country code - StringType(SIZE(2))
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.O">
            organization - StringType(SIZE(1..64))
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.OU">
            organizational unit name - StringType(SIZE(1..64))
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.T">
            Title
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.CN">
            common name - StringType(SIZE(1..64))
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.Street">
            street - StringType(SIZE(1..64))
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.SerialNumber">
            device serial number name - StringType(SIZE(1..64))
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.L">
            locality name - StringType(SIZE(1..64))
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.ST">
            state, or province name - StringType(SIZE(1..64))
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.Surname">
            Naming attributes of type X520name
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.BusinessCategory">
            businessCategory - DirectoryString(SIZE(1..128)
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.PostalCode">
            postalCode - DirectoryString(SIZE(1..40)
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.DnQualifier">
            dnQualifier - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.Pseudonym">
            RFC 3039 Pseudonym - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.DateOfBirth">
            RFC 3039 DateOfBirth - GeneralizedTime - YYYYMMDD000000Z
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.PlaceOfBirth">
            RFC 3039 PlaceOfBirth - DirectoryString(SIZE(1..128)
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.Gender">
            RFC 3039 DateOfBirth - PrintableString (SIZE(1)) -- "M", "F", "m" or "f"
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.CountryOfCitizenship">
            RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
            codes only
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.CountryOfResidence">
            RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
            codes only
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.NameAtBirth">
            ISIS-MTT NameAtBirth - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.PostalAddress">
            RFC 3039 PostalAddress - SEQUENCE SIZE (1..6) OF
            DirectoryString(SIZE(1..30))
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.DmdName">
            RFC 2256 dmdName
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.TelephoneNumber">
            id-at-telephoneNumber
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.OrganizationIdentifier">
            id-at-organizationIdentifier
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.Name">
            id-at-name
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.EmailAddress">
            Email address (RSA PKCS#9 extension) - IA5String.
            <p>Note: if you're trying to be ultra orthodox, don't use this! It shouldn't be in here.</p>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.UnstructuredName">
            more from PKCS#9
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.E">
            email address in Verisign certificates
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.UID">
            LDAP User id.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.DefaultReverse">
            determines whether or not strings should be processed and printed
            from back to front.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.DefaultSymbolsInternal">
            default look up table translating OID values into their common symbols following
            the convention in RFC 2253 with a few extras
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.RFC2253SymbolsInternal">
            look up table translating OID values into their common symbols following the convention in RFC 2253
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.RFC1779SymbolsInternal">
             look up table translating OID values into their common symbols following the convention in RFC 1779
            
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.DefaultLookupInternal">
            look up table translating common symbols into their OIDS.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return a X509Name based on the passed in tagged object.
            
             @param obj tag object holding name.
             @param explicitly true if explicitly tagged false otherwise.
             @return the X509Name
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence
            
             the principal will be a list of constructed sets, each containing an (OID, string) pair.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier},System.Collections.Generic.IDictionary{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String})">
            Constructor from a table of attributes with ordering.
            <p>
            it's is assumed the table contains OID/string pairs, and the contents
            of the table are copied into an internal table as part of the
            construction process. The ordering ArrayList should contain the OIDs
            in the order they are meant to be encoded or printed in ToString.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier},System.Collections.Generic.IDictionary{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String},Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Constructor from a table of attributes with ordering.
            <p>
            it's is assumed the table contains OID/string pairs, and the contents
            of the table are copied into an internal table as part of the
            construction process. The ordering ArrayList should contain the OIDs
            in the order they are meant to be encoded or printed in ToString.</p>
            <p>
            The passed in converter will be used to convert the strings into their
            ASN.1 counterparts.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier},System.Collections.Generic.IList{System.String})">
            Takes two vectors one of the oids and the other of the values.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier},System.Collections.Generic.IList{System.String},Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes two vectors one of the oids and the other of the values.
            <p>
            The passed in converter will be used to convert the strings into their
            ASN.1 counterparts.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes with each
            string value being converted to its associated ASN.1 type using the passed
            in converter.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. If reverse
            is true, create the encoded version of the sequence starting from the
            last element in the string.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes with each
            string value being converted to its associated ASN.1 type using the passed
            in converter. If reverse is true the ASN.1 sequence representing the DN will
            be built by starting at the end of the string, rather than the start.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.Collections.Generic.IDictionary{System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier},System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. lookUp
            should provide a table of lookups, indexed by lowercase only strings and
            yielding a DerObjectIdentifier, other than that OID. and numeric oids
            will be processed automatically.
            <br/>
            If reverse is true, create the encoded version of the sequence
            starting from the last element in the string.
            @param reverse true if we should start scanning from the end (RFC 2553).
            @param lookUp table of names and their oids.
            @param dirName the X.500 string to be parsed.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.Collections.Generic.IDictionary{System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier},System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. lookUp
            should provide a table of lookups, indexed by lowercase only strings and
            yielding a DerObjectIdentifier, other than that OID. and numeric oids
            will be processed automatically. The passed in converter is used to convert the
            string values to the right of each equals sign to their ASN.1 counterparts.
            <br/>
            @param reverse true if we should start scanning from the end, false otherwise.
            @param lookUp table of names and oids.
            @param dirName the string dirName
            @param converter the converter to convert string values into their ASN.1 equivalents
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.GetOidList">
            return an IList of the oids in the name, in the order they were found.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.GetValueList">
            return an IList of the values found in the name, in the order they
            were found.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.GetValueList(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return an IList of the values found in the name, in the order they
            were found, with the DN label corresponding to passed in oid.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.Equivalent(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name,System.Boolean)">
            <param name="other">The X509Name object to test equivalency against.</param>
            <param name="inOrder">If true, the order of elements must be the same,
            as well as the values associated with each element.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.Equivalent(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name)">
            test for equivalence - note: case is ignored.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name.ToString(System.Boolean,System.Collections.Generic.IDictionary{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String})">
             convert the structure to a string - if reverse is true the
             oids and values are listed out starting with the last element
             in the sequence (ala RFC 2253), otherwise the string will begin
             with the first element of the structure. If no string definition
             for the oid is found in oidSymbols the string value of the oid is
             added. Two standard symbol tables are provided DefaultSymbols, and
             RFC2253Symbols as part of this class.
            
             @param reverse if true start at the end of the sequence and work back.
             @param oidSymbols look up table strings for oids.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509NameEntryConverter">
                 * It turns out that the number of standard ways the fields in a DN should be
                 * encoded into their ASN.1 counterparts is rapidly approaching the
                 * number of machines on the internet. By default the X509Name class
                 * will produce UTF8Strings in line with the current recommendations (RFC 3280).
                 * <p>
                 * An example of an encoder look like below:
                 * <pre>
                 * public class X509DirEntryConverter
                 *     : X509NameEntryConverter
                 * {
                 *     public Asn1Object GetConvertedValue(
                 *         DerObjectIdentifier  oid,
                 *         string               value)
                 *     {
                 *         if (str.Length() != 0 &amp;&amp; str.charAt(0) == '#')
                 *         {
                 *             return ConvertHexEncoded(str, 1);
                 *         }
                 *         if (oid.Equals(EmailAddress))
                 *         {
                 *             return new DerIA5String(str);
                 *         }
                 *         else if (CanBePrintable(str))
                 *         {
                 *             return new DerPrintableString(str);
                 *         }
                 *         else if (CanBeUTF8(str))
                 *         {
                 *             return new DerUtf8String(str);
                 *         }
                 *         else
                 *         {
                 *             return new DerBmpString(str);
                 *         }
                 *     }
                 * }
            	 * </pre>
            	 * </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.ConvertHexEncoded(System.String,System.Int32)">
             Convert an inline encoded hex string rendition of an ASN.1
             object back into its corresponding ASN.1 object.
            
             @param str the hex encoded object
             @param off the index at which the encoding starts
             @return the decoded object
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.CanBePrintable(System.String)">
            return true if the passed in string can be represented without
            loss as a PrintableString, false otherwise.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.GetConvertedValue(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String)">
             Convert the passed in string value into the appropriate ASN.1
             encoded object.
            
             @param oid the oid associated with the value in the DN.
             @param value the value of the particular DN component.
             @return the ASN.1 equivalent for the value.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509NameTokenizer">
            class for breaking up an X500 Name into it's component tokens, ala
            java.util.StringTokenizer. We need this class as some of the
            lightweight Java environment don't support classes like
            StringTokenizer.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.ECNamedCurveTable">
            <summary>A unified elliptic curve registry of the various standard-specific registries.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetByName(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of
            the full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetByOid(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetByOidLazy(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of
            the full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetName(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetOid(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.Names">
            <summary>Enumerate the available curve names in all the registries.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.KeySpecificInfo">
            ASN.1 def for Diffie-Hellman key exchange KeySpecificInfo structure. See
            RFC 2631, or X9.42, for further details.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.KeySpecificInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             KeySpecificInfo ::= Sequence {
                 algorithm OBJECT IDENTIFIER,
                 counter OCTET STRING SIZE (4..4)
             }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.OtherInfo">
            ANS.1 def for Diffie-Hellman key exchange OtherInfo structure. See
            RFC 2631, or X9.42, for further details.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.OtherInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             OtherInfo ::= Sequence {
                 keyInfo KeySpecificInfo,
                 partyAInfo [0] OCTET STRING OPTIONAL,
                 suppPubInfo [2] OCTET STRING
             }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X962NamedCurves">
            <summary>Elliptic curve registry for the curves defined in X.962 EC-DSA.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetByName(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetByOid(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetByOidLazy(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetName(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetOid(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X962NamedCurves.Names">
            <summary>Enumerate the available curve names in this registry.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X962Parameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Parameters ::= CHOICE {
               ecParameters ECParameters,
               namedCurve   CURVES.&amp;id({CurveNames}),
               implicitlyCA Null
            }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9Curve">
            ASN.1 def for Elliptic-Curve Curve structure. See
            X9.62, for further details.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9Curve.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             Curve ::= Sequence {
                 a               FieldElement,
                 b               FieldElement,
                 seed            BIT STRING      OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters">
            ASN.1 def for Elliptic-Curve ECParameters structure. See
            X9.62, for further details.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters.CurveEntry">
             Return the ASN.1 entry representing the Curve.
            
             @return the X9Curve for the curve in these parameters.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters.FieldIDEntry">
             Return the ASN.1 entry representing the FieldID.
            
             @return the X9FieldID for the FieldID in these parameters.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters.BaseEntry">
             Return the ASN.1 entry representing the base point G.
            
             @return the X9ECPoint for the base point in these parameters.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECParameters ::= Sequence {
                 version         Integer { ecpVer1(1) } (ecpVer1),
                 fieldID         FieldID {{FieldTypes}},
                 curve           X9Curve,
                 base            X9ECPoint,
                 order           Integer,
                 cofactor        Integer OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECPoint">
            class for describing an ECPoint as a Der object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECPoint.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECPoint ::= OCTET STRING
            </pre>
            <p>
            Octet string produced using ECPoint.GetEncoded().</p>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9FieldElement">
            Class for processing an ECFieldElement as a DER object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9FieldElement.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             FieldElement ::= OCTET STRING
            </pre>
            <p>
            <ol>
            <li> if <i>q</i> is an odd prime then the field element is
            processed as an Integer and converted to an octet string
            according to x 9.62 4.3.1.</li>
            <li> if <i>q</i> is 2<sup>m</sup> then the bit string
            contained in the field element is converted into an octet
            string with the same ordering padded at the front if necessary.
            </li>
            </ol>
            </p>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9FieldID">
            ASN.1 def for Elliptic-Curve Field ID structure. See
            X9.62, for further details.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Constructor for elliptic curves over prime fields
            <code>F<sub>2</sub></code>.
            @param primeP The prime <code>p</code> defining the prime field.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>..
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9FieldID.ToAsn1Object">
            Produce a Der encoding of the following structure.
            <pre>
             FieldID ::= Sequence {
                 fieldType       FIELD-ID.&amp;id({IOSet}),
                 parameters      FIELD-ID.&amp;Type({IOSet}{&#64;fieldType})
             }
            </pre>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.IdDsaWithSha1">
            id-dsa-with-sha1 OBJECT IDENTIFIER ::=  { iso(1) member-body(2)
                  us(840) x9-57 (10040) x9cm(4) 3 }
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.X9x63Scheme">
            X9.63
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.ansi_x9_42">
            X9.42
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ArmoredInputStream">
             reader for Base64 armored objects - read the headers and then start returning
             bytes when the data is reached. An IOException is thrown if the CRC check
             is detected and fails.
             <p>
             By default a missing CRC will not cause an exception. To force CRC detection use:
             <pre>
                 ArmoredInputStream aIn = ...
            
                 aIn.setDetectMissingCRC(true);
             </pre>
             </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ArmoredInputStream.Decode(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[])">
             decode the base 64 encoded input data.
            
             @return the offset the data starts in out.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ArmoredInputStream.#ctor(System.IO.Stream)">
             Create a stream for reading a PGP armoured message, parsing up to a header
             and then reading the data that follows.
            
             @param input
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ArmoredInputStream.#ctor(System.IO.Stream,System.Boolean)">
             Create an armoured input stream which will assume the data starts
             straight away, or parse for headers first depending on the value of
             hasHeaders.
            
             @param input
             @param hasHeaders true if headers are to be looked for, false otherwise.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ArmoredInputStream.IsClearText">
            @return true if we are inside the clear text section of a PGP
            signed message.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ArmoredInputStream.IsEndOfStream">
            @return true if the stream is actually at end of file.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ArmoredInputStream.GetArmorHeaderLine">
            Return the armor header line (if there is one)
            @return the armor header line, null if none present.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ArmoredInputStream.GetArmorHeaders">
            Return the armor headers (the lines after the armor header line),
            @return an array of armor headers, null if there aren't any.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ArmoredInputStream.SetDetectMissingCrc(System.Boolean)">
             Change how the stream should react if it encounters missing CRC checksum.
             The default value is false (ignore missing CRC checksums). If the behavior is set to true,
             an {@link IOException} will be thrown if a missing CRC checksum is encountered.
            
             @param detectMissing ignore missing CRC sums
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ArmoredOutputStream">
            Basic output stream.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ArmoredOutputStream.Encode(System.IO.Stream,System.Int32[],System.Int32)">
            encode the input data producing a base 64 encoded byte array.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ArmoredOutputStream.SetHeader(System.String,System.String)">
            Set an additional header entry. Any current value(s) under the same name will be
            replaced by the new one. A null value will clear the entry for name.         *
            @param name the name of the header entry.
            @param v the value of the header entry.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ArmoredOutputStream.AddHeader(System.String,System.String)">
             Set an additional header entry. The current value(s) will continue to exist together
             with the new one. Adding a null value has no effect.
            
             @param name the name of the header entry.
             @param value the value of the header entry.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ArmoredOutputStream.ResetHeaders">
            Reset the headers to only contain a Version string (if one is present).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ArmoredOutputStream.BeginClearText(Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            Start a clear text signed message.
            @param hashAlgorithm
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ArmoredOutputStream.Dispose(System.Boolean)">
            <b>Note</b>: Close() does not close the underlying stream. So it is possible to write
            multiple objects using armoring to a single stream.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Attr.ImageAttrib">
            <remarks>Basic type for a image attribute packet.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgInputStream">
            <remarks>Reader for PGP objects.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgInputStream.NextPacketTag">
            <summary>Returns the next packet tag in the stream.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgInputStream.PartialInputStream">
            <summary>
            A stream that overlays our input stream, allowing the user to only read a segment of it.
            NB: dataLength will be negative if the segment length is in the upper range above 2**31.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgObject">
            <remarks>Base class for a PGP object.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgOutputStream">
            <remarks>Basic output stream.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream)">
            <summary>Create a stream representing a general packet.</summary>
            <param name="outStr">Output stream to write to.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream,Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.PacketTag)">
            <summary>Create a stream representing an old style partial object.</summary>
            <param name="outStr">Output stream to write to.</param>
            <param name="tag">The packet tag for the object.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream,Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.PacketTag,System.Int64,System.Boolean)">
            <summary>Create a stream representing a general packet.</summary>
            <param name="outStr">Output stream to write to.</param>
            <param name="tag">Packet tag.</param>
            <param name="length">Size of chunks making up the packet.</param>
            <param name="oldFormat">If true, the header is written out in old format.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream,Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.PacketTag,System.Int64)">
            <summary>Create a new style partial input stream buffered into chunks.</summary>
            <param name="outStr">Output stream to write to.</param>
            <param name="tag">Packet tag.</param>
            <param name="length">Size of chunks making up the packet.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream,Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.PacketTag,System.Byte[])">
            <summary>Create a new style partial input stream buffered into chunks.</summary>
            <param name="outStr">Output stream to write to.</param>
            <param name="tag">Packet tag.</param>
            <param name="buffer">Buffer to use for collecting chunks.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgOutputStream.Flush">
            <summary>Flush the underlying stream.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgOutputStream.Finish">
            <summary>Finish writing out the current packet without closing the underlying stream.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.CompressedDataPacket">
            <remarks>Generic compressed data object.</remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.CompressedDataPacket.Algorithm">
            <summary>The algorithm tag value.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.CompressionAlgorithmTag">
            <remarks>Basic tags for compression algorithms.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ContainedPacket">
            <remarks>Basic type for a PGP packet.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.DsaPublicBcpgKey">
            <remarks>Base class for a DSA public key.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.DsaPublicBcpgKey.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <param name="bcpgIn">The stream to read the packet from.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.DsaPublicBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.DsaPublicBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.DsaSecretBcpgKey">
            <remarks>Base class for a DSA secret key.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.DsaSecretBcpgKey.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgInputStream)">
            @param in
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.DsaSecretBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.DsaSecretBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.DsaSecretBcpgKey.X">
            @return x
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ECDHPublicBcpgKey">
            <remarks>Base class for an ECDH Public Key.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ECDHPublicBcpgKey.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <param name="bcpgIn">The stream to read the packet from.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ECDsaPublicBcpgKey">
            <remarks>Base class for an ECDSA Public Key.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ECDsaPublicBcpgKey.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <param name="bcpgIn">The stream to read the packet from.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ECPublicBcpgKey">
            <remarks>Base class for an EC Public Key.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ECPublicBcpgKey.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <param name="bcpgIn">The stream to read the packet from.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ECPublicBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ECPublicBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ECSecretBcpgKey">
            <remarks>Base class for an EC Secret Key.</remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ECSecretBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ECSecretBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ElGamalPublicBcpgKey">
            <remarks>Base class for an ElGamal public key.</remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ElGamalPublicBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ElGamalPublicBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey">
            <remarks>Base class for an ElGamal secret key.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgInputStream)">
            @param in
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            @param x
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ExperimentalPacket">
            <remarks>Basic packet for an experimental packet.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.HashAlgorithmTag">
            <remarks>Basic tags for hash algorithms.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.IBcpgKey">
            <remarks>Base interface for a PGP key.</remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.IBcpgKey.Format">
            <summary>
            The base format for this key - in the case of the symmetric keys it will generally
            be raw indicating that the key is just a straight byte representation, for an asymmetric
            key the format will be PGP, indicating the key is a string of MPIs encoded in PGP format.
            </summary>
            <returns>"RAW" or "PGP".</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.InputStreamPacket.GetInputStream">
            <summary>Note: you can only read from this once...</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.LiteralDataPacket">
            <remarks>Generic literal data packet.</remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.LiteralDataPacket.Format">
            <summary>The format tag value.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.LiteralDataPacket.ModificationTime">
            <summary>The modification time of the file in milli-seconds (since Jan 1, 1970 UTC)</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.MarkerPacket">
            <remarks>Basic type for a marker packet.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.ModDetectionCodePacket">
            <remarks>Basic packet for a modification detection code packet.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.MPInteger">
            <remarks>A multiple precision integer</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.OnePassSignaturePacket">
            <remarks>Generic signature object</remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.OnePassSignaturePacket.KeyAlgorithm">
            <summary>The encryption algorithm tag.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.OnePassSignaturePacket.HashAlgorithm">
            <summary>The hash algorithm tag.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.PacketTag">
            <remarks>Basic PGP packet tag types.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag">
            <remarks>Public Key Algorithm tag numbers.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.PublicKeyEncSessionPacket">
            <remarks>Basic packet for a PGP public key.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.PublicKeyPacket">
            <remarks>Basic packet for a PGP public key.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.PublicKeyPacket.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,System.DateTime,Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.IBcpgKey)">
            <summary>Construct a version 4 public key packet.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.PublicSubkeyPacket">
            <remarks>Basic packet for a PGP public subkey</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.PublicSubkeyPacket.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,System.DateTime,Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.IBcpgKey)">
            <summary>Construct a version 4 public subkey packet.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.RsaPublicBcpgKey">
            <remarks>Base class for an RSA public key.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.RsaPublicBcpgKey.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <summary>Construct an RSA public key from the passed in stream.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.RsaPublicBcpgKey.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <param name="n">The modulus.</param>
            <param name="e">The public exponent.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.RsaPublicBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.RsaPublicBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.RsaSecretBcpgKey">
            <remarks>Base class for an RSA secret (or priate) key.</remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.RsaSecretBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.RsaSecretBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.S2k">
            <remarks>The string to key specifier class.</remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.S2k.HashAlgorithm">
            <summary>The hash algorithm.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.S2k.GetIV">
            <summary>The IV for the key generation algorithm.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.S2k.IterationCount">
            <summary>The iteration count</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.S2k.ProtectionMode">
            <summary>The protection mode - only if GnuDummyS2K</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SecretKeyPacket">
            <remarks>Basic packet for a PGP secret key.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SecretSubkeyPacket">
            <remarks>Basic packet for a PGP secret key.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.EmbeddedSignature">
            Packet embedded signature
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.Exportable">
            packet giving signature creation time.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.Features">
            packet giving signature expiration time.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.Features.FEATURE_MODIFICATION_DETECTION">
            Identifier for the Modification Detection (packets 18 and 19) 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.Features.FEATURE_AEAD_ENCRYPTED_DATA">
            Identifier for the AEAD Encrypted Data Packet (packet 20) and version 5
                     Symmetric-Key Encrypted Session Key Packets (packet 3) 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.Features.FEATURE_VERSION_5_PUBLIC_KEY">
            Identifier for the Version 5 Public-Key Packet format and corresponding new
                       fingerprint format 
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.Features.SupportsModificationDetection">
            Returns if modification detection is supported.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.Features.SupportsFeature(System.Byte)">
            Returns if a particular feature is supported.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.IssuerKeyId">
            packet giving signature creation time.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.KeyExpirationTime">
            packet giving time after creation at which the key expires.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.KeyExpirationTime.Time">
             Return the number of seconds after creation time a key is valid for.
            
             @return second count for key validity.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.KeyFlags">
            Packet holding the key flag values.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.KeyFlags.Flags">
            <summary>
            Return the flag values contained in the first 4 octets (note: at the moment
            the standard only uses the first one).
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.NotationData">
            Class provided a NotationData object according to
            RFC2440, Chapter 5.2.3.15. Notation Data
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.PreferredAlgorithms">
            packet giving signature creation time.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.PrimaryUserId">
            packet giving whether or not the signature is signed using the primary user ID for the key.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.Revocable">
            packet giving whether or not is revocable.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.SignatureCreationTime">
            packet giving signature creation time.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.SignatureExpirationTime">
            packet giving signature expiration time.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.SignatureExpirationTime.Time">
            return time in seconds before signature expires after creation time.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.SignerUserId">
            packet giving the User ID of the signer.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.Sig.TrustSignature">
            packet giving trust.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.RevocationKey">
            <summary>
            Represents revocation key OpenPGP signature sub packet.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.RevocationReason">
            <summary>
            Represents revocation reason OpenPGP signature sub packet.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SignaturePacket">
            <remarks>Generic signature packet.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SignaturePacket.#ctor(System.Int32,System.Int64,Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.HashAlgorithmTag,Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SignatureSubpacket[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SignatureSubpacket[],System.Byte[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.MPInteger[])">
             Generate a version 4 signature packet.
            
             @param signatureType
             @param keyAlgorithm
             @param hashAlgorithm
             @param hashedData
             @param unhashedData
             @param fingerprint
             @param signature
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SignaturePacket.#ctor(System.Int32,System.Int32,System.Int64,Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.HashAlgorithmTag,System.Int64,System.Byte[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.MPInteger[])">
             Generate a version 2/3 signature packet.
            
             @param signatureType
             @param keyAlgorithm
             @param hashAlgorithm
             @param fingerprint
             @param signature
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SignaturePacket.KeyId">
            return the keyId
            @return the keyId that created the signature.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SignaturePacket.GetSignatureTrailer">
             return the signature trailer that must be included with the data
             to reconstruct the signature
            
             @return byte[]
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SignaturePacket.GetSignature">
            		* return the signature as a set of integers - note this is normalised to be the
                    * ASN.1 encoding of what appears in the signature packet.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SignaturePacket.GetSignatureBytes">
            Return the byte encoding of the signature section.
            @return uninterpreted signature bytes.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SignaturePacket.CreationTime">
            <summary>Return the creation time in milliseconds since 1 Jan., 1970 UTC.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SignatureSubpacket">
            <remarks>Basic type for a PGP Signature sub-packet.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SignatureSubpacket.GetData">
            <summary>Return the generic data making up the packet.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SignatureSubpacketsParser">
            reader for signature sub-packets
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SignatureSubpacketTag">
            Basic PGP signature sub-packet tag types.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SymmetricEncDataPacket">
            <remarks>Basic type for a symmetric key encrypted packet.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag">
            Basic tags for symmetric key algorithms
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket">
            Basic type for a symmetric encrypted session key packet
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket.EncAlgorithm">
            @return int
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket.S2k">
            @return S2k
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket.GetSecKeyData">
            @return byte[]
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket.Version">
            @return int
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.TrustPacket">
            <summary>Basic type for a trust packet.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.UserAttributePacket">
            Basic type for a user attribute packet.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.UserAttributeSubpacket">
            Basic type for a user attribute sub-packet.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.UserAttributeSubpacket.GetData">
            return the generic data making up the packet.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.UserAttributeSubpacketsParser">
            reader for user attribute sub-packets
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.UserAttributeSubpacketTag">
            Basic PGP user attribute sub-packet tag types.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Bcpg.UserIdPacket">
            Basic type for a user ID packet.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cmp.GeneralPkiMessage.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiMessage)">
            <summary>
            Wrap a PKIMessage ASN.1 structure.
            </summary>
            <param name="pkiMessage">PKI message.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cmp.GeneralPkiMessage.#ctor(System.Byte[])">
            <summary>
            Create a PKIMessage from the passed in bytes.
            </summary>
            <param name="encoding">BER/DER encoding of the PKIMessage</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cmp.GeneralPkiMessage.HasProtection">
            <summary>
            Return true if this message has protection bits on it. A return value of true
            indicates the message can be used to construct a ProtectedPKIMessage.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cmp.ProtectedPkiMessage">
            <summary>
            Wrapper for a PKIMessage with protection attached to it.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cmp.ProtectedPkiMessage.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cmp.GeneralPkiMessage)">
            <summary>
            Wrap a general message.
            </summary>
            <exception cref="T:System.ArgumentException">If the general message does not have protection.</exception>
            <param name="pkiMessage">The General message</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cmp.ProtectedPkiMessage.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiMessage)">
            <summary>
            Wrap a PKI message.
            </summary>
            <exception cref="T:System.ArgumentException">If the PKI message does not have protection.</exception>
            <param name="pkiMessage">The PKI message</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cmp.ProtectedPkiMessage.Header">
            <summary>Message header</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cmp.ProtectedPkiMessage.Body">
            <summary>Message body</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cmp.ProtectedPkiMessage.ToAsn1Message">
            <summary>
            Return the underlying ASN.1 structure contained in this object.
            </summary>
            <returns>PkiMessage structure</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cmp.ProtectedPkiMessage.HasPasswordBasedMacProtected">
            <summary>
            Determine whether the message is protected by a password based MAC. Use verify(PKMACBuilder, char[])
            to verify the message if this method returns true.
            </summary>
            <returns>true if protection MAC PBE based, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cmp.ProtectedPkiMessage.GetCertificates">
            <summary>
            Return the extra certificates associated with this message.
            </summary>
            <returns>an array of extra certificates, zero length if none present.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cmp.ProtectedPkiMessage.Verify(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IVerifierFactory)">
            <summary>
            Verify a message with a public key based signature attached.
            </summary>
            <param name="verifierFactory">a factory of signature verifiers.</param>
            <returns>true if the provider is able to create a verifier that validates the signature, false otherwise.</returns>      
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cmp.ProtectedPkiMessage.Verify(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PKMacBuilder,System.Char[])">
            <summary>
            Verify a message with password based MAC protection.
            </summary>
            <param name="pkMacBuilder">MAC builder that can be used to construct the appropriate MacCalculator</param>
            <param name="password">the MAC password</param>
            <returns>true if the passed in password and MAC builder verify the message, false otherwise.</returns>
            <exception cref="T:System.InvalidOperationException">if algorithm not MAC based, or an exception is thrown verifying the MAC.</exception>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAttributeTableParameter">
            <remarks>
            The 'Signature' parameter is only available when generating unsigned attributes.
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedData">
            containing class for an CMS Authenticated Data object
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedData.MacAlgOid">
            return the object identifier for the content MAC algorithm.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedData.GetRecipientInfos">
            return a store of the intended recipients for this message
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedData.ContentInfo">
            return the ContentInfo 
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedData.GetAuthAttrs">
            return a table of the digested attributes indexed by
            the OID of the attribute.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedData.GetUnauthAttrs">
            return a table of the undigested attributes indexed by
            the OID of the attribute.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedData.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator">
             General class for generating a CMS authenticated-data message.
            
             A simple example of usage.
            
             <pre>
                  CMSAuthenticatedDataGenerator  fact = new CMSAuthenticatedDataGenerator();
            
                  fact.addKeyTransRecipient(cert);
            
                  CMSAuthenticatedData         data = fact.generate(content, algorithm, "BC");
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="random">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator.Generate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsProcessable,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.CipherKeyGenerator)">
            generate an enveloped object that contains an CMS Enveloped Data
            object using the given provider and the passed in key generator.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator.Generate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsProcessable,System.String)">
            generate an authenticated object that contains an CMS Authenticated Data object
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataParser">
             Parsing class for an CMS Authenticated Data object from an input stream.
             <p>
             Note: that because we are in a streaming mode only one recipient can be tried and it is important
             that the methods on the parser are called in the appropriate order.
             </p>
             <p>
             Example of use - assuming the first recipient matches the private key we have.
             <pre>
                  CMSAuthenticatedDataParser     ad = new CMSAuthenticatedDataParser(inputStream);
            
                  RecipientInformationStore  recipients = ad.getRecipientInfos();
            
                  Collection  c = recipients.getRecipients();
                  Iterator    it = c.iterator();
            
                  if (it.hasNext())
                  {
                      RecipientInformation   recipient = (RecipientInformation)it.next();
            
                      CMSTypedStream recData = recipient.getContentStream(privateKey, "BC");
            
                      processDataStream(recData.getContentStream());
            
                      if (!Arrays.equals(ad.getMac(), recipient.getMac())
                      {
                          System.err.println("Data corrupted!!!!");
                      }
                  }
              </pre>
              Note: this class does not introduce buffering - if you are processing large files you should create
              the parser with:
              <pre>
                      CMSAuthenticatedDataParser     ep = new CMSAuthenticatedDataParser(new BufferedInputStream(inputStream, bufSize));
              </pre>
              where bufSize is a suitably large buffer size.
             </p>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataParser.MacAlgOid">
            return the object identifier for the mac algorithm.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataParser.MacAlgParams">
            return the ASN.1 encoded encryption algorithm parameters, or null if
            there aren't any.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataParser.GetRecipientInfos">
            return a store of the intended recipients for this message
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataParser.GetAuthAttrs">
            return a table of the unauthenticated attributes indexed by
            the OID of the attribute.
            @exception java.io.IOException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataParser.GetUnauthAttrs">
            return a table of the unauthenticated attributes indexed by
            the OID of the attribute.
            @exception java.io.IOException
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator">
             General class for generating a CMS authenticated-data message stream.
             <p>
             A simple example of usage.
             <pre>
                  CMSAuthenticatedDataStreamGenerator edGen = new CMSAuthenticatedDataStreamGenerator();
            
                  edGen.addKeyTransRecipient(cert);
            
                  ByteArrayOutputStream  bOut = new ByteArrayOutputStream();
            
                  OutputStream out = edGen.open(
                                          bOut, CMSAuthenticatedDataGenerator.AES128_CBC, "BC");*
                  out.write(data);
            
                  out.close();
             </pre>
             </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="random">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.SetBufferSize(System.Int32)">
             Set the underlying string size for encapsulated data
            
             @param bufferSize length of octet strings to buffer the data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.SetBerEncodeRecipients(System.Boolean)">
            Use a BER Set to store the recipient information
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.Open(System.IO.Stream,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.CipherKeyGenerator)">
            generate an enveloped object that contains an CMS Enveloped Data
            object using the given provider and the passed in key generator.
            @throws java.io.IOException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.Open(System.IO.Stream,System.String)">
            generate an enveloped object that contains an CMS Enveloped Data object
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.Open(System.IO.Stream,System.String,System.Int32)">
            generate an enveloped object that contains an CMS Enveloped Data object
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthenticatedGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="random">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAuthEnvelopedData">
            containing class for an CMS AuthEnveloped Data object
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsCompressedData">
            containing class for an CMS Compressed Data object
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsCompressedData.GetContent">
             Return the uncompressed content.
            
             @return the uncompressed content
             @throws CmsException if there is an exception uncompressing the data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsCompressedData.GetContent(System.Int32)">
             Return the uncompressed content, throwing an exception if the data size
             is greater than the passed in limit. If the content is exceeded getCause()
             on the CMSException will contain a StreamOverflowException
            
             @param limit maximum number of bytes to read
             @return the content read
             @throws CMSException if there is an exception uncompressing the data.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsCompressedData.ContentInfo">
            return the ContentInfo 
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsCompressedData.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsCompressedDataGenerator">
                * General class for generating a compressed CMS message.
                * <p>
                * A simple example of usage.</p>
                * <p>
                * <pre>
                *      CMSCompressedDataGenerator fact = new CMSCompressedDataGenerator();
                *      CMSCompressedData data = fact.Generate(content, algorithm);
                * </pre>
            	* </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsCompressedDataGenerator.Generate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsProcessable,System.String)">
            Generate an object that contains an CMS Compressed Data
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsCompressedDataParser">
             Class for reading a CMS Compressed Data stream.
             <pre>
                 CMSCompressedDataParser cp = new CMSCompressedDataParser(inputStream);
            
                 process(cp.GetContent().GetContentStream());
             </pre>
              Note: this class does not introduce buffering - if you are processing large files you should create
              the parser with:
              <pre>
                  CMSCompressedDataParser     ep = new CMSCompressedDataParser(new BufferedInputStream(inputStream, bufSize));
              </pre>
              where bufSize is a suitably large buffer size.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsCompressedDataStreamGenerator">
             General class for generating a compressed CMS message stream.
             <p>
             A simple example of usage.
             </p>
             <pre>
                  CMSCompressedDataStreamGenerator gen = new CMSCompressedDataStreamGenerator();
            
                  Stream cOut = gen.Open(outputStream, CMSCompressedDataStreamGenerator.ZLIB);
            
                  cOut.Write(data);
            
                  cOut.Close();
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsCompressedDataStreamGenerator.#ctor">
            base constructor
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsCompressedDataStreamGenerator.SetBufferSize(System.Int32)">
             Set the underlying string size for encapsulated data
            
             @param bufferSize length of octet strings to buffer the data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsContentInfoParser.Close">
            Close the underlying data stream.
            @throws IOException if the close fails.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedData">
            containing class for an CMS Enveloped Data object
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedData.EncryptionAlgOid">
            return the object identifier for the content encryption algorithm.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedData.GetRecipientInfos">
            return a store of the intended recipients for this message
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedData.ContentInfo">
            return the ContentInfo 
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedData.GetUnprotectedAttributes">
            return a table of the unprotected attributes indexed by
            the OID of the attribute.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedData.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator">
             <remarks>
             General class for generating a CMS enveloped-data message.
            
             A simple example of usage.
            
             <pre>
                  CmsEnvelopedDataGenerator  fact = new CmsEnvelopedDataGenerator();
            
                  fact.AddKeyTransRecipient(cert);
            
                  CmsEnvelopedData         data = fact.Generate(content, algorithm);
             </pre>
             </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="random">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator.Generate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsProcessable,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.CipherKeyGenerator)">
            <summary>
            Generate an enveloped object that contains a CMS Enveloped Data
            object using the passed in key generator.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator.Generate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsProcessable,System.String)">
            <summary>Generate an enveloped object that contains an CMS Enveloped Data object.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator.Generate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsProcessable,System.String,System.Int32)">
            <summary>Generate an enveloped object that contains an CMS Enveloped Data object.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataParser">
             Parsing class for an CMS Enveloped Data object from an input stream.
             <p>
             Note: that because we are in a streaming mode only one recipient can be tried and it is important
             that the methods on the parser are called in the appropriate order.
             </p>
             <p>
             Example of use - assuming the first recipient matches the private key we have.
             <pre>
                  CmsEnvelopedDataParser     ep = new CmsEnvelopedDataParser(inputStream);
            
                  RecipientInformationStore  recipients = ep.GetRecipientInfos();
            
                  Collection  c = recipients.getRecipients();
                  Iterator    it = c.iterator();
            
                  if (it.hasNext())
                  {
                      RecipientInformation   recipient = (RecipientInformation)it.next();
            
                      CMSTypedStream recData = recipient.getContentStream(privateKey);
            
                      processDataStream(recData.getContentStream());
                  }
              </pre>
              Note: this class does not introduce buffering - if you are processing large files you should create
              the parser with:
              <pre>
                      CmsEnvelopedDataParser     ep = new CmsEnvelopedDataParser(new BufferedInputStream(inputStream, bufSize));
              </pre>
              where bufSize is a suitably large buffer size.
             </p>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataParser.EncryptionAlgOid">
            return the object identifier for the content encryption algorithm.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataParser.EncryptionAlgParams">
            return the ASN.1 encoded encryption algorithm parameters, or null if
            there aren't any.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataParser.GetRecipientInfos">
            return a store of the intended recipients for this message
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataParser.GetUnprotectedAttributes">
            return a table of the unprotected attributes indexed by
            the OID of the attribute.
            @throws IOException
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator">
             General class for generating a CMS enveloped-data message stream.
             <p>
             A simple example of usage.
             <pre>
                  CmsEnvelopedDataStreamGenerator edGen = new CmsEnvelopedDataStreamGenerator();
            
                  edGen.AddKeyTransRecipient(cert);
            
                  MemoryStream  bOut = new MemoryStream();
            
                  Stream out = edGen.Open(
                                          bOut, CMSEnvelopedDataGenerator.AES128_CBC);*
                  out.Write(data);
            
                  out.Close();
             </pre>
             </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="random">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.SetBufferSize(System.Int32)">
            <summary>Set the underlying string size for encapsulated data.</summary>
            <param name="bufferSize">Length of octet strings to buffer the data.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.SetBerEncodeRecipients(System.Boolean)">
            <summary>Use a BER Set to store the recipient information.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.Open(System.IO.Stream,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.CipherKeyGenerator)">
            <summary>
            Generate an enveloped object that contains an CMS Enveloped Data
            object using the passed in key generator.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.Open(System.IO.Stream,System.String)">
            generate an enveloped object that contains an CMS Enveloped Data object
            @throws IOException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.Open(System.IO.Stream,System.String,System.Int32)">
            generate an enveloped object that contains an CMS Enveloped Data object
            @throws IOException
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedGenerator">
             General class for generating a CMS enveloped-data message.
            
             A simple example of usage.
            
             <pre>
                  CMSEnvelopedDataGenerator  fact = new CMSEnvelopedDataGenerator();
            
                  fact.addKeyTransRecipient(cert);
            
                  CMSEnvelopedData         data = fact.generate(content, algorithm, "BC");
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="random">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKeyTransRecipient(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate)">
             add a recipient.
            
             @param cert recipient's public key certificate
             @exception ArgumentException if there is a problem with the certificate
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKeyTransRecipient(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[])">
             add a recipient
            
             @param key the public key used by the recipient
             @param subKeyId the identifier for the recipient's public key
             @exception ArgumentException if there is a problem with the key
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKekRecipient(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Byte[])">
            add a KEK recipient.
            @param key the secret key to use for wrapping
            @param keyIdentifier the byte string that identifies the key
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKekRecipient(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.KeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.KekIdentifier)">
            add a KEK recipient.
            @param key the secret key to use for wrapping
            @param keyIdentifier the byte string that identifies the key
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKeyAgreementRecipient(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.String)">
             Add a key agreement based recipient.
            
             @param agreementAlgorithm key agreement algorithm to use.
             @param senderPrivateKey private key to initialise sender side of agreement with.
             @param senderPublicKey sender public key to include with message.
             @param recipientCert recipient's public key certificate.
             @param cekWrapAlgorithm OID for key wrapping algorithm to use.
             @exception SecurityUtilityException if the algorithm requested cannot be found
             @exception InvalidKeyException if the keys are inappropriate for the algorithm specified
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKeyAgreementRecipients(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Collections.Generic.IEnumerable{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate},System.String)">
             Add multiple key agreement based recipients (sharing a single KeyAgreeRecipientInfo structure).
            
             @param agreementAlgorithm key agreement algorithm to use.
             @param senderPrivateKey private key to initialise sender side of agreement with.
             @param senderPublicKey sender public key to include with message.
             @param recipientCerts recipients' public key certificates.
             @param cekWrapAlgorithm OID for key wrapping algorithm to use.
             @exception SecurityUtilityException if the algorithm requested cannot be found
             @exception InvalidKeyException if the keys are inappropriate for the algorithm specified
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddRecipientInfoGenerator(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.RecipientInfoGenerator)">
            <summary>
            Add a generator to produce the recipient info required.
            </summary>
            <param name="recipientInfoGenerator">a generator of a recipient info object.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsProcessable.Write(System.IO.Stream)">
            <summary>
            Generic routine to copy out the data we want processed.
            </summary>
            <remarks>
            This routine may be called multiple times.
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsProcessableByteArray">
            a holding class for a byte array of data to be processed.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsProcessableFile">
            a holding class for a file of data to be processed.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData">
             general class for handling a pkcs7-signature message.
            
             A simple example of usage - note, in the example below the validity of
             the certificate isn't verified, just the fact that one of the certs
             matches the given signer...
            
             <pre>
              IX509Store              certs = s.GetCertificates();
              SignerInformationStore  signers = s.GetSignerInfos();
            
              foreach (SignerInformation signer in signers.GetSigners())
              {
                  ArrayList       certList = new ArrayList(certs.GetMatches(signer.SignerID));
                  X509Certificate cert = (X509Certificate) certList[0];
            
                  if (signer.Verify(cert.GetPublicKey()))
                  {
                      verified++;
                  }
              }
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData.#ctor(System.Collections.Generic.IDictionary{System.String,System.Byte[]},System.Byte[])">
             Content with detached signature, digests precomputed
            
             @param hashes a map of precomputed digests for content indexed by name of hash.
             @param sigBlock the signature object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsProcessable,System.IO.Stream)">
             base constructor - content with detached signature.
            
             @param signedContent the content that was signed.
             @param sigData the signature object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData.#ctor(System.IO.Stream)">
            base constructor - with encapsulated content
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData.Version">
            <summary>Return the version number for this object.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData.GetSignerInfos">
            return the collection of signers that are associated with the
            signatures for the message.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData.GetAttributeCertificates">
             return a X509Store containing the attribute certificates, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of attribute certificates
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData.GetCertificates">
             return a X509Store containing the public key certificates, if any, contained in this message.
            
             @return a store of public key certificates
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData.GetCrls">
             return a X509Store containing CRLs, if any, contained in this message.
            
             @return a store of CRLs
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData.SignedContentType">
            <summary>
            Return the <c>DerObjectIdentifier</c> associated with the encapsulated
            content info structure carried in the signed data.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData.ContentInfo">
            return the ContentInfo
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData.GetEncoded(System.String)">
             return the ASN.1 encoded representation of this object using the specified encoding.
            
             @param encoding the ASN.1 encoding format to use ("BER" or "DER").
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData.ReplaceSigners(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData,Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformationStore)">
             Replace the signerinformation store associated with this
             CmsSignedData object with the new one passed in. You would
             probably only want to do this if you wanted to change the unsigned
             attributes associated with a signer, or perhaps delete one.
            
             @param signedData the signed data object to be used as a base.
             @param signerInformationStore the new signer information store to use.
             @return a new signed data object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData.ReplaceCertificatesAndCrls(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedData,Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Collections.IStore{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate},Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Collections.IStore{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl})">
             Replace the certificate and CRL information associated with this
             CmsSignedData object with the new one passed in.
            
             @param signedData the signed data object to be used as a base.
             @param x509Certs the new certificates to be used.
             @param x509Crls the new CRLs to be used.
             @return a new signed data object.
             @exception CmsException if there is an error processing the stores
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator">
                 * general class for generating a pkcs7-signature message.
                 * <p>
                 * A simple example of usage.
                 *
                 * <pre>
                 *      IX509Store certs...
                 *      IX509Store crls...
                 *      CmsSignedDataGenerator gen = new CmsSignedDataGenerator();
                 *
                 *      gen.AddSigner(privKey, cert, CmsSignedGenerator.DigestSha1);
                 *      gen.AddCertificates(certs);
                 *      gen.AddCrls(crls);
                 *
                 *      CmsSignedData data = gen.Generate(content);
                 * </pre>
            	 * </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="random">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.String)">
                    * add a signer - no attributes other than the default ones will be
                    * provided here.
            		*
            		* @param key signing key to use
            		* @param cert certificate containing corresponding public key
            		* @param digestOID digest algorithm OID
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.String,System.String)">
             add a signer, specifying the digest encryption algorithm to use - no attributes other than the default ones will be
             provided here.
            
             @param key signing key to use
             @param cert certificate containing corresponding public key
             @param encryptionOID digest encryption algorithm OID
             @param digestOID digest algorithm OID
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String)">
            add a signer - no attributes other than the default ones will be
            provided here.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,System.String)">
            add a signer, specifying the digest encryption algorithm to use - no attributes other than the default ones will be
            provided here.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable)">
                    * add a signer with extra signed/unsigned attributes.
            		*
            		* @param key signing key to use
            		* @param cert certificate containing corresponding public key
            		* @param digestOID digest algorithm OID
            		* @param signedAttr table of attributes to be included in signature
            		* @param unsignedAttr table of attributes to be included as unsigned
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.String,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             add a signer, specifying the digest encryption algorithm, with extra signed/unsigned attributes.
            
             @param key signing key to use
             @param cert certificate containing corresponding public key
             @param encryptionOID digest encryption algorithm OID
             @param digestOID digest algorithm OID
             @param signedAttr table of attributes to be included in signature
             @param unsignedAttr table of attributes to be included as unsigned
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable)">
            	     * add a signer with extra signed/unsigned attributes.
            		 *
            		 * @param key signing key to use
            		 * @param subjectKeyID subjectKeyID of corresponding public key
            		 * @param digestOID digest algorithm OID
            		 * @param signedAttr table of attributes to be included in signature
            		 * @param unsignedAttr table of attributes to be included as unsigned
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             add a signer, specifying the digest encryption algorithm, with extra signed/unsigned attributes.
            
             @param key signing key to use
             @param subjectKeyID subjectKeyID of corresponding public key
             @param encryptionOID digest encryption algorithm OID
             @param digestOID digest algorithm OID
             @param signedAttr table of attributes to be included in signature
             @param unsignedAttr table of attributes to be included as unsigned
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAttributeTableGenerator,Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAttributeTableGenerator)">
            add a signer with extra signed/unsigned attributes based on generators.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.String,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAttributeTableGenerator,Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAttributeTableGenerator)">
            add a signer, specifying the digest encryption algorithm, with extra signed/unsigned attributes based on generators.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAttributeTableGenerator,Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAttributeTableGenerator)">
            add a signer with extra signed/unsigned attributes based on generators.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAttributeTableGenerator,Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAttributeTableGenerator)">
            add a signer, including digest encryption algorithm, with extra signed/unsigned attributes based on generators.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.Generate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsProcessable)">
            generate a signed object that for a CMS Signed Data object
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.Generate(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsProcessable,System.Boolean)">
            generate a signed object that for a CMS Signed Data
            object  - if encapsulate is true a copy
            of the message will be included in the signature. The content type
            is set according to the OID represented by the string signedContentType.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.Generate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsProcessable,System.Boolean)">
            generate a signed object that for a CMS Signed Data
            object - if encapsulate is true a copy
            of the message will be included in the signature with the
            default content type "data".
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataGenerator.GenerateCounterSigners(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation)">
             generate a set of one or more SignerInformation objects representing counter signatures on
             the passed in SignerInformation object.
            
             @param signer the signer to be countersigned
             @param sigProvider the provider to be used for counter signing.
             @return a store containing the signers.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataParser">
             Parsing class for an CMS Signed Data object from an input stream.
             <p>
             Note: that because we are in a streaming mode only one signer can be tried and it is important
             that the methods on the parser are called in the appropriate order.
             </p>
             <p>
             A simple example of usage for an encapsulated signature.
             </p>
             <p>
             Two notes: first, in the example below the validity of
             the certificate isn't verified, just the fact that one of the certs
             matches the given signer, and, second, because we are in a streaming
             mode the order of the operations is important.
             </p>
             <pre>
                  CmsSignedDataParser     sp = new CmsSignedDataParser(encapSigData);
            
                  sp.GetSignedContent().Drain();
            
                  IX509Store              certs = sp.GetCertificates();
                  SignerInformationStore  signers = sp.GetSignerInfos();
            
                  foreach (SignerInformation signer in signers.GetSigners())
                  {
                      ArrayList       certList = new ArrayList(certs.GetMatches(signer.SignerID));
                      X509Certificate cert = (X509Certificate) certList[0];
            
                      Console.WriteLine("verify returns: " + signer.Verify(cert));
                  }
             </pre>
              Note also: this class does not introduce buffering - if you are processing large files you should create
              the parser with:
              <pre>
                      CmsSignedDataParser     ep = new CmsSignedDataParser(new BufferedInputStream(encapSigData, bufSize));
              </pre>
              where bufSize is a suitably large buffer size.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataParser.#ctor(System.IO.Stream)">
            base constructor - with encapsulated content
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataParser.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsTypedStream,System.IO.Stream)">
             base constructor
            
             @param signedContent the content that was signed.
             @param sigData the signature object.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataParser.Version">
             Return the version number for the SignedData object
            
             @return the version number
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataParser.GetSignerInfos">
            return the collection of signers that are associated with the
            signatures for the message.
            @throws CmsException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataParser.GetAttributeCertificates">
             return a X509Store containing the attribute certificates, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of attribute certificates
             @exception org.bouncycastle.x509.NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataParser.GetCertificates">
             return a X509Store containing the public key certificates, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of public key certificates
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataParser.GetCrls">
             return a X509Store containing CRLs, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of CRLs
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataParser.SignedContentType">
            <summary>
            Return the <c>DerObjectIdentifier</c> associated with the encapsulated
            content info structure carried in the signed data.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataParser.ReplaceSigners(System.IO.Stream,Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformationStore,System.IO.Stream)">
            Replace the signerinformation store associated with the passed
            in message contained in the stream original with the new one passed in.
            You would probably only want to do this if you wanted to change the unsigned
            attributes associated with a signer, or perhaps delete one.
            <p>
            The output stream is returned unclosed.
            </p>
            @param original the signed data stream to be used as a base.
            @param signerInformationStore the new signer information store to use.
            @param out the stream to Write the new signed data object to.
            @return out.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataParser.ReplaceCertificatesAndCrls(System.IO.Stream,Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Collections.IStore{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate},Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Collections.IStore{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl},Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Collections.IStore{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificate},System.IO.Stream)">
            Replace the certificate and CRL information associated with this
            CMSSignedData object with the new one passed in.
            <p>
            The output stream is returned unclosed.
            </p>
            @param original the signed data stream to be used as a base.
            @param certsAndCrls the new certificates and CRLs to be used.
            @param out the stream to Write the new signed data object to.
            @return out.
            @exception CmsException if there is an error processing the CertStore
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator">
             General class for generating a pkcs7-signature message stream.
             <p>
             A simple example of usage.
             </p>
             <pre>
                  IX509Store                   certs...
                  CmsSignedDataStreamGenerator gen = new CmsSignedDataStreamGenerator();
            
                  gen.AddSigner(privateKey, cert, CmsSignedDataStreamGenerator.DIGEST_SHA1);
            
                  gen.AddCertificates(certs);
            
                  Stream sigOut = gen.Open(bOut);
            
                  sigOut.Write(Encoding.UTF8.GetBytes("Hello World!"));
            
                  sigOut.Close();
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="random">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.SetBufferSize(System.Int32)">
             Set the underlying string size for encapsulated data
            
             @param bufferSize length of octet strings to buffer the data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.String)">
            add a signer - no attributes other than the default ones will be
            provided here.
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.String,System.String)">
            add a signer, specifying the digest encryption algorithm - no attributes other than the default ones will be
            provided here.
            @throws NoSuchProviderException
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable)">
            add a signer with extra signed/unsigned attributes.
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.String,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable)">
            add a signer with extra signed/unsigned attributes - specifying digest
            encryption algorithm.
            @throws NoSuchProviderException
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String)">
            add a signer - no attributes other than the default ones will be
            provided here.
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,System.String)">
            add a signer - no attributes other than the default ones will be
            provided here.
            @throws NoSuchProviderException
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable)">
            add a signer with extra signed/unsigned attributes.
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.Open(System.IO.Stream)">
            generate a signed object that for a CMS Signed Data object
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.Open(System.IO.Stream,System.Boolean)">
            generate a signed object that for a CMS Signed Data
            object - if encapsulate is true a copy
            of the message will be included in the signature with the
            default content type "data".
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.Open(System.IO.Stream,System.Boolean,System.IO.Stream)">
            generate a signed object that for a CMS Signed Data
            object using the given provider - if encapsulate is true a copy
            of the message will be included in the signature with the
            default content type "data". If dataOutputStream is non null the data
            being signed will be written to the stream as it is processed.
            @param out stream the CMS object is to be written to.
            @param encapsulate true if data should be encapsulated.
            @param dataOutputStream output stream to copy the data being signed to.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.Open(System.IO.Stream,System.String,System.Boolean)">
            generate a signed object that for a CMS Signed Data
            object - if encapsulate is true a copy
            of the message will be included in the signature. The content type
            is set according to the OID represented by the string signedContentType.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.Open(System.IO.Stream,System.String,System.Boolean,System.IO.Stream)">
            generate a signed object that for a CMS Signed Data
            object using the given provider - if encapsulate is true a copy
            of the message will be included in the signature. The content type
            is set according to the OID represented by the string signedContentType.
            @param out stream the CMS object is to be written to.
            @param signedContentType OID for data to be signed.
            @param encapsulate true if data should be encapsulated.
            @param dataOutputStream output stream to copy the data being signed to.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedGenerator.Data">
            Default type for the signed data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="random">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedGenerator.AddSigners(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformationStore)">
             Add a store of precalculated signers to the generator.
            
             @param signerStore store of signers
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedGenerator.GetGeneratedDigests">
             Return a map of oids and byte arrays representing the digests calculated on the content during
             the last generate.
            
             @return a map of oids (as string objects) and byte[] representing digests.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedHelper.GetDigestAlgName(System.String)">
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsSignedHelper.GetEncryptionAlgName(System.String)">
            Return the digest encryption algorithm using one of the standard
            JCA string representations rather than the algorithm identifier (if
            possible).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator">
            Default authenticated attributes generator.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator.#ctor">
            Initialise to use all defaults
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             Initialise with some extra attributes or overrides.
            
             @param attributeTable initial attribute table to use.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator.CreateStandardAttributeTable(System.Collections.Generic.IDictionary{Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAttributeTableParameter,System.Object})">
             Create a standard attribute table from the passed in parameters - this will
             normally include contentType and messageDigest. If the constructor
             using an AttributeTable was used, entries in it for contentType and
             messageDigest will override the generated ones.
            
             @param parameters source parameters for table generation.
            
             @return a filled in IDictionary of attributes.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator.GetAttributes(System.Collections.Generic.IDictionary{Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAttributeTableParameter,System.Object})">
            @param parameters source parameters
            @return the populated attribute table
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator">
            Default signed attributes generator.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator.#ctor">
            Initialise to use all defaults
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             Initialise with some extra attributes or overrides.
            
             @param attributeTable initial attribute table to use.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator.CreateStandardAttributeTable(System.Collections.Generic.IDictionary{Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAttributeTableParameter,System.Object})">
             Create a standard attribute table from the passed in parameters - this will
             normally include contentType, signingTime, and messageDigest. If the constructor
             using an AttributeTable was used, entries in it for contentType, signingTime, and
             messageDigest will override the generated ones.
            
             @param parameters source parameters for table generation.
            
             @return a filled in Dictionary of attributes.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator.GetAttributes(System.Collections.Generic.IDictionary{Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAttributeTableParameter,System.Object})">
            @param parameters source parameters
            @return the populated attribute table
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.KekRecipientInformation">
            the RecipientInfo class for a recipient who has been sent a message
            encrypted using a secret key known to the other side.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.KekRecipientInformation.GetContentStream(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            decrypt the content and return an input stream.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.KeyAgreeRecipientInformation">
            the RecipientInfo class for a recipient who has been sent a message
            encrypted using key agreement.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.KeyAgreeRecipientInformation.GetContentStream(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            decrypt the content and return an input stream.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.KeyTransRecipientInformation">
            the KeyTransRecipientInformation class for a recipient who has been sent a secret
            key encrypted using their public key that needs to be used to
            extract the message.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.KeyTransRecipientInformation.GetContentStream(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            decrypt the content and return it as a byte array.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.OriginatorID">
            a basic index for an originator.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.OriginatorInformation.GetCertificates">
             Return the certificates stored in the underlying OriginatorInfo object.
            
             @return a Store of X509CertificateHolder objects.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.OriginatorInformation.GetCrls">
             Return the CRLs stored in the underlying OriginatorInfo object.
            
             @return a Store of X509CRLHolder objects.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.OriginatorInformation.ToAsn1Structure">
             Return the underlying ASN.1 object defining this SignerInformation object.
            
             @return a OriginatorInfo.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.PasswordRecipientInformation">
            the RecipientInfo class for a recipient who has been sent a message
            encrypted using a password.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.PasswordRecipientInformation.KeyDerivationAlgorithm">
             return the object identifier for the key derivation algorithm, or null
             if there is none present.
            
             @return OID for key derivation algorithm, if present.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.PasswordRecipientInformation.GetContentStream(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            decrypt the content and return an input stream.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.Pkcs5Scheme2PbeKey">
            <summary>
            PKCS5 scheme-2 - password converted to bytes assuming ASCII.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.Pkcs5Scheme2Utf8PbeKey">
            PKCS5 scheme-2 - password converted to bytes using UTF-8.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.RecipientInfoGenerator.Generate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.KeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Generate a RecipientInfo object for the given key.
            </summary>
            <param name="contentEncryptionKey">
            A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.KeyParameter"/>
            </param>
            <param name="random">
            A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom"/>
            </param>
            <returns>
            A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.RecipientInfo"/>
            </returns>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.GeneralSecurityException"></exception>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.RecipientInformation.KeyEncryptionAlgOid">
                    * return the object identifier for the key encryption algorithm.
                    * 
            		* @return OID for key encryption algorithm.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.RecipientInformation.KeyEncryptionAlgParams">
                    * return the ASN.1 encoded key encryption algorithm parameters, or null if
                    * there aren't any.
                    * 
            		* @return ASN.1 encoding of key encryption algorithm parameters.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.RecipientInformation.GetMac">
             Return the MAC calculated for the content stream. Note: this call is only meaningful once all
             the content has been read.
            
             @return  byte array containing the mac.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.RecipientInformationStore.GetFirstRecipient(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.RecipientID)">
             Return the first RecipientInformation object that matches the
             passed in selector. Null if there are no matches.
            
             @param selector to identify a recipient
             @return a single RecipientInformation object. Null if none matches.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.RecipientInformationStore.Count">
             Return the number of recipients in the collection.
            
             @return number of recipients identified.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.RecipientInformationStore.GetRecipients">
             Return all recipients in the collection
            
             @return a collection of recipients.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.RecipientInformationStore.GetRecipients(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.RecipientID)">
             Return possible empty collection with recipients matching the passed in RecipientID
            
             @param selector a recipient id to select against.
             @return a collection of RecipientInformation objects.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerID">
            a basic index for a signer.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.SetDirectSignature(System.Boolean)">
             If the passed in flag is true, the signer signature will be based on the data, not
             a collection of signed attributes, and no signed attributes will be included.
            
             @return the builder object
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.WithSignedAttributeGenerator(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAttributeTableGenerator)">
              Provide a custom signed attribute generator.
            
             @param signedGen a generator of signed attributes.
             @return the builder object
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.WithUnsignedAttributeGenerator(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.CmsAttributeTableGenerator)">
             Provide a generator of unsigned attributes.
            
             @param unsignedGen  a generator for signed attributes.
             @return the builder object
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.Build(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate)">
             Build a generator with the passed in X.509 certificate issuer and serial number as the signerIdentifier.
            
             @param contentSigner  operator for generating the final signature in the SignerInfo with.
             @param certificate  X.509 certificate related to the contentSigner.
             @return  a SignerInfoGenerator
             @throws OperatorCreationException   if the generator cannot be built.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.Build(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory,System.Byte[])">
             Build a generator with the passed in subjectKeyIdentifier as the signerIdentifier. If used  you should
             try to follow the calculation described in RFC 5280 section 4.2.1.2.
            
             @param signerFactory  operator factory for generating the final signature in the SignerInfo with.
             @param subjectKeyIdentifier    key identifier to identify the public key for verifying the signature.
             @return  a SignerInfoGenerator
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation">
            an expanded SignerInfo block from a CMS Signed message
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation)">
             Protected constructor. In some cases clients have their own idea about how to encode
             the signed attributes and calculate the signature. This constructor is to allow developers
             to deal with that by extending off the class and overriding e.g. SignedAttributes property.
            
             @param baseInfo the SignerInformation to base this one on.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.Version">
            return the version number for this objects underlying SignerInfo structure.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.DigestAlgOid">
            return the object identifier for the signature.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.DigestAlgParams">
            return the signature parameters, or null if there aren't any.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.GetContentDigest">
            return the content digest that was calculated during verification.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.EncryptionAlgOid">
            return the object identifier for the signature.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.EncryptionAlgParams">
            return the signature/encryption algorithm parameters, or null if
            there aren't any.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.SignedAttributes">
            return a table of the signed attributes - indexed by
            the OID of the attribute.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.UnsignedAttributes">
            return a table of the unsigned attributes indexed by
            the OID of the attribute.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.GetSignature">
            return the encoded signature
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.GetCounterSignatures">
            Return a SignerInformationStore containing the counter signatures attached to this
            signer. If no counter signatures are present an empty store is returned.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.GetEncodedSignedAttributes">
            return the DER encoding of the signed attributes.
            @throws IOException if an encoding error occurs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.Verify(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            verify that the given public key successfully handles and confirms the
            signature associated with this signer.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.Verify(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate)">
            verify that the given certificate successfully handles and confirms
            the signature associated with this signer and, if a signingTime
            attribute is available, that the certificate was valid at the time the
            signature was generated.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.ToSignerInfo">
             Return the base ASN.1 CMS structure that this object contains.
            
             @return an object containing a CMS SignerInfo structure.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.ReplaceUnsignedAttributes(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             Return a signer information object with the passed in unsigned
             attributes replacing the ones that are current associated with
             the object passed in.
            
             @param signerInformation the signerInfo to be used as the basis.
             @param unsignedAttributes the unsigned attributes to add.
             @return a copy of the original SignerInformationObject with the changed attributes.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation.AddCounterSigners(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation,Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformationStore)">
             Return a signer information object with passed in SignerInformationStore representing counter
             signatures attached as an unsigned attribute.
            
             @param signerInformation the signerInfo to be used as the basis.
             @param counterSigners signer info objects carrying counter signature.
             @return a copy of the original SignerInformationObject with the changed attributes.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformationStore.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation)">
             Create a store containing a single SignerInformation object.
            
             @param signerInfo the signer information to contain.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformationStore.#ctor(System.Collections.Generic.IEnumerable{Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation})">
             Create a store containing a collection of SignerInformation objects.
            
             @param signerInfos a collection signer information objects to contain.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformationStore.GetFirstSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerID)">
             Return the first SignerInformation object that matches the
             passed in selector. Null if there are no matches.
            
             @param selector to identify a signer
             @return a single SignerInformation object. Null if none matches.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformationStore.Count">
            <summary>The number of signers in the collection.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformationStore.GetSigners">
            <returns>An ICollection of all signers in the collection</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformationStore.GetSigners(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerID)">
             Return possible empty collection with signers matching the passed in SignerID
            
             @param selector a signer id to select against.
             @return a collection of SignerInformation objects.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SimpleAttributeTableGenerator">
            Basic generator that just returns a preconstructed attribute table
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.AuthenticatorControl">
            <summary>
            Carrier for an authenticator control.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.AuthenticatorControl.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerUtf8String)">
            <summary>
            Basic constructor - build from a UTF-8 string representing the token.
            </summary>
            <param name="token">UTF-8 string representing the token.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.AuthenticatorControl.#ctor(System.String)">
            <summary>
            Basic constructor - build from a string representing the token.
            </summary>
            <param name="token">string representing the token.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.AuthenticatorControl.Type">
            <summary>
            Return the type of this control.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.AuthenticatorControl.Value">
            <summary>
            Return the token associated with this control (a UTF8String).
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.CertificateRequestMessage.#ctor(System.Byte[])">
            <summary>
            Create a CertificateRequestMessage from the passed in bytes.
            </summary>
            <param name="encoded">BER/DER encoding of the CertReqMsg structure.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.CertificateRequestMessage.ToAsn1Structure">
            <summary>
            Return the underlying ASN.1 object defining this CertificateRequestMessage object.
            </summary>
            <returns>A CertReqMsg</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.CertificateRequestMessage.GetCertTemplate">
            <summary>
            Return the certificate template contained in this message.
            </summary>
            <returns>a CertTemplate structure.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.CertificateRequestMessage.HasControls">
            <summary>
            Return whether or not this request has control values associated with it.
            </summary>
            <returns>true if there are control values present, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.CertificateRequestMessage.HasControl(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>
            Return whether or not this request has a specific type of control value.
            </summary>
            <param name="objectIdentifier">the type OID for the control value we are checking for.</param>
            <returns>true if a control value of type is present, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.CertificateRequestMessage.GetControl(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>
            Return a control value of the specified type.
            </summary>
            <param name="type">the type OID for the control value we are checking for.</param>
            <returns>the control value if present, null otherwise.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.CertificateRequestMessage.HasProofOfPossession">
            <summary>
            Return whether or not this request message has a proof-of-possession field in it.
            </summary>
            <returns>true if proof-of-possession is present, false otherwise.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.CertificateRequestMessage.ProofOfPossession">
            <summary>
            Return the type of the proof-of-possession this request message provides.
            </summary>
            <returns>one of: popRaVerified, popSigningKey, popKeyEncipherment, popKeyAgreement</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.CertificateRequestMessage.HasSigningKeyProofOfPossessionWithPkMac">
            <summary>
            Return whether or not the proof-of-possession (POP) is of the type popSigningKey and
            it has a public key MAC associated with it.
            </summary>
            <returns>true if POP is popSigningKey and a PKMAC is present, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.CertificateRequestMessage.IsValidSigningKeyPop(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IVerifierFactoryProvider)">
            <summary>
            Return whether or not a signing key proof-of-possession (POP) is valid.
            </summary>
            <param name="verifierProvider">a provider that can produce content verifiers for the signature contained in this POP.</param>
            <returns>true if the POP is valid, false otherwise.</returns>
            <exception cref="T:System.InvalidOperationException">if there is a problem in verification or content verifier creation.</exception>
            <exception cref="T:System.InvalidOperationException">if POP not appropriate.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.CertificateRequestMessage.GetEncoded">
            <summary>
            Return the ASN.1 encoding of the certReqMsg we wrap.
            </summary>
            <returns>a byte array containing the binary encoding of the certReqMsg.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.EncryptedValueBuilder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IKeyWrapper,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherBuilderWithKey)">
            
             Create a builder that makes EncryptedValue structures.
            
             <param name="wrapper">wrapper a wrapper for key used to encrypt the actual data contained in the EncryptedValue.</param>
             <param name="encryptor">encryptor  an output encryptor to encrypt the actual data contained in the EncryptedValue. </param>
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.EncryptedValueBuilder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IKeyWrapper,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherBuilderWithKey,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.IEncryptedValuePadder)">
            
             Create a builder that makes EncryptedValue structures with fixed length blocks padded using the passed in padder.
            
             <param name="wrapper">a wrapper for key used to encrypt the actual data contained in the EncryptedValue.</param>
             <param name="encryptor">encryptor  an output encryptor to encrypt the actual data contained in the EncryptedValue.</param>
             <param name="padder">padder a padder to ensure that the EncryptedValue created will always be a constant length.</param>
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.EncryptedValueBuilder.Build(System.Char[])">
            
             Build an EncryptedValue structure containing the passed in pass phrase.
            
             <param name="revocationPassphrase">a revocation pass phrase.</param>
            <returns>an EncryptedValue containing the encrypted pass phrase.</returns>       
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.EncryptedValueBuilder.Build(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate)">
            <summary>
             Build an EncryptedValue structure containing the certificate contained in
             the passed in holder.
            </summary>
             <param name="holder">a holder containing a certificate.</param>
              <returns>an EncryptedValue containing the encrypted certificate.</returns>
             <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.CrmfException">on a failure to encrypt the data, or wrap the symmetric key for this value.</exception>
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.EncryptedValueBuilder.Build(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo)">
            <summary>
             Build an EncryptedValue structure containing the private key contained in
             the passed info structure.
            </summary>
             <param name="privateKeyInfo">a PKCS#8 private key info structure.</param>
             <returns>an EncryptedValue containing an EncryptedPrivateKeyInfo structure.</returns>
             <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.CrmfException">on a failure to encrypt the data, or wrap the symmetric key for this value.</exception>
            
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.IControl">
            <summary>
            Generic interface for a CertificateRequestMessage control value.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.IControl.Type">
            <summary>
            Return the type of this control.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.IControl.Value">
            <summary>
            Return the value contained in this control object.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.IEncryptedValuePadder">
            <summary>
            An encrypted value padder is used to make sure that prior to a value been
            encrypted the data is padded to a standard length.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.IEncryptedValuePadder.GetPaddedData(System.Byte[])">
            
             <summary>Return a byte array of padded data.</summary>
            
             <param name="data">the data to be padded.</param>
             <returns>a padded byte array containing data.</returns>
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.IEncryptedValuePadder.GetUnpaddedData(System.Byte[])">
            
             <summary>Return a byte array of with padding removed.</summary>
            
             <param name="paddedData">the data to be padded.</param>
             <returns>an array containing the original unpadded data.</returns>
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PkiArchiveControl.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Crmf.PkiArchiveOptions)">
            <summary>
            Basic constructor - build from an PKIArchiveOptions structure.
            </summary>
            <param name="pkiArchiveOptions">the ASN.1 structure that will underlie this control.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PkiArchiveControl.Type">
            <summary>
            Return the type of this control.
            </summary>
            <returns>CRMFObjectIdentifiers.id_regCtrl_pkiArchiveOptions</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PkiArchiveControl.Value">
            <summary>
            Return the underlying ASN.1 object.
            </summary>
            <returns>a PKIArchiveOptions structure.</returns>    
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PkiArchiveControl.ArchiveType">
            <summary>
            Return the archive control type, one of: encryptedPrivKey,keyGenParameters,or archiveRemGenPrivKey.
            </summary>
            <returns>the archive control type.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PkiArchiveControl.EnvelopedData">
            <summary>
            Return whether this control contains enveloped data.
            </summary>
            <returns>true if the control contains enveloped data, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PkiArchiveControl.GetEnvelopedData">
            <summary>
            Return the enveloped data structure contained in this control.
            </summary>
            <returns>a CMSEnvelopedData object.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PkiArchiveControlBuilder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName)">
             <summary>
            Basic constructor - specify the contents of the PKIArchiveControl structure.
             </summary>
             <param name="privateKeyInfo">the private key to be archived.</param>
             <param name="generalName">the general name to be associated with the private key.</param>
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PkiArchiveControlBuilder.AddRecipientGenerator(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.RecipientInfoGenerator)">
            <summary>Add a recipient generator to this control.</summary>       
            <param name="recipientGen"> recipient generator created for a specific recipient.</param>
            <returns>this builder object.</returns>       
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PkiArchiveControlBuilder.Build(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherBuilderWithKey)">
            <summary>Build the PKIArchiveControl using the passed in encryptor to encrypt its contents.</summary>
            <param name="contentEncryptor">a suitable content encryptor.</param>
            <returns>a PKIArchiveControl object.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PKMacBuilder.#ctor">
            <summary>
            Default, IterationCount = 1000, OIW=IdSha1, Mac=HmacSHA1
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PKMacBuilder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.IPKMacPrimitivesProvider)">
            <summary>
            Defaults with IPKMacPrimitivesProvider
            </summary>
            <param name="provider"></param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PKMacBuilder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.IPKMacPrimitivesProvider,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier)">
            <summary>
            Create.
            </summary>
            <param name="provider">The Mac provider</param>
            <param name="digestAlgorithmIdentifier">Digest Algorithm Id</param>
            <param name="macAlgorithmIdentifier">Mac Algorithm Id</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PKMacBuilder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.IPKMacPrimitivesProvider,System.Int32)">
            <summary>
            Create a PKMAC builder enforcing a ceiling on the maximum iteration count.
            </summary>
            <param name="provider">supporting calculator</param>
            <param name="maxIterations">max allowable value for iteration count.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PKMacBuilder.SetSaltLength(System.Int32)">
             Set the salt length in octets.
            
             @param saltLength length in octets of the salt to be generated.
             @return the generator
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PKMacBuilder.SetIterationCount(System.Int32)">
            <summary>
            Set the iteration count.
            </summary>
            <param name="iterationCount">the iteration count.</param>
            <returns>this</returns>
            <exception cref="T:System.ArgumentException">if iteration count is less than 100</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PKMacBuilder.SetParameters(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PbmParameter)">
            <summary>
            Set PbmParameters
            </summary>
            <param name="parameters">The parameters.</param>
            <returns>this</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PKMacBuilder.SetSecureRandom(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            The Secure random
            </summary>
            <param name="random">The random.</param>
            <returns>this</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.PKMacBuilder.Build(System.Char[])">
            <summary>
            Build an IMacFactory.
            </summary>
            <param name="password">The password.</param>
            <returns>IMacFactory</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.RegTokenControl.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerUtf8String)">
            <summary>
            Basic constructor - build from a UTF-8 string representing the token.
            </summary>
            <param name="token">UTF-8 string representing the token.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.RegTokenControl.#ctor(System.String)">
            <summary>
            Basic constructor - build from a string representing the token.
            </summary>
            <param name="token">string representing the token.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.RegTokenControl.Type">
            <summary>
            Return the type of this control.
            </summary>
            <returns>CRMFObjectIdentifiers.id_regCtrl_regToken</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crmf.RegTokenControl.Value">
            <summary>
            Return the token associated with this control (a UTF8String).
            </summary>
            <returns>a UTF8String.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.DHAgreement">
            a Diffie-Hellman key exchange engine.
            <p>
            note: This uses MTI/A0 key agreement in order to make the key agreement
            secure against passive attacks. If you're doing Diffie-Hellman and both
            parties have long term public keys you should look at using this. For
            further information have a look at RFC 2631.</p>
            <p>
            It's possible to extend this to more than two parties as well, for the moment
            that is left as an exercise for the reader.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.DHAgreement.CalculateMessage">
            calculate our initial message.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.DHAgreement.CalculateAgreement(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.DHPublicKeyParameters,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            given a message from a given party and the corresponding public key
            calculate the next message in the agreement sequence. In this case
            this will represent the shared secret.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.DHBasicAgreement">
            a Diffie-Hellman key agreement class.
            <p>
            note: This is only the basic algorithm, it doesn't take advantage of
            long term public keys if they are available. See the DHAgreement class
            for a "better" implementation.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.DHBasicAgreement.CalculateAgreement(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            given a short term public key from a given party calculate the next
            message in the agreement sequence.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.DHStandardGroups">
            <summary>Standard Diffie-Hellman groups from various IETF specifications.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.ECDHBasicAgreement">
             P1363 7.2.1 ECSVDP-DH
            
             ECSVDP-DH is Elliptic Curve Secret Value Derivation Primitive,
             Diffie-Hellman version. It is based on the work of [DH76], [Mil86],
             and [Kob87]. This primitive derives a shared secret value from one
             party's private key and another party's public key, where both have
             the same set of EC domain parameters. If two parties correctly
             execute this primitive, they will produce the same output. This
             primitive can be invoked by a scheme to derive a shared secret key;
             specifically, it may be used with the schemes ECKAS-DH1 and
             DL/ECKAS-DH2. It assumes that the input keys are valid (see also
             Section 7.2.2).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.ECDHCBasicAgreement">
             P1363 7.2.2 ECSVDP-DHC
            
             ECSVDP-DHC is Elliptic Curve Secret Value Derivation Primitive,
             Diffie-Hellman version with cofactor multiplication. It is based on
             the work of [DH76], [Mil86], [Kob87], [LMQ98] and [Kal98a]. This
             primitive derives a shared secret value from one party's private key
             and another party's public key, where both have the same set of EC
             domain parameters. If two parties correctly execute this primitive,
             they will produce the same output. This primitive can be invoked by a
             scheme to derive a shared secret key; specifically, it may be used
             with the schemes ECKAS-DH1 and DL/ECKAS-DH2. It does not assume the
             validity of the input public key (see also Section 7.2.1).
             <p>
             Note: As stated P1363 compatibility mode with ECDH can be preset, and
             in this case the implementation doesn't have a ECDH compatibility mode
             (if you want that just use ECDHBasicAgreement and note they both implement
             BasicAgreement!).</p>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant">
             <summary>
             A participant in a Password Authenticated Key Exchange by Juggling (J-PAKE) exchange.
            
             The J-PAKE exchange is defined by Feng Hao and Peter Ryan in the paper
             <a href="http://grouper.ieee.org/groups/1363/Research/contributions/hao-ryan-2008.pdf">
             "Password Authenticated Key Exchange by Juggling, 2008."</a>
            
             The J-PAKE protocol is symmetric.
             There is no notion of a <i>client</i> or <i>server</i>, but rather just two <i>participants</i>.
             An instance of JPakeParticipant represents one participant, and
             is the primary interface for executing the exchange.
            
             To execute an exchange, construct a JPakeParticipant on each end,
             and call the following 7 methods
             (once and only once, in the given order, for each participant, sending messages between them as described):
            
             CreateRound1PayloadToSend() - and send the payload to the other participant
             ValidateRound1PayloadReceived(JPakeRound1Payload) - use the payload received from the other participant
             CreateRound2PayloadToSend() - and send the payload to the other participant
             ValidateRound2PayloadReceived(JPakeRound2Payload) - use the payload received from the other participant
             CalculateKeyingMaterial()
             CreateRound3PayloadToSend(BigInteger) - and send the payload to the other participant
             ValidateRound3PayloadReceived(JPakeRound3Payload, BigInteger) - use the payload received from the other participant
            
             Each side should derive a session key from the keying material returned by CalculateKeyingMaterial().
             The caller is responsible for deriving the session key using a secure key derivation function (KDF).
            
             Round 3 is an optional key confirmation process.
             If you do not execute round 3, then there is no assurance that both participants are using the same key.
             (i.e. if the participants used different passwords, then their session keys will differ.)
            
             If the round 3 validation succeeds, then the keys are guaranteed to be the same on both sides.
            
             The symmetric design can easily support the asymmetric cases when one party initiates the communication.
             e.g. Sometimes the round1 payload and round2 payload may be sent in one pass.
             Also, in some cases, the key confirmation payload can be sent together with the round2 payload.
             These are the trivial techniques to optimize the communication.
            
             The key confirmation process is implemented as specified in
             <a href="http://csrc.nist.gov/publications/nistpubs/800-56A/SP800-56A_Revision1_Mar08-2007.pdf">NIST SP 800-56A Revision 1</a>,
             Section 8.2 Unilateral Key Confirmation for Key Agreement Schemes.
            
             This class is stateful and NOT threadsafe.
             Each instance should only be used for ONE complete J-PAKE exchange
             (i.e. a new JPakeParticipant should be constructed for each new J-PAKE exchange).
             </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.#ctor(System.String,System.Char[])">
             <summary>
             Convenience constructor for a new JPakeParticipant that uses
             the JPakePrimeOrderGroups#NIST_3072 prime order group,
             a SHA-256 digest, and a default SecureRandom implementation.
            
             After construction, the State state will be STATE_INITIALIZED.
             
             Throws NullReferenceException if any argument is null. Throws
             ArgumentException if password is empty.
             </summary>
             <param name="participantId">Unique identifier of this participant.
                  The two participants in the exchange must NOT share the same id.</param>
             <param name="password">Shared secret.
                  A defensive copy of this array is made (and cleared once CalculateKeyingMaterial() is called).
                  Caller should clear the input password as soon as possible.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.#ctor(System.String,System.Char[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroup)">
             <summary>
             Convenience constructor for a new JPakeParticipant that uses
             a SHA-256 digest, and a default SecureRandom implementation.
            
             After construction, the State state will be STATE_INITIALIZED.
             
             Throws NullReferenceException if any argument is null. Throws
             ArgumentException if password is empty.
             </summary>
             <param name="participantId">Unique identifier of this participant.
                  The two participants in the exchange must NOT share the same id.</param>
             <param name="password">Shared secret.
                  A defensive copy of this array is made (and cleared once CalculateKeyingMaterial() is called).
                  Caller should clear the input password as soon as possible.</param>
             <param name="group">Prime order group. See JPakePrimeOrderGroups for standard groups.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.#ctor(System.String,System.Char[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroup,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
             <summary>
             Constructor for a new JPakeParticipant.
            
             After construction, the State state will be STATE_INITIALIZED.
             
             Throws NullReferenceException if any argument is null. Throws
             ArgumentException if password is empty.
             </summary>
             <param name="participantId">Unique identifier of this participant.
                  The two participants in the exchange must NOT share the same id.</param>
             <param name="password">Shared secret.
                  A defensive copy of this array is made (and cleared once CalculateKeyingMaterial() is called).
                  Caller should clear the input password as soon as possible.</param>
             <param name="group">Prime order group. See JPakePrimeOrderGroups for standard groups.</param>
             <param name="digest">Digest to use during zero knowledge proofs and key confirmation
                 (SHA-256 or stronger preferred).</param>
             <param name="random">Source of secure random data for x1 and x2, and for the zero knowledge proofs.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.State">
            <summary>
            Gets the current state of this participant.
            See the <tt>STATE_*</tt> constants for possible values.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.CreateRound1PayloadToSend">
             <summary>
             Creates and returns the payload to send to the other participant during round 1.
            
             After execution, the State state} will be STATE_ROUND_1_CREATED}.
             </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.ValidateRound1PayloadReceived(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload)">
             <summary>
             Validates the payload received from the other participant during round 1.
            
             Must be called prior to CreateRound2PayloadToSend().
            
             After execution, the State state will be  STATE_ROUND_1_VALIDATED.
             
             Throws CryptoException if validation fails. Throws InvalidOperationException
             if called multiple times.
             </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.CreateRound2PayloadToSend">
             <summary>
             Creates and returns the payload to send to the other participant during round 2.
            
             ValidateRound1PayloadReceived(JPakeRound1Payload) must be called prior to this method.
            
             After execution, the State state will be  STATE_ROUND_2_CREATED.
            
             Throws InvalidOperationException if called prior to ValidateRound1PayloadReceived(JPakeRound1Payload), or multiple times
             </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.ValidateRound2PayloadReceived(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound2Payload)">
             <summary>
             Validates the payload received from the other participant during round 2.
             Note that this DOES NOT detect a non-common password.
             The only indication of a non-common password is through derivation
             of different keys (which can be detected explicitly by executing round 3 and round 4)
            
             Must be called prior to CalculateKeyingMaterial().
            
             After execution, the State state will be STATE_ROUND_2_VALIDATED.
            
             Throws CryptoException if validation fails. Throws
             InvalidOperationException if called prior to ValidateRound1PayloadReceived(JPakeRound1Payload), or multiple times
             </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.CalculateKeyingMaterial">
             <summary>
             Calculates and returns the key material.
             A session key must be derived from this key material using a secure key derivation function (KDF).
             The KDF used to derive the key is handled externally (i.e. not by JPakeParticipant).
            
             The keying material will be identical for each participant if and only if
             each participant's password is the same.  i.e. If the participants do not
             share the same password, then each participant will derive a different key.
             Therefore, if you immediately start using a key derived from
             the keying material, then you must handle detection of incorrect keys.
             If you want to handle this detection explicitly, you can optionally perform
             rounds 3 and 4.  See JPakeParticipant for details on how to execute
             rounds 3 and 4.
            
             The keying material will be in the range <tt>[0, p-1]</tt>.
            
             ValidateRound2PayloadReceived(JPakeRound2Payload) must be called prior to this method.
             
             As a side effect, the internal password array is cleared, since it is no longer needed.
            
             After execution, the State state will be STATE_KEY_CALCULATED.
            
             Throws InvalidOperationException if called prior to ValidateRound2PayloadReceived(JPakeRound2Payload),
             or if called multiple times.
             </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.CreateRound3PayloadToSend(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
             <summary>
             Creates and returns the payload to send to the other participant during round 3.
            
             See JPakeParticipant for more details on round 3.
            
             After execution, the State state} will be  STATE_ROUND_3_CREATED.
             Throws InvalidOperationException if called prior to CalculateKeyingMaterial, or multiple
             times.
             </summary>
             <param name="keyingMaterial">The keying material as returned from CalculateKeyingMaterial().</param> 
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.ValidateRound3PayloadReceived(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound3Payload,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
             <summary>
             Validates the payload received from the other participant during round 3.
            
             See JPakeParticipant for more details on round 3.
            
             After execution, the State state will be STATE_ROUND_3_VALIDATED.
             
             Throws CryptoException if validation fails. Throws InvalidOperationException if called prior to
             CalculateKeyingMaterial or multiple times
             </summary>
             <param name="round3PayloadReceived">The round 3 payload received from the other participant.</param> 
             <param name="keyingMaterial">The keying material as returned from CalculateKeyingMaterial().</param> 
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroup">
             <summary>
             A pre-computed prime order group for use during a J-PAKE exchange.
            
             Typically a Schnorr group is used.  In general, J-PAKE can use any prime order group
             that is suitable for public key cryptography, including elliptic curve cryptography.
            
             See JPakePrimeOrderGroups for convenient standard groups.
            
             NIST <a href="http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/DSA2_All.pdf">publishes</a>
             many groups that can be used for the desired level of security.
             </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroup.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
             <summary>
             Constructs a new JPakePrimeOrderGroup.
            
             In general, you should use one of the pre-approved groups from
             JPakePrimeOrderGroups, rather than manually constructing one.
            
             The following basic checks are performed:
            
             p-1 must be evenly divisible by q
             g must be in [2, p-1]
             g^q mod p must equal 1
             p must be prime (within reasonably certainty)
             q must be prime (within reasonably certainty)
            
             The prime checks are performed using BigInteger#isProbablePrime(int),
             and are therefore subject to the same probability guarantees.
            
             These checks prevent trivial mistakes.
             However, due to the small uncertainties if p and q are not prime,
             advanced attacks are not prevented.
             Use it at your own risk.
             
             Throws NullReferenceException if any argument is null. Throws
             InvalidOperationException is any of the above validations fail.
             </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroup.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.Boolean)">
            <summary>
            Constructor used by the pre-approved groups in JPakePrimeOrderGroups.
            These pre-approved groups can avoid the expensive checks.
            User-specified groups should not use this constructor.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroups">
            <summary>
            Standard pre-computed prime order groups for use by J-PAKE.
            (J-PAKE can use pre-computed prime order groups, same as DSA and Diffie-Hellman.)
            <p/>
            This class contains some convenient constants for use as input for
            constructing {@link JPAKEParticipant}s.
            <p/>
            The prime order groups below are taken from Sun's JDK JavaDoc (docs/guide/security/CryptoSpec.html#AppB),
            and from the prime order groups
            <a href="http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/DSA2_All.pdf">published by NIST</a>.
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroups.SUN_JCE_1024">
            <summary>
            From Sun's JDK JavaDoc (docs/guide/security/CryptoSpec.html#AppB)
            1024-bit p, 160-bit q and 1024-bit g for 80-bit security.
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroups.NIST_2048">
            <summary>
            From NIST.
            2048-bit p, 224-bit q and 2048-bit g for 112-bit security.
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroups.NIST_3072">
            <summary>
            From NIST.
            3072-bit p, 256-bit q and 3072-bit g for 128-bit security.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload">
            <summary>
            The payload sent/received during the first round of a J-PAKE exchange.
            
            Each JPAKEParticipant creates and sends an instance of this payload to
            the other. The payload to send should be created via 
            JPAKEParticipant.CreateRound1PayloadToSend().
            
            Each participant must also validate the payload received from the other.
            The received payload should be validated via 
            JPAKEParticipant.ValidateRound1PayloadReceived(JPakeRound1Payload).
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload.participantId">
            <summary>
            The id of the JPAKEParticipant who created/sent this payload.
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload.gx1">
            <summary>
            The value of g^x1
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload.gx2">
            <summary>
            The value of g^x2
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload.knowledgeProofForX1">
            <summary>
            The zero knowledge proof for x1.
            
            This is a two element array, containing {g^v, r} for x1.
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload.knowledgeProofForX2">
            <summary>
            The zero knowledge proof for x2.
            
            This is a two element array, containing {g^v, r} for x2.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound2Payload">
            <summary>
            The payload sent/received during the second round of a J-PAKE exchange.
            
            Each JPAKEParticipant creates and sends an instance
            of this payload to the other JPAKEParticipant.
            The payload to send should be created via
            JPAKEParticipant#createRound2PayloadToSend()
            
            Each JPAKEParticipant must also validate the payload
            received from the other JPAKEParticipant.
            The received payload should be validated via
            JPAKEParticipant#validateRound2PayloadReceived(JPakeRound2Payload)
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound2Payload.participantId">
            <summary>
            The id of the JPAKEParticipant who created/sent this payload.
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound2Payload.a">
            <summary>
            The value of A, as computed during round 2.
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound2Payload.knowledgeProofForX2s">
            <summary>
            The zero knowledge proof for x2 * s.
            
            This is a two element array, containing {g^v, r} for x2 * s.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound3Payload">
             <summary>
             The payload sent/received during the optional third round of a J-PAKE exchange,
             which is for explicit key confirmation.
            
             Each JPAKEParticipant creates and sends an instance
             of this payload to the other JPAKEParticipant.
             The payload to send should be created via
             JPAKEParticipant#createRound3PayloadToSend(BigInteger)
            
             Eeach JPAKEParticipant must also validate the payload
             received from the other JPAKEParticipant.
             The received payload should be validated via
             JPAKEParticipant#validateRound3PayloadReceived(JPakeRound3Payload, BigInteger)
             </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound3Payload.participantId">
            <summary>
            The id of the {@link JPAKEParticipant} who created/sent this payload.
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound3Payload.macTag">
            <summary>
            The value of MacTag, as computed by round 3.
            
            See JPAKEUtil#calculateMacTag(string, string, BigInteger, BigInteger, BigInteger, BigInteger, BigInteger, org.bouncycastle.crypto.Digest)
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities">
            <summary>
            Primitives needed for a J-PAKE exchange.
            
            The recommended way to perform a J-PAKE exchange is by using
            two JPAKEParticipants.  Internally, those participants
            call these primitive operations in JPakeUtilities.
            
            The primitives, however, can be used without a JPAKEParticipant if needed.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.GenerateX1(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Return a value that can be used as x1 or x3 during round 1.
            The returned value is a random value in the range [0, q-1].
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.GenerateX2(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Return a value that can be used as x2 or x4 during round 1.
            The returned value is a random value in the range [1, q-1].
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateS(System.Char[])">
            <summary>
            Converts the given password to a BigInteger
            for use in arithmetic calculations.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateGx(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Calculate g^x mod p as done in round 1.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateGA(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Calculate ga as done in round 2.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateX2s(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Calculate x2 * s as done in round 2.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateA(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Calculate A as done in round 2. 
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateZeroKnowledgeProof(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Calculate a zero knowledge proof of x using Schnorr's signature.
            The returned array has two elements {g^v, r = v-x*h} for x.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.ValidateGx4(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Validates that g^x4 is not 1.
            throws CryptoException if g^x4 is 1
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.ValidateGa(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Validates that ga is not 1.
            
            As described by Feng Hao...
            Alice could simply check ga != 1 to ensure it is a generator.
            In fact, as we will explain in Section 3, (x1 + x3 + x4 ) is random over Zq even in the face of active attacks.
            Hence, the probability for ga = 1 is extremely small - on the order of 2^160 for 160-bit q.
            
            throws CryptoException if ga is 1
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.ValidateZeroKnowledgeProof(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger[],System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
            <summary>
            Validates the zero knowledge proof (generated by
            calculateZeroKnowledgeProof(BigInteger, BigInteger, BigInteger, BigInteger, BigInteger, string, Digest, SecureRandom)
            is correct.
            
            throws CryptoException if the zero knowledge proof is not correct
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateKeyingMaterial(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Calculates the keying material, which can be done after round 2 has completed.
            A session key must be derived from this key material using a secure key derivation function (KDF).
            The KDF used to derive the key is handled externally (i.e. not by JPAKEParticipant).
            
            KeyingMaterial = (B/g^{x2*x4*s})^x2
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.ValidateParticipantIdsDiffer(System.String,System.String)">
             <summary>
             Validates that the given participant ids are not equal.
             (For the J-PAKE exchange, each participant must use a unique id.)
            
             Throws CryptoException if the participantId strings are equal.
             </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.ValidateParticipantIdsEqual(System.String,System.String)">
            <summary>
            Validates that the given participant ids are equal.
            This is used to ensure that the payloads received from
            each round all come from the same participant.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.ValidateNotNull(System.Object,System.String)">
            <summary>
            Validates that the given object is not null.
            throws NullReferenceException if the object is null.
            </summary>
            <param name="obj">object in question</param>
            <param name="description">name of the object (to be used in exception message)</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateMacTag(System.String,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
             <summary>
             Calculates the MacTag (to be used for key confirmation), as defined by
             <a href="http://csrc.nist.gov/publications/nistpubs/800-56A/SP800-56A_Revision1_Mar08-2007.pdf">NIST SP 800-56A Revision 1</a>,
             Section 8.2 Unilateral Key Confirmation for Key Agreement Schemes.
            
             MacTag = HMAC(MacKey, MacLen, MacData)
             MacKey = H(K || "JPAKE_KC")
             MacData = "KC_1_U" || participantId || partnerParticipantId || gx1 || gx2 || gx3 || gx4
            
             Note that both participants use "KC_1_U" because the sender of the round 3 message
             is always the initiator for key confirmation.
            
             HMAC = {@link HMac} used with the given {@link Digest}
             H = The given {@link Digest}
             MacLen = length of MacTag
             </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateMacKey(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
            <summary>
            Calculates the MacKey (i.e. the key to use when calculating the MagTag for key confirmation).
            
            MacKey = H(K || "JPAKE_KC")
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.ValidateMacTag(System.String,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Validates the MacTag received from the partner participant.
            
            throws CryptoException if the participantId strings are equal.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Kdf.ConcatenationKdfGenerator">
            <summary>Generator for Concatenation Key Derivation Function defined in NIST SP 800-56A, Sect 5.8.1</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Kdf.ConcatenationKdfGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
            <param name="digest">the digest to be used as the source of generated bytes</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Kdf.ConcatenationKdfGenerator.Digest">
            <summary>the underlying digest.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Kdf.ConcatenationKdfGenerator.GenerateBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Fill <c>len</c> bytes of the output buffer with bytes generated from the derivation function.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Kdf.DHKekGenerator">
            RFC 2631 Diffie-hellman KEK derivation function.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Kdf.ECDHKekGenerator">
            X9.63 based key derivation function for ECDH CMS.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.SM2KeyExchange">
            <summary>
            SM2 Key Exchange protocol - based on https://tools.ietf.org/html/draft-shen-sm2-ecdsa-02
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client">
            Implements the client side SRP-6a protocol. Note that this class is stateful, and therefore NOT threadsafe.
            This implementation of SRP is based on the optimized message sequence put forth by Thomas Wu in the paper
            "SRP-6: Improvements and Refinements to the Secure Remote Password Protocol, 2002"
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            Initialises the client to begin new authentication attempt
            @param N The safe prime associated with the client's verifier
            @param g The group parameter associated with the client's verifier
            @param digest The digest algorithm associated with the client's verifier
            @param random For key generation
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.GenerateClientCredentials(System.Byte[],System.Byte[],System.Byte[])">
            Generates client's credentials given the client's salt, identity and password
            @param salt The salt used in the client's verifier.
            @param identity The user's identity (eg. username)
            @param password The user's password
            @return Client's public value to send to server
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.CalculateSecret(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Generates client's verification message given the server's credentials
            @param serverB The server's credentials
            @return Client's verification message for the server
            @throws CryptoException If server's credentials are invalid
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.CalculateClientEvidenceMessage">
            Computes the client evidence message M1 using the previously received values.
            To be called after calculating the secret S.
            @return M1: the client side generated evidence message
            @throws CryptoException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.VerifyServerEvidenceMessage(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Authenticates the server evidence message M2 received and saves it only if correct.
            @param M2: the server side generated evidence message
            @return A boolean indicating if the server message M2 was the expected one.
            @throws CryptoException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.CalculateSessionKey">
            Computes the final session key as a result of the SRP successful mutual authentication
            To be called after verifying the server evidence message M2.
            @return Key: the mutually authenticated symmetric session key
            @throws CryptoException
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server">
            Implements the server side SRP-6a protocol. Note that this class is stateful, and therefore NOT threadsafe.
            This implementation of SRP is based on the optimized message sequence put forth by Thomas Wu in the paper
            "SRP-6: Improvements and Refinements to the Secure Remote Password Protocol, 2002"
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            Initialises the server to accept a new client authentication attempt
            @param N The safe prime associated with the client's verifier
            @param g The group parameter associated with the client's verifier
            @param v The client's verifier
            @param digest The digest algorithm associated with the client's verifier
            @param random For key generation
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.GenerateServerCredentials">
            Generates the server's credentials that are to be sent to the client.
            @return The server's public value to the client
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.CalculateSecret(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Processes the client's credentials. If valid the shared secret is generated and returned.
            @param clientA The client's credentials
            @return A shared secret BigInteger
            @throws CryptoException If client's credentials are invalid
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.VerifyClientEvidenceMessage(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Authenticates the received client evidence message M1 and saves it only if correct.
            To be called after calculating the secret S.
            @param M1: the client side generated evidence message
            @return A boolean indicating if the client message M1 was the expected one.
            @throws CryptoException 
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.CalculateServerEvidenceMessage">
            Computes the server evidence message M2 using the previously verified values.
            To be called after successfully verifying the client evidence message M1.
            @return M2: the server side generated evidence message
            @throws CryptoException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.CalculateSessionKey">
            Computes the final session key as a result of the SRP successful mutual authentication
            To be called after calculating the server evidence message M2.
            @return Key: the mutual authenticated symmetric session key
            @throws CryptoException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Utilities.CalculateM1(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Computes the client evidence message (M1) according to the standard routine:
            M1 = H( A | B | S )
            @param digest The Digest used as the hashing function H
            @param N Modulus used to get the pad length
            @param A The public client value
            @param B The public server value
            @param S The secret calculated by both sides
            @return M1 The calculated client evidence message
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Utilities.CalculateM2(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Computes the server evidence message (M2) according to the standard routine:
            M2 = H( A | M1 | S )
            @param digest The Digest used as the hashing function H
            @param N Modulus used to get the pad length
            @param A The public client value
            @param M1 The client evidence message
            @param S The secret calculated by both sides
            @return M2 The calculated server evidence message
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Utilities.CalculateKey(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Computes the final Key according to the standard routine: Key = H(S)
            @param digest The Digest used as the hashing function H
            @param N Modulus used to get the pad length
            @param S The secret calculated by both sides
            @return
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6VerifierGenerator">
            Generates new SRP verifier for user
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6VerifierGenerator.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
            Initialises generator to create new verifiers
            @param N The safe prime to use (see DHParametersGenerator)
            @param g The group parameter to use (see DHParametersGenerator)
            @param digest The digest to use. The same digest type will need to be used later for the actual authentication
            attempt. Also note that the final session key size is dependent on the chosen digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Agreement.Srp.Srp6VerifierGenerator.GenerateVerifier(System.Byte[],System.Byte[],System.Byte[])">
            Creates a new SRP verifier
            @param salt The salt to use, generally should be large and random
            @param identity The user's identifying information (eg. username)
            @param password The user's password
            @return A new verifier for use in future SRP authentication
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair">
            a holding class for public/private parameter pairs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
             basic constructor.
            
             @param publicParam a public key parameters object.
             @param privateParam the corresponding private key parameters.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.Public">
             return the public key parameters.
            
             @return the public key parameters.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.Private">
             return the private key parameters.
            
             @return the private key parameters.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadBlockCipher">
            The AEAD block ciphers already handle buffering internally, so this class
            just takes care of implementing IBufferedCipher methods.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadCipher">
            The AEAD ciphers already handle buffering internally, so this class
            just takes care of implementing IBufferedCipher methods.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAeadCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher">
            a buffer wrapper for an asymmetric block cipher, allowing input
            to be accumulated in a piecemeal fashion until final processing.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher)">
             base constructor.
            
             @param cipher the cipher this buffering object wraps.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.GetBufferPosition">
             return the amount of data sitting in the buffer.
            
             @return the amount of data sitting in the buffer.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the buffer and the underlying cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.DoFinal">
             process the contents of the buffer using the underlying
             cipher.
            
             @return the result of the encryption/decryption process on the
             buffer.
             @exception InvalidCipherTextException if we are given a garbage block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.Reset">
            <summary>Reset the buffer</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion. The BufferedBlockCipher outputs a block only when the
            buffer is full and more data is being added, or on a doFinal.
            <p>
            Note: in the case where the underlying cipher is either a CFB cipher or an
            OFB one the last block may not be a multiple of the block size.
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedBlockCipher.#ctor">
            constructor for subclasses
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IBlockCipherMode)">
             Create a buffered block cipher without padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             false otherwise.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedBlockCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedBlockCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.CipherKeyGenerator">
            The base class for symmetric, or secret, cipher key generators.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.CipherKeyGenerator.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             initialise the key generator.
            
             @param param the parameters to be used for key generation
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.CipherKeyGenerator.GenerateKey">
             Generate a secret key.
            
             @return a byte array containing the key value.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.DataLengthException">
            <summary>This exception is thrown if a buffer that is meant to have output copied into it turns out to be too
            short, or if we've been given insufficient input.</summary>
            <remarks>
            In general this exception will get thrown rather than an <see cref="T:System.IndexOutOfRangeException"/>.
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2bDigest">
            Implementation of the cryptographic hash function Blake2b.
            <p/>
            Blake2b offers a built-in keying mechanism to be used directly
            for authentication ("Prefix-MAC") rather than a HMAC construction.
            <p/>
            Blake2b offers a built-in support for a salt for randomized hashing
            and a personal string for defining a unique hash function for each application.
            <p/>
            BLAKE2b is optimized for 64-bit platforms and produces digests of any size
            between 1 and 64 bytes.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2bDigest.#ctor(System.Int32)">
             Basic sized constructor - size in bits.
            
             @param digestSize size of the digest in bits
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2bDigest.#ctor(System.Byte[])">
             Blake2b for authentication ("Prefix-MAC mode").
             After calling the doFinal() method, the key will
             remain to be used for further computations of
             this instance.
             The key can be overwritten using the clearKey() method.
            
             @param key A key up to 64 bytes or null
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2bDigest.#ctor(System.Byte[],System.Int32,System.Byte[],System.Byte[])">
             Blake2b with key, required digest length (in bytes), salt and personalization.
             After calling the doFinal() method, the key, the salt and the personal string
             will remain and might be used for further computations with this instance.
             The key can be overwritten using the clearKey() method, the salt (pepper)
             can be overwritten using the clearSalt() method.
            
             @param key             A key up to 64 bytes or null
             @param digestLength    from 1 up to 64 bytes
             @param salt            16 bytes or null
             @param personalization 16 bytes or null
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2bDigest.Update(System.Byte)">
             update the message digest with a single byte.
            
             @param b the input byte to be entered.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2bDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             update the message digest with a block of bytes.
            
             @param message the byte array containing the data.
             @param offset  the offset into the byte array where the data starts.
             @param len     the length of the data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2bDigest.DoFinal(System.Byte[],System.Int32)">
             close the digest, producing the final digest value. The doFinal
             call leaves the digest reset.
             Key, salt and personal string remain.
            
             @param out       the array the digest is to be copied into.
             @param outOffset the offset into the out array the digest is to start at.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2bDigest.Reset">
            Reset the digest back to it's initial state.
            The key, the salt and the personal string will
            remain for further computations.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2bDigest.AlgorithmName">
             return the algorithm name
            
             @return the algorithm name
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2bDigest.GetDigestSize">
             return the size, in bytes, of the digest produced by this message digest.
            
             @return the size, in bytes, of the digest produced by this message digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2bDigest.GetByteLength">
             Return the size in bytes of the internal buffer the digest applies it's compression
             function to.
            
             @return byte length of the digests internal buffer.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2bDigest.ClearKey">
            Overwrite the key
            if it is no longer used (zeroization)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2bDigest.ClearSalt">
            Overwrite the salt (pepper) if it
            is secret and no longer used (zeroization)
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest">
            Implementation of the cryptographic hash function BLAKE2s.
            <p/>
            BLAKE2s offers a built-in keying mechanism to be used directly
            for authentication ("Prefix-MAC") rather than a HMAC construction.
            <p/>
            BLAKE2s offers a built-in support for a salt for randomized hashing
            and a personal string for defining a unique hash function for each application.
            <p/>
            BLAKE2s is optimized for 32-bit platforms and produces digests of any size
            between 1 and 32 bytes.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.blake2s_IV">
             BLAKE2s Initialization Vector
            
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.blake2s_sigma">
             Message word permutations
            
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.buffer">
            Whenever this buffer overflows, it will be processed in the Compress()
            function. For performance issues, long messages will not use this buffer.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.bufferPos">
             Position of last inserted byte
            
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.internalState">
             Internal state, in the BLAKE2 paper it is called v
            
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.chainValue">
             State vector, in the BLAKE2 paper it is called h
            
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.t0">
             holds least significant bits of counter
            
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.t1">
             holds most significant bits of counter
            
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.f0">
             finalization flag, for last block: ~0
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.#ctor">
            BLAKE2s-256 for hashing.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.#ctor(System.Int32)">
             BLAKE2s for hashing.
            
             @param digestBits the desired digest length in bits. Must be a multiple of 8 and less than 256.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.#ctor(System.Byte[])">
             BLAKE2s for authentication ("Prefix-MAC mode").
             <p/>
             After calling the doFinal() method, the key will remain to be used for
             further computations of this instance. The key can be overwritten using
             the clearKey() method.
            
             @param key a key up to 32 bytes or null
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.#ctor(System.Byte[],System.Int32,System.Byte[],System.Byte[])">
             BLAKE2s with key, required digest length, salt and personalization.
             <p/>
             After calling the doFinal() method, the key, the salt and the personal
             string will remain and might be used for further computations with this
             instance. The key can be overwritten using the clearKey() method, the
             salt (pepper) can be overwritten using the clearSalt() method.
            
             @param key             a key up to 32 bytes or null
             @param digestBytes     from 1 up to 32 bytes
             @param salt            8 bytes or null
             @param personalization 8 bytes or null
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.Update(System.Byte)">
             Update the message digest with a single byte.
            
             @param b the input byte to be entered.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             Update the message digest with a block of bytes.
            
             @param message the byte array containing the data.
             @param offset  the offset into the byte array where the data starts.
             @param len     the length of the data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.DoFinal(System.Byte[],System.Int32)">
             Close the digest, producing the final digest value. The doFinal() call
             leaves the digest reset. Key, salt and personal string remain.
            
             @param out       the array the digest is to be copied into.
             @param outOffset the offset into the out array the digest is to start at.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.Reset">
            Reset the digest back to its initial state. The key, the salt and the
            personal string will remain for further computations.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.AlgorithmName">
             Return the algorithm name.
            
             @return the algorithm name
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.GetDigestSize">
             Return the size in bytes of the digest produced by this message digest.
            
             @return the size in bytes of the digest produced by this message digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.GetByteLength">
             Return the size in bytes of the internal buffer the digest applies its
             compression function to.
            
             @return byte length of the digest's internal buffer.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.ClearKey">
            Overwrite the key if it is no longer used (zeroization).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2sDigest.ClearSalt">
            Overwrite the salt (pepper) if it is secret and no longer used
            (zeroization).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest">
            Implementation of the eXtendable Output Function (XOF) BLAKE2xs.
            <p/>
            BLAKE2xs offers a built-in keying mechanism to be used directly
            for authentication ("Prefix-MAC") rather than a HMAC construction.
            <p/>
            BLAKE2xs offers a built-in support for a salt for randomized hashing
            and a personal string for defining a unique hash function for each application.
            <p/>
            BLAKE2xs is optimized for 32-bit platforms and produces digests of any size
            between 1 and 2^16-2 bytes. The length can also be unknown and then the maximum
            length will be 2^32 blocks of 32 bytes.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.UnknownDigestLength">
            Magic number to indicate an unknown length of digest
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.digestLength">
            Expected digest length for the xof. It can be unknown.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.hash">
            Root hash that will take the updates
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.h0">
            Digest of the root hash
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.buf">
            Digest of each round of the XOF
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.bufPos">
            Current position for a round
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.digestPos">
            Overall position of the digest. It is useful when the length is known
            in advance to get last block length.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.blockPos">
            Keep track of the round number to detect the end of the digest after
            2^32 blocks of 32 bytes.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.nodeOffset">
            Current node offset incremented by 1 every round.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.#ctor">
            BLAKE2xs for hashing with unknown digest length
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.#ctor(System.Int32)">
             BLAKE2xs for hashing
            
             @param digestBytes The desired digest length in bytes. Must be above 1 and less than 2^16-1
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.#ctor(System.Int32,System.Byte[])">
             BLAKE2xs with key
            
             @param digestBytes The desired digest length in bytes. Must be above 1 and less than 2^16-1
             @param key         A key up to 32 bytes or null
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.#ctor(System.Int32,System.Byte[],System.Byte[],System.Byte[])">
             BLAKE2xs with key, salt and personalization
            
             @param digestBytes     The desired digest length in bytes. Must be above 1 and less than 2^16-1
             @param key             A key up to 32 bytes or null
             @param salt            8 bytes or null
             @param personalization 8 bytes or null
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.AlgorithmName">
             Return the algorithm name.
            
             @return the algorithm name
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.GetDigestSize">
             Return the size in bytes of the digest produced by this message digest.
            
             @return the size in bytes of the digest produced by this message digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.GetByteLength">
             Return the size in bytes of the internal buffer the digest applies its
             compression function to.
            
             @return byte length of the digest's internal buffer.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.GetUnknownMaxLength">
             Return the maximum size in bytes the digest can produce when the length
             is unknown
            
             @return byte length of the largest digest with unknown length
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.Update(System.Byte)">
             Update the message digest with a single byte.
            
             @param in the input byte to be entered.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             Update the message digest with a block of bytes.
            
             @param in    the byte array containing the data.
             @param inOff the offset into the byte array where the data starts.
             @param len   the length of the data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.Reset">
            Reset the digest back to its initial state. The key, the salt and the
            personal string will remain for further computations.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.DoFinal(System.Byte[],System.Int32)">
             Close the digest, producing the final digest value. The doFinal() call
             leaves the digest reset. Key, salt and personal string remain.
            
             @param out       the array the digest is to be copied into.
             @param outOffset the offset into the out array the digest is to start at.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.OutputFinal(System.Byte[],System.Int32,System.Int32)">
             Close the digest, producing the final digest value. The doFinal() call
             leaves the digest reset. Key, salt, personal string remain.
            
             @param out    output array to write the output bytes to.
             @param outOff offset to start writing the bytes at.
             @param outLen the number of output bytes requested.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake2xsDigest.Output(System.Byte[],System.Int32,System.Int32)">
             Start outputting the results of the final calculation for this digest. Unlike doFinal, this method
             will continue producing output until the Xof is explicitly reset, or signals otherwise.
            
             @param out    output array to write the output bytes to.
             @param outOff offset to start writing the bytes at.
             @param outLen the number of output bytes requested.
             @return the number of bytes written
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.ERR_OUTPUTTING">
            Already outputting error.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.NUMWORDS">
            Number of Words.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.ROUNDS">
            Number of Rounds.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.BLOCKLEN">
            Buffer length.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHUNKLEN">
            Chunk length.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHUNKSTART">
            ChunkStart Flag.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHUNKEND">
            ChunkEnd Flag.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.PARENT">
            Parent Flag.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.ROOT">
            Root Flag.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.KEYEDHASH">
            KeyedHash Flag.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.DERIVECONTEXT">
            DeriveContext Flag.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.DERIVEKEY">
            DeriveKey Flag.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHAINING0">
            Chaining0 State Locations.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHAINING1">
            Chaining1 State Location.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHAINING2">
            Chaining2 State Location.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHAINING3">
            Chaining3 State Location.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHAINING4">
            Chaining4 State Location.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHAINING5">
            Chaining5 State Location.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHAINING6">
            Chaining6 State Location.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHAINING7">
            Chaining7 State Location.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.IV0">
            IV0 State Locations.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.IV1">
            IV1 State Location.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.IV2">
            IV2 State Location.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.IV3">
            IV3 State Location.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.COUNT0">
            Count0 State Location.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.COUNT1">
            Count1 State Location.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.DATALEN">
            DataLen State Location.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.FLAGS">
            Flags State Location.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.SIGMA">
            Message word permutations.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.IV">
            Blake3 Initialization Vector.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theBuffer">
            The byte input/output buffer.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theK">
            The key.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theChaining">
            The chaining value.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theV">
            The state.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theM">
            The message Buffer.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theIndices">
            The indices.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theStack">
            The chainingStack.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theDigestLen">
            The default digestLength.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_outputting">
            Are we outputting?
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_outputAvailable">
            How many more bytes can we output?
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theMode">
            The current mode.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theOutputMode">
            The output mode.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theOutputDataLen">
            The output dataLen.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theCounter">
            The block counter.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theCurrBytes">
            The # of bytes in the current block.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_thePos">
            The position of the next byte in the buffer.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.#ctor(System.Int32)">
            <param name="pDigestSize">the default digest size (in bits)</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest)">
             Constructor.
            
             @param pSource the source digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.Blake3Parameters)">
             Initialise.
            
             @param pParams the parameters.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.AdjustStack">
            Adjust the stack.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.CompressFinalBlock(System.Int32)">
             Compress final block.
            
             @param pDataLen the data length
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.ProcessStack">
            Process the stack.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.Compress">
            Perform compression.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.PerformRound">
            Perform a round.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.AdjustChaining">
            Adjust Chaining after compression.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.MixG(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
             Mix function G.
            
             @param msgIdx the message index
             @param posA   position A in V
             @param posB   position B in V
             @param posC   position C in V
             @param posD   poistion D in V
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.InitIndices">
            initialise the indices.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.PermuteIndices">
            PermuteIndices.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.InitNullKey">
            Initialise null key.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.InitKey(System.Byte[])">
             Initialise key.
            
             @param pKey the keyBytes
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.InitKeyFromContext">
            Initialise key from context.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.InitChunkBlock(System.Int32,System.Boolean)">
             Initialise chunk block.
            
             @param pDataLen the dataLength
             @param pFinal   is this the final chunk?
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.InitParentBlock">
            Initialise parent block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.NextOutputBlock">
            Initialise output block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.IncrementBlockCount">
            IncrementBlockCount.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.ResetBlockCount">
            ResetBlockCount.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Blake3Digest.SetRoot">
            Set root indication.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.CShakeDigest">
            <summary>
            Customizable SHAKE function.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.CShakeDigest.#ctor(System.Int32,System.Byte[],System.Byte[])">
            <summary>
            Base constructor
            </summary>
            <param name="bitLength">bit length of the underlying SHAKE function, 128 or 256.</param>
            <param name="N">the function name string, note this is reserved for use by NIST. Avoid using it if not required.</param>
            <param name="S">the customization string - available for local use.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Dstu7564Digest">
            implementation of Ukrainian DSTU 7564 hash function
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.GeneralDigest">
            base implementation of MD4 family style digest as outlined in
            "Handbook of Applied Cryptography", pages 344 - 347.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Gost3411Digest">
            implementation of GOST R 34.11-94
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Gost3411Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Gost3411Digest.#ctor(System.Byte[])">
            Constructor to allow use of a particular sbox with GOST28147
            @see GOST28147Engine#getSBox(String)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Gost3411Digest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Gost3411Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Gost3411Digest.C2">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.KeccakDigest">
            <summary>
            Implementation of Keccak based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.KeccakDigest.GetByteLength">
             Return the size of block that the compression function is applied to in bytes.
            
             @return internal byte length of a block.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.LongDigest">
            Base class for SHA-384 and SHA-512.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.LongDigest.#ctor">
            Constructor for variable length word
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.LongDigest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.LongDigest)">
            Copy constructor.  We are using copy constructors in place
            of the object.Clone() interface as this interface is not
            supported by J2ME.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.LongDigest.AdjustByteCounts">
            adjust the byte counts so that byteCount2 represents the
            upper long (less 3 bits) word of the byte count.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.MD2Digest">
            implementation of MD2
            as outlined in RFC1319 by B.Kaliski from RSA Laboratories April 1992
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.MD2Digest.AlgorithmName">
             return the algorithm name
            
             @return the algorithm name
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.MD2Digest.DoFinal(System.Byte[],System.Int32)">
             Close the digest, producing the final digest value. The doFinal
             call leaves the digest reset.
            
             @param out the array the digest is to be copied into.
             @param outOff the offset into the out array the digest is to start at.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.MD2Digest.Reset">
            reset the digest back to it's initial state.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.MD2Digest.Update(System.Byte)">
             update the message digest with a single byte.
            
             @param in the input byte to be entered.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.MD2Digest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             update the message digest with a block of bytes.
            
             @param in the byte array containing the data.
             @param inOff the offset into the byte array where the data starts.
             @param len the length of the data.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.MD4Digest">
            implementation of MD4 as RFC 1320 by R. Rivest, MIT Laboratory for
            Computer Science and RSA Data Security, Inc.
            <p>
            <b>NOTE</b>: This algorithm is only included for backwards compatibility
            with legacy applications, it's not secure, don't use it for anything new!</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.MD4Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.MD4Digest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.MD4Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.MD4Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.MD5Digest">
            implementation of MD5 as outlined in "Handbook of Applied Cryptography", pages 346 - 347.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.MD5Digest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.MD5Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.MD5Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.NonMemoableDigest">
            Wrapper removes exposure to the IMemoable interface on an IDigest implementation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.NonMemoableDigest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
             Base constructor.
            
             @param baseDigest underlying digest to use.
             @exception IllegalArgumentException if baseDigest is null
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.ParallelHash">
            <summary>
            ParallelHash - a hash designed  to  support the efficient hashing of very long strings, by taking advantage,
            of the parallelism available in modern processors with an optional XOF mode.
            <para>
            From NIST Special Publication 800-185 - SHA-3 Derived Functions:cSHAKE, KMAC, TupleHash and ParallelHash
            </para>
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.ParallelHash.#ctor(System.Int32,System.Byte[],System.Int32)">
             Base constructor.
            
             @param bitLength bit length of the underlying SHAKE function, 128 or 256.
             @param S the customization string - available for local use.
             @param B the blocksize (in bytes) for hashing.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD128Digest">
            implementation of RipeMD128
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD128Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD128Digest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD128Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD128Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD160Digest">
            implementation of RipeMD see,
            http://www.esat.kuleuven.ac.be/~bosselae/ripemd160.html
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD160Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD160Digest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD160Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD160Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD256Digest">
            <remarks>
            <p>Implementation of RipeMD256.</p>
            <p><b>Note:</b> this algorithm offers the same level of security as RipeMD128.</p>
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD256Digest.#ctor">
            <summary> Standard constructor</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD256Digest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD256Digest)">
            <summary> Copy constructor.  This will copy the state of the provided
            message digest.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD256Digest.Reset">
            <summary> reset the chaining variables to the IV values.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD320Digest">
            <remarks>
            <p>Implementation of RipeMD 320.</p>
            <p><b>Note:</b> this algorithm offers the same level of security as RipeMD160.</p>
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD320Digest.#ctor">
            <summary> Standard constructor</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD320Digest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD320Digest)">
            <summary> Copy constructor.  This will copy the state of the provided
            message digest.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.RipeMD320Digest.Reset">
            <summary> reset the chaining variables to the IV values.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha1Digest">
             implementation of SHA-1 as outlined in "Handbook of Applied Cryptography", pages 346 - 349.
            
             It is interesting to ponder why the, apart from the extra IV, the other difference here from MD5
             is the "endianness" of the word processing!
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha1Digest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha1Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha1Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha224Digest">
            SHA-224 as described in RFC 3874
            <pre>
                    block  word  digest
            SHA-1   512    32    160
            SHA-224 512    32    224
            SHA-256 512    32    256
            SHA-384 1024   64    384
            SHA-512 1024   64    512
            </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha224Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha224Digest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha224Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha224Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha256Digest">
             Draft FIPS 180-2 implementation of SHA-256. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha256Digest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha256Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha256Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha384Digest">
             Draft FIPS 180-2 implementation of SHA-384. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha384Digest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha384Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha384Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha3Digest">
            <summary>
            Implementation of SHA-3 based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha512Digest">
             Draft FIPS 180-2 implementation of SHA-512. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha512Digest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha512Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha512Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha512tDigest">
            FIPS 180-4 implementation of SHA-512/t
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha512tDigest.#ctor(System.Int32)">
            Standard constructor
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha512tDigest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha512tDigest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.Sha512tDigest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.ShakeDigest">
            <summary>
            Implementation of SHAKE based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.ShortenedDigest">
            Wrapper class that reduces the output length of a particular digest to
            only the first n bytes of the digest function.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.ShortenedDigest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,System.Int32)">
             Base constructor.
            
             @param baseDigest underlying digest to use.
             @param length length in bytes of the output of doFinal.
             @exception ArgumentException if baseDigest is null, or length is greater than baseDigest.GetDigestSize().
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinDigest">
            <summary>
            Implementation of the Skein parameterised hash function in 256, 512 and 1024 bit block sizes,
            based on the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine">Threefish</see> tweakable block cipher.
            </summary>
            <remarks>
            This is the 1.3 version of Skein defined in the Skein hash function submission to the NIST SHA-3
            competition in October 2010.
            <p/>
            Skein was designed by Niels Ferguson - Stefan Lucks - Bruce Schneier - Doug Whiting - Mihir
            Bellare - Tadayoshi Kohno - Jon Callas - Jesse Walker.
            </remarks>
            <seealso cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine"/>
            <seealso cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters"/>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinDigest.SKEIN_256">
            <summary>
            256 bit block size - Skein-256
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinDigest.SKEIN_512">
            <summary>
            512 bit block size - Skein-512
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinDigest.SKEIN_1024">
            <summary>
            1024 bit block size - Skein-1024
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinDigest.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a Skein digest with an internal state size and output size.
            </summary>
            <param name="stateSizeBits">the internal state size in bits - one of <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinDigest.SKEIN_256"/> <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinDigest.SKEIN_512"/> or
                                  <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinDigest.SKEIN_1024"/>.</param>
            <param name="digestSizeBits">the output/digest size to produce in bits, which must be an integral number of
                                 bytes.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinDigest.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters)">
            <summary>
            Optionally initialises the Skein digest with the provided parameters.
            </summary>
            See <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters"></see> for details on the parameterisation of the Skein hash function.
            <param name="parameters">the parameters to apply to this engine, or <code>null</code> to use no parameters.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine">
            <summary>
            Implementation of the Skein family of parameterised hash functions in 256, 512 and 1024 bit block
            sizes, based on the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine">Threefish</see> tweakable block cipher.
            </summary>
            <remarks>
            This is the 1.3 version of Skein defined in the Skein hash function submission to the NIST SHA-3
            competition in October 2010.
            <p/>
            Skein was designed by Niels Ferguson - Stefan Lucks - Bruce Schneier - Doug Whiting - Mihir
            Bellare - Tadayoshi Kohno - Jon Callas - Jesse Walker.
            <p/>
            This implementation is the basis for <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinDigest"/> and <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.SkeinMac"/>, implementing the
            parameter based configuration system that allows Skein to be adapted to multiple applications. <br/>
            Initialising the engine with <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters"/> allows standard and arbitrary parameters to
            be applied during the Skein hash function.
            <p/>
            Implemented:
            <ul>
            <li>256, 512 and 1024 bit internal states.</li>
            <li>Full 96 bit input length.</li>
            <li>Parameters defined in the Skein specification, and arbitrary other pre and post message
            parameters.</li>
            <li>Arbitrary output size in 1 byte intervals.</li>
            </ul>
            <p/>
            Not implemented:
            <ul>
            <li>Sub-byte length input (bit padding).</li>
            <li>Tree hashing.</li>
            </ul>
            </remarks>
            <seealso cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters"/>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.SKEIN_256">
            <summary>
            256 bit block size - Skein-256
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.SKEIN_512">
            <summary>
            512 bit block size - Skein-512
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.SKEIN_1024">
            <summary>
            1024 bit block size - Skein-1024
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.PARAM_TYPE_KEY">
            The parameter type for the Skein key.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.PARAM_TYPE_CONFIG">
            The parameter type for the Skein configuration block.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.PARAM_TYPE_MESSAGE">
            The parameter type for the message.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.PARAM_TYPE_OUTPUT">
            The parameter type for the output transformation.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.InitialStates">
            Precalculated UBI(CFG) states for common state/output combinations without key or other
            pre-message params.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.UbiTweak.LOW_RANGE">
            Point at which position might overflow long, so switch to add with carry logic
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.UbiTweak.T1_FINAL">
            Bit 127 = final
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.UbiTweak.T1_FIRST">
            Bit 126 = first
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.UbiTweak.tweak">
            UBI uses a 128 bit tweak
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.UbiTweak.extendedPosition">
            Whether 64 bit position exceeded
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.UbiTweak.AdvancePosition(System.Int32)">
            Advances the position in the tweak by the specified value.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.UBI">
            The Unique Block Iteration chaining mode.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.UBI.currentBlock">
            Buffer for the current block of message data
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.UBI.currentOffset">
            Offset into the current message block
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.UBI.message">
            Buffer for message words for feedback into encrypted block
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.threefish">
            Underlying Threefish tweakable block cipher
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.outputSizeBytes">
            Size of the digest output, in bytes
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.chain">
            The current chaining/state value
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.initialState">
            The initial state value
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.key">
            The (optional) key parameter
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.preMessageParameters">
            Parameters to apply prior to the message
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.postMessageParameters">
            Parameters to apply after the message, but prior to output
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.ubi">
            The current UBI operation
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.singleByte">
            Buffer for single byte update method
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a Skein digest with an internal state size and output size.
            </summary>
            <param name="blockSizeBits">the internal state size in bits - one of <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.SKEIN_256"/> <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.SKEIN_512"/> or
                                  <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.SKEIN_1024"/>.</param>
            <param name="outputSizeBits">the output/digest size to produce in bits, which must be an integral number of
                                 bytes.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine)">
            <summary>
            Creates a SkeinEngine as an exact copy of an existing instance.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters)">
            <summary>
            Initialises the Skein engine with the provided parameters. See <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters"/> for
            details on the parameterisation of the Skein hash function.
            </summary>
            <param name="parameters">the parameters to apply to this engine, or <code>null</code> to use no parameters.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.CreateInitialState">
            Calculate the initial (pre message block) chaining state.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine.Reset">
            <summary>
            Reset the engine to the initial state (with the key and any pre-message parameters , ready to
            accept message input.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SM3Digest">
            <summary>
            Implementation of Chinese SM3 digest as described at
            http://tools.ietf.org/html/draft-shen-sm3-hash-00
            and at .... ( Chinese PDF )
            </summary>
            <remarks>
            The specification says "process a bit stream",
            but this is written to process bytes in blocks of 4,
            meaning this will process 32-bit word groups.
            But so do also most other digest specifications,
            including the SHA-256 which was a origin for
            this specification.
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SM3Digest.#ctor">
            <summary>
            Standard constructor
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SM3Digest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SM3Digest)">
            <summary>
            Copy constructor.  This will copy the state of the provided
            message digest.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SM3Digest.Reset">
            <summary>
            reset the chaining variables
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.TigerDigest">
            implementation of Tiger based on:
            <a href="http://www.cs.technion.ac.il/~biham/Reports/Tiger">
             http://www.cs.technion.ac.il/~biham/Reports/Tiger</a>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.TigerDigest.#ctor">
            Standard constructor
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.TigerDigest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.TigerDigest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.TigerDigest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.TupleHash">
            <summary>
            TupleHash - a hash designed  to  simply  hash  a  tuple  of  input  strings,  any  or  all  of  which  may  be  empty  strings,
            in  an  unambiguous way with an optional XOF mode.
            <para>
            From NIST Special Publication 800-185 - SHA-3 Derived Functions:cSHAKE, KMAC, TupleHash and ParallelHash
            </para>
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.TupleHash.#ctor(System.Int32,System.Byte[])">
             Base constructor.
            
             @param bitLength bit length of the underlying SHAKE function, 128 or 256.
             @param S         the customization string - available for local use.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest">
            Implementation of WhirlpoolDigest, based on Java source published by Barreto and Rijmen.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest)">
            Copy constructor. This will copy the state of the provided message digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest.Reset">
            Reset the chaining variables
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.EC.CustomNamedCurves">
            <summary>Elliptic curve registry for various customized curve implementations.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetByName(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetByOid(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetByOidLazy(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetName(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetOid(System.String)">
            <summary>Look up the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.EC.CustomNamedCurves.Names">
            <summary>Enumerate the available curve names in this registry.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding">
            ISO 9796-1 padding. Note in the light of recent results you should
            only use this with RSA (rather than the "simpler" Rabin keys) and you
            should never use it with anything other than a hash (ie. even if the
            message is small don't sign the message, sign it's hash) or some "random"
            value. See your favorite search engine for details.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.GetInputBlockSize">
            return the input block size. The largest message we can process
            is (key_size_in_bits + 3)/16, which in our world comes to
            key_size_in_bytes / 2.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.GetOutputBlockSize">
            return the maximum possible size for the output.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.SetPadBits(System.Int32)">
            set the number of bits in the next message to be treated as
            pad bits.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.GetPadBits">
            retrieve the number of pad bits in the last decoded message.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block is not a valid ISO 9796 bit string
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.OaepEncoding">
            Optimal Asymmetric Encryption Padding (OAEP) - see PKCS 1 V 2.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.OaepEncoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block turns out to
            be badly formatted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.OaepEncoding.MaskGeneratorFunction1(System.Byte[],System.Int32,System.Int32,System.Int32)">
            mask generator function, as described in PKCS1v2.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding">
            this does your basic Pkcs 1 v1.5 padding - whether or not you should be using this
            depends on your application - see Pkcs1 Version 2 for details.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.StrictLengthEnabledProperty">
            some providers fail to include the leading zero in PKCS1 encoded blocks. If you need to
            work with one of these set the system property Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs1.Strict to false.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.StrictLengthEnabled">
            The same effect can be achieved by setting the static property directly
            <p>
            The static property is checked during construction of the encoding object, it is set to
            true by default.
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher)">
             Basic constructor.
            
             @param cipher
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,System.Int32)">
            Constructor for decryption with a fixed plaintext length.
            
            @param cipher The cipher to use for cryptographic operation.
            @param pLen Length of the expected plaintext.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,System.Byte[])">
            Constructor for decryption with a fixed plaintext length and a fallback
            value that is returned, if the padding is incorrect.
            
            @param cipher
                       The cipher to use for cryptographic operation.
            @param fallback
                       The fallback value, we don't to a arraycopy here.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.CheckPkcs1Encoding(System.Byte[],System.Int32)">
            Checks if the argument is a correctly PKCS#1.5 encoded Plaintext
            for encryption.
            
            @param encoded The Plaintext.
            @param pLen Expected length of the plaintext.
            @return Either 0, if the encoding is correct, or -1, if it is incorrect.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.DecodeBlockOrRandom(System.Byte[],System.Int32,System.Int32)">
            Decode PKCS#1.5 encoding, and return a random value if the padding is not correct.
            
            @param in The encrypted block.
            @param inOff Offset in the encrypted block.
            @param inLen Length of the encrypted block.
            @param pLen Length of the desired output.
            @return The plaintext without padding, or a random value if the padding was incorrect.
            @throws InvalidCipherTextException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block is not in Pkcs1 format.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.AesEngine">
             an implementation of the AES (Rijndael), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor, they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations, 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each, for a total of 2Kbytes,
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first.
            
             The slowest version uses no static tables at all and computes the values in each round.
             </p>
             <p>
             This file contains the middle performance version with 2Kbytes of static tables for round precomputation.
             </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.AesEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.AesEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.AesEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.AesLightEngine">
             an implementation of the AES (Rijndael), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor, they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations, 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each, for a total of 2Kbytes,
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first
            
             The slowest version uses no static tables at all and computes the values
             in each round.
             </p>
             <p>
             This file contains the slowest performance version with no static tables
             for round precomputation, but it has the smallest foot print.
             </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.AesLightEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.AesLightEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.AesLightEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.AesWrapEngine">
            <remarks>
            An implementation of the AES Key Wrapper from the NIST Key Wrap Specification.
            <p/>
            For further details see: <a href="http://csrc.nist.gov/encryption/kms/key-wrap.pdf">http://csrc.nist.gov/encryption/kms/key-wrap.pdf</a>.
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.AriaEngine">
            RFC 5794.
            
            ARIA is a 128-bit block cipher with 128-, 192-, and 256-bit keys.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.BlowfishEngine">
            A class that provides Blowfish key encryption operations,
            such as encoding data and generating keys.
            All the algorithms herein are from Applied Cryptography
            and implement a simplified cryptography interface.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.BlowfishEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Blowfish cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.BlowfishEngine.ProcessTable(System.UInt32,System.UInt32,System.UInt32[])">
            apply the encryption cycle to each value pair in the table.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.CamelliaEngine">
            Camellia - based on RFC 3713.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.CamelliaLightEngine">
            Camellia - based on RFC 3713, smaller implementation, about half the size of CamelliaEngine.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.CamelliaWrapEngine">
            <remarks>
            An implementation of the Camellia key wrapper based on RFC 3657/RFC 3394.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc3657.txt">http://www.ietf.org/rfc/rfc3657.txt</a>.
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Cast5Engine">
             A class that provides CAST key encryption operations,
             such as encoding data and generating keys.
            
             All the algorithms herein are from the Internet RFC's
            
             RFC2144 - Cast5 (64bit block, 40-128bit key)
             RFC2612 - CAST6 (128bit block, 128-256bit key)
            
             and implement a simplified cryptography interface.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Cast5Engine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a CAST cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Cast5Engine.F1(System.UInt32,System.UInt32,System.Int32)">
             The first of the three processing functions for the
             encryption and decryption.
            
             @param D            the input to be processed
             @param Kmi        the mask to be used from Km[n]
             @param Kri        the rotation value to be used
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Cast5Engine.F2(System.UInt32,System.UInt32,System.Int32)">
             The second of the three processing functions for the
             encryption and decryption.
            
             @param D            the input to be processed
             @param Kmi        the mask to be used from Km[n]
             @param Kri        the rotation value to be used
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Cast5Engine.F3(System.UInt32,System.UInt32,System.Int32)">
             The third of the three processing functions for the
             encryption and decryption.
            
             @param D            the input to be processed
             @param Kmi        the mask to be used from Km[n]
             @param Kri        the rotation value to be used
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Cast5Engine.CAST_Encipher(System.UInt32,System.UInt32,System.UInt32[])">
             Does the 16 rounds to encrypt the block.
            
             @param L0    the LH-32bits of the plaintext block
             @param R0    the RH-32bits of the plaintext block
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Cast6Engine">
             A class that provides CAST6 key encryption operations,
             such as encoding data and generating keys.
            
             All the algorithms herein are from the Internet RFC
            
             RFC2612 - CAST6 (128bit block, 128-256bit key)
            
             and implement a simplified cryptography interface.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Cast6Engine.CAST_Encipher(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32[])">
             Does the 12 quad rounds rounds to encrypt the block.
            
             @param A    the 00-31  bits of the plaintext block
             @param B    the 32-63  bits of the plaintext block
             @param C    the 64-95  bits of the plaintext block
             @param D    the 96-127 bits of the plaintext block
             @param result the resulting ciphertext
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Cast6Engine.CAST_Decipher(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32[])">
             Does the 12 quad rounds rounds to decrypt the block.
            
             @param A    the 00-31  bits of the ciphertext block
             @param B    the 32-63  bits of the ciphertext block
             @param C    the 64-95  bits of the ciphertext block
             @param D    the 96-127 bits of the ciphertext block
             @param result the resulting plaintext
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ChaCha7539Engine">
            <summary>
            Implementation of Daniel J. Bernstein's ChaCha stream cipher.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ChaCha7539Engine.#ctor">
            <summary>
            Creates a 20 rounds ChaCha engine.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ChaChaEngine">
            <summary>
            Implementation of Daniel J. Bernstein's ChaCha stream cipher.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ChaChaEngine.#ctor">
            <summary>
            Creates a 20 rounds ChaCha engine.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ChaChaEngine.#ctor(System.Int32)">
            <summary>
            Creates a ChaCha engine with a specific number of rounds.
            </summary>
            <param name="rounds">the number of rounds (must be an even number).</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEdeEngine">
            <remarks>A class that provides a basic DESede (or Triple DES) engine.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEdeEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a DESede cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine">
                * Wrap keys according to
                * <a href="http://www.ietf.org/internet-drafts/draft-ietf-smime-key-wrap-01.txt">
                * draft-ietf-smime-key-wrap-01.txt</a>.
                * <p>
                * Note:
                * <ul>
                * <li>this is based on a draft, and as such is subject to change - don't use this class for anything requiring long term storage.</li>
                * <li>if you are using this to wrap triple-des keys you need to set the
                * parity bits on the key and, if it's a two-key triple-des key, pad it
                * yourself.</li>
                * </ul>
            	* </p>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.engine">
            Field engine 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.param">
            Field param 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.paramPlusIV">
            Field paramPlusIV 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.iv">
            Field iv 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.forWrapping">
            Field forWrapping 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.IV2">
            Field IV2           
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Method init
            
             @param forWrapping
             @param param
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.AlgorithmName">
             Method GetAlgorithmName
            
             @return
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.Wrap(System.Byte[],System.Int32,System.Int32)">
             Method wrap
            
             @param in
             @param inOff
             @param inLen
             @return
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.Unwrap(System.Byte[],System.Int32,System.Int32)">
             Method unwrap
            
             @param in
             @param inOff
             @param inLen
             @return
             @throws InvalidCipherTextException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.CalculateCmsKeyChecksum(System.Byte[])">
             Some key wrap algorithms make use of the Key Checksum defined
             in CMS [CMS-Algorithms]. This is used to provide an integrity
             check value for the key being wrapped. The algorithm is
            
             - Compute the 20 octet SHA-1 hash on the key being wrapped.
             - Use the first 8 octets of this hash as the checksum value.
            
             @param key
             @return
             @throws Exception
             @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.CheckCmsKeyChecksum(System.Byte[],System.Byte[])">
            @param key
            @param checksum
            @return
            @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEngine">
            <remarks>A class that provides a basic DES engine.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a DES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEngine.bytebit">
            what follows is mainly taken from "Applied Cryptography", by
            Bruce Schneier, however it also bears great resemblance to Richard
            Outerbridge's D3DES...
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.DesEngine.GenerateWorkingKey(System.Boolean,System.Byte[])">
             Generate an integer based working key based on our secret key
             and what we processing we are planning to do.
            
             Acknowledgements for this routine go to James Gillogly and Phil Karn.
                     (whoever, and wherever they are!).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Dstu7624Engine">
            implementation of DSTU 7624 (Kalyna)
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ElGamalEngine">
            this does your basic ElGamal algorithm.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ElGamalEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the ElGamal engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary ElGamal key parameters.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ElGamalEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For ElGamal this is always one byte less than the size of P on
             encryption, and twice the length as the size of P on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ElGamalEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For ElGamal this is always one byte less than the size of P on
             decryption, and twice the length as the size of P on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ElGamalEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic ElGamal algorithm.
            
             @param in the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param length the length of the data to be processed.
             @return the result of the ElGamal process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Gost28147Engine">
            implementation of GOST 28147-89
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Gost28147Engine.#ctor">
            standard constructor.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Gost28147Engine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an Gost28147 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Gost28147Engine.GetSBox(System.String)">
            Return the S-Box associated with SBoxName
            @param sBoxName name of the S-Box
            @return byte array representing the S-Box
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Grain128AeadEngine.STATE_SIZE">
            Constants
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Grain128AeadEngine.workingKey">
            Variables to hold the state of the engine during encryption and
            decryption
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Grain128AeadEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialize a Grain-128AEAD cipher.
            
             @param forEncryption Whether or not we are for encryption.
             @param param        The parameters required to set up the cipher.
             @throws ArgumentException If the params argument is inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Grain128AeadEngine.InitGrain">
            320 clocks initialization phase.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Grain128AeadEngine.GetOutputNFSR">
             Get output from non-linear function g(x).
            
             @return Output from NFSR.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Grain128AeadEngine.GetOutputLFSR">
             Get output from linear function f(x).
            
             @return Output from LFSR.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Grain128AeadEngine.GetOutput">
             Get output from output function h(x).
            
             @return y_t.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Grain128AeadEngine.Shift(System.UInt32[],System.UInt32)">
             Shift array 1 bit and add val to index.Length - 1.
            
             @param array The array to shift.
             @param val   The value to shift in.
             @return The shifted array with val added to index.Length - 1.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Grain128AeadEngine.SetKey(System.Byte[],System.Byte[])">
             Set keys, reset cipher.
            
             @param keyBytes The key.
             @param ivBytes  The IV.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.HC128Engine">
             HC-128 is a software-efficient stream cipher created by Hongjun Wu. It
             generates keystream from a 128-bit secret key and a 128-bit initialization
             vector.
             <p>
             http://www.ecrypt.eu.org/stream/p3ciphers/hc/hc128_p3.pdf
             </p><p>
             It is a third phase candidate in the eStream contest, and is patent-free.
             No attacks are known as of today (April 2007). See
            
             http://www.ecrypt.eu.org/stream/hcp3.html
             </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.HC128Engine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise a HC-128 cipher.
            
             @param forEncryption whether or not we are for encryption. Irrelevant, as
                                  encryption and decryption are the same.
             @param params        the parameters required to set up the cipher.
             @throws ArgumentException if the params argument is
                                              inappropriate (ie. the key is not 128 bit long).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.HC256Engine">
            HC-256 is a software-efficient stream cipher created by Hongjun Wu. It 
            generates keystream from a 256-bit secret key and a 256-bit initialization 
            vector.
            <p>
            http://www.ecrypt.eu.org/stream/p3ciphers/hc/hc256_p3.pdf
            </p><p>
            Its brother, HC-128, is a third phase candidate in the eStream contest.
            The algorithm is patent-free. No attacks are known as of today (April 2007). 
            See
            
            http://www.ecrypt.eu.org/stream/hcp3.html
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.HC256Engine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise a HC-256 cipher.
            
             @param forEncryption whether or not we are for encryption. Irrelevant, as
                                  encryption and decryption are the same.
             @param params        the parameters required to set up the cipher.
             @throws ArgumentException if the params argument is
                                              inappropriate (ie. the key is not 256 bit long).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.IdeaEngine">
            A class that provides a basic International Data Encryption Algorithm (IDEA) engine.
            <p>
            This implementation is based on the "HOWTO: INTERNATIONAL DATA ENCRYPTION ALGORITHM"
            implementation summary by Fauzan Mirza (F.U.Mirza@sheffield.ac.uk). (barring 1 typo at the
            end of the MulInv function!).
            </p>
            <p>
            It can be found at ftp://ftp.funet.fi/pub/crypt/cryptography/symmetric/idea/
            </p>
            <p>
            Note: This algorithm was patented in the USA, Japan and Europe. These patents expired in 2011/2012.
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.IdeaEngine.#ctor">
            standard constructor.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.IdeaEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an IDEA cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.IdeaEngine.Mul(System.Int32,System.Int32)">
             return x = x * y where the multiplication is done modulo
             65537 (0x10001) (as defined in the IDEA specification) and
             a zero input is taken to be 65536 (0x10000).
            
             @param x the x value
             @param y the y value
             @return x = x * y
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.IdeaEngine.ExpandKey(System.Byte[])">
            The following function is used to expand the user key to the encryption
            subkey. The first 16 bytes are the user key, and the rest of the subkey
            is calculated by rotating the previous 16 bytes by 25 bits to the left,
            and so on until the subkey is completed.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.IdeaEngine.MulInv(System.Int32)">
            This function computes multiplicative inverse using Euclid's Greatest
            Common Divisor algorithm. Zero and one are self inverse.
            <p>
            i.e. x * MulInv(x) == 1 (modulo BASE)
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.IdeaEngine.AddInv(System.Int32)">
            Return the additive inverse of x.
            <p>
            i.e. x + AddInv(x) == 0
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.IdeaEngine.InvertKey(System.Int32[])">
            The function to invert the encryption subkey to the decryption subkey.
            It also involves the multiplicative inverse and the additive inverse functions.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.IesEngine">
            support class for constructing intergrated encryption ciphers
            for doing basic message exchanges on top of key agreement ciphers
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.IesEngine.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBasicAgreement,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDerivationFunction,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IMac)">
             set up for use with stream mode, where the key derivation function
             is used to provide a stream of bytes to xor with the message.
            
             @param agree the key agreement used as the basis for the encryption
             @param kdf the key derivation function used for byte generation
             @param mac the message authentication code generator for the message
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.IesEngine.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBasicAgreement,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDerivationFunction,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IMac,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.BufferedBlockCipher)">
             set up for use in conjunction with a block cipher to handle the
             message.
            
             @param agree the key agreement used as the basis for the encryption
             @param kdf the key derivation function used for byte generation
             @param mac the message authentication code generator for the message
             @param cipher the cipher to used for encrypting the message
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.IesEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the encryptor.
            
             @param forEncryption whether or not this is encryption/decryption.
             @param privParam our private key parameters
             @param pubParam the recipient's/sender's public key parameters
             @param param encoding and derivation parameters.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.IsaacEngine">
            Implementation of Bob Jenkin's ISAAC (Indirection Shift Accumulate Add and Count).
            see: http://www.burtleburtle.net/bob/rand/isaacafa.html
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.IsaacEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an ISAAC cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine">
            NaccacheStern Engine. For details on this cipher, please see
            http://www.gemplus.com/smart/rd/publications/pdf/NS98pkcs.pdf
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Initializes this algorithm. Must be called before all other Functions.
            
             @see org.bouncycastle.crypto.AsymmetricBlockCipher#init(bool,
                  org.bouncycastle.crypto.CipherParameters)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.GetInputBlockSize">
             Returns the input block size of this algorithm.
            
             @see org.bouncycastle.crypto.AsymmetricBlockCipher#GetInputBlockSize()
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.GetOutputBlockSize">
             Returns the output block size of this algorithm.
            
             @see org.bouncycastle.crypto.AsymmetricBlockCipher#GetOutputBlockSize()
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single Block using the Naccache-Stern algorithm.
            
             @see org.bouncycastle.crypto.AsymmetricBlockCipher#ProcessBlock(byte[],
                  int, int)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.Encrypt(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
             Encrypts a BigInteger aka Plaintext with the public key.
            
             @param plain
                        The BigInteger to encrypt
             @return The byte[] representation of the encrypted BigInteger (i.e.
                     crypted.toByteArray())
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.AddCryptedBlocks(System.Byte[],System.Byte[])">
             Adds the contents of two encrypted blocks mod sigma
            
             @param block1
                        the first encrypted block
             @param block2
                        the second encrypted block
             @return encrypt((block1 + block2) mod sigma)
             @throws InvalidCipherTextException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.ProcessData(System.Byte[])">
             Convenience Method for data exchange with the cipher.
            
             Determines blocksize and splits data to blocksize.
            
             @param data the data to be processed
             @return the data after it went through the NaccacheSternEngine.
             @throws InvalidCipherTextException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.ChineseRemainder(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger},System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger})">
             Computes the integer x that is expressed through the given primes and the
             congruences with the chinese remainder theorem (CRT).
            
             @param congruences
                        the congruences c_i
             @param primes
                        the primes p_i
             @return an integer x for that x % p_i == c_i
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.NoekeonEngine">
            A Noekeon engine, using direct-key mode.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.NoekeonEngine.#ctor">
            Create an instance of the Noekeon encryption algorithm
            and set some defaults
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.NoekeonEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC2Engine">
            an implementation of RC2 as described in RFC 2268
                 "A Description of the RC2(r) Encryption Algorithm" R. Rivest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC2Engine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC2 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC2Engine.RotateWordLeft(System.Int32,System.Int32)">
            return the result rotating the 16 bit number in x left by y
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC2WrapEngine">
            Wrap keys according to RFC 3217 - RC2 mechanism
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.engine">
            Field engine 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.parameters">
            Field param 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.paramPlusIV">
            Field paramPlusIV 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.iv">
            Field iv 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.forWrapping">
            Field forWrapping 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.IV2">
            Field IV2           
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Method init
            
             @param forWrapping
             @param param
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.AlgorithmName">
             Method GetAlgorithmName
            
             @return
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.Wrap(System.Byte[],System.Int32,System.Int32)">
             Method wrap
            
             @param in
             @param inOff
             @param inLen
             @return
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.Unwrap(System.Byte[],System.Int32,System.Int32)">
             Method unwrap
            
             @param in
             @param inOff
             @param inLen
             @return
             @throws InvalidCipherTextException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.CalculateCmsKeyChecksum(System.Byte[])">
             Some key wrap algorithms make use of the Key Checksum defined
             in CMS [CMS-Algorithms]. This is used to provide an integrity
             check value for the key being wrapped. The algorithm is
            
             - Compute the 20 octet SHA-1 hash on the key being wrapped.
             - Use the first 8 octets of this hash as the checksum value.
            
             @param key
             @return
             @throws Exception
             @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.CheckCmsKeyChecksum(System.Byte[],System.Byte[])">
            @param key
            @param checksum
            @return
            @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC4Engine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC4 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC532Engine">
            The specification for RC5 came from the <code>RC5 Encryption Algorithm</code>
            publication in RSA CryptoBytes, Spring of 1995.
            <em>http://www.rsasecurity.com/rsalabs/cryptobytes</em>.
            <p>
            This implementation has a word size of 32 bits.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC532Engine.#ctor">
            Create an instance of the RC5 encryption algorithm
            and set some defaults
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC532Engine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC5-32 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC532Engine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC564Engine">
            The specification for RC5 came from the <code>RC5 Encryption Algorithm</code>
            publication in RSA CryptoBytes, Spring of 1995.
            <em>http://www.rsasecurity.com/rsalabs/cryptobytes</em>.
            <p>
            This implementation is set to work with a 64 bit word size.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC564Engine.#ctor">
            Create an instance of the RC5 encryption algorithm
            and set some defaults
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC564Engine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC5-64 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC564Engine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC6Engine">
            An RC6 engine.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC6Engine.#ctor">
            Create an instance of the RC6 encryption algorithm
            and set some defaults
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC6Engine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC5-32 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RC6Engine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param inKey the key to be used
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Rfc3211WrapEngine">
            an implementation of the RFC 3211 Key Wrap
            Specification.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Rfc3394WrapEngine">
            <remarks>
            An implementation of the AES Key Wrapper from the NIST Key Wrap
            Specification as described in RFC 3394.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc3394.txt">http://www.ietf.org/rfc/rfc3394.txt</a>
            and  <a href="http://csrc.nist.gov/encryption/kms/key-wrap.pdf">http://csrc.nist.gov/encryption/kms/key-wrap.pdf</a>.
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RijndaelEngine">
            an implementation of Rijndael, based on the documentation and reference implementation
            by Paulo Barreto, Vincent Rijmen, for v2.0 August '99.
            <p>
            Note: this implementation is based on information prior to readonly NIST publication.
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Mul0x2(System.Int32)">
            multiply two elements of GF(2^m)
            needed for MixColumn and InvMixColumn
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RijndaelEngine.KeyAddition(System.Int64[])">
            xor corresponding text input and round key input bytes
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RijndaelEngine.ShiftRow(System.Byte[])">
            Row 0 remains unchanged
            The other three rows are shifted a variable amount
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Substitution(System.Byte[])">
            Replace every byte of the input by the byte at that place
            in the nonlinear S-box
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RijndaelEngine.MixColumn">
            Mix the bytes of every column in a linear way
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RijndaelEngine.InvMixColumn">
            Mix the bytes of every column in a linear way
            This is the opposite operation of Mixcolumn
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RijndaelEngine.GenerateWorkingKey(System.Byte[])">
            Calculate the necessary round keys
            The number of calculations depends on keyBits and blockBits
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RijndaelEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RijndaelEngine.#ctor(System.Int32)">
             basic constructor - set the cipher up for a given blocksize
            
             @param blocksize the blocksize in bits, must be 128, 192, or 256.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Rijndael cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine">
            this does your basic RSA algorithm with blinding
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic RSA algorithm.
            
             @param inBuf the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param inLen the length of the data to be processed.
             @return the result of the RSA process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine">
            This does your basic RSA Chaum's blinding and unblinding as outlined in
            "Handbook of Applied Cryptography", page 475. You need to use this if you are
            trying to get another party to generate signatures without them being aware
            of the message they are signing.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the blinding engine.
            
             @param forEncryption true if we are encrypting (blinding), false otherwise.
             @param param         the necessary RSA key parameters.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the RSA blinding algorithm.
            
             @param in    the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param inLen the length of the data to be processed.
             @return the result of the RSA process.
             @throws DataLengthException the input block is too large.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaCoreEngine">
            this does your basic RSA algorithm.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaEngine">
            this does your basic RSA algorithm.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.RsaEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic RSA algorithm.
            
             @param inBuf the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param inLen the length of the data to be processed.
             @return the result of the RSA process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Salsa20Engine">
            <summary>
            Implementation of Daniel J. Bernstein's Salsa20 stream cipher, Snuffle 2005
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Salsa20Engine.StateSize">
            Constants 
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Salsa20Engine.#ctor">
            <summary>
            Creates a 20 round Salsa20 engine.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.Salsa20Engine.#ctor(System.Int32)">
            <summary>
            Creates a Salsa20 engine with a specific number of rounds.
            </summary>
            <param name="rounds">the number of rounds (must be an even number).</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SeedEngine">
            Implementation of the SEED algorithm as described in RFC 4009
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SeedWrapEngine">
            <remarks>
            An implementation of the SEED key wrapper based on RFC 4010/RFC 3394.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc4010.txt">http://www.ietf.org/rfc/rfc4010.txt</a>.
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngine">
                 * Serpent is a 128-bit 32-round block cipher with variable key lengths,
                 * including 128, 192 and 256 bit keys conjectured to be at least as
                 * secure as three-key triple-DES.
                 * <p>
                 * Serpent was designed by Ross Anderson, Eli Biham and Lars Knudsen as a
                 * candidate algorithm for the NIST AES Quest.
            	 * </p>
                 * <p>
                 * For full details see <a href="http://www.cl.cam.ac.uk/~rja14/serpent.html">The Serpent home page</a>
            	 * </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngine.MakeWorkingKey(System.Byte[])">
             Expand a user-supplied key material into a session key.
            
             @param key  The user-key bytes (multiples of 4) to use.
             @exception ArgumentException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Serpent cipher.
            
             @param encrypting whether or not we are for encryption.
             @param params     the parameters required to set up the cipher.
             @throws IllegalArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in     the array containing the input data.
             @param inOff  offset into the in array the data starts at.
             @param out    the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @return the number of bytes processed and produced.
             @throws DataLengthException if there isn't enough data in in, or
             space in out.
             @throws IllegalStateException if the cipher isn't initialised.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib0(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvSO - {13, 3,11, 0,10, 6, 5,12, 1,14, 4, 7,15, 9, 8, 2 } - 15 terms.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb1(System.Int32,System.Int32,System.Int32,System.Int32)">
            S1 - {15,12, 2, 7, 9, 0, 5,10, 1,11,14, 8, 6,13, 3, 4 } - 14 terms.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib1(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS1 - { 5, 8, 2,14,15, 6,12, 3,11, 4, 7, 9, 1,13,10, 0 } - 14 steps.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb2(System.Int32,System.Int32,System.Int32,System.Int32)">
            S2 - { 8, 6, 7, 9, 3,12,10,15,13, 1,14, 4, 0,11, 5, 2 } - 16 terms.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib2(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS2 - {12, 9,15, 4,11,14, 1, 2, 0, 3, 6,13, 5, 8,10, 7 } - 16 steps.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb3(System.Int32,System.Int32,System.Int32,System.Int32)">
            S3 - { 0,15,11, 8,12, 9, 6, 3,13, 1, 2, 4,10, 7, 5,14 } - 16 terms.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib3(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS3 - { 0, 9,10, 7,11,14, 6,13, 3, 5,12, 2, 4, 8,15, 1 } - 15 terms
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb4(System.Int32,System.Int32,System.Int32,System.Int32)">
            S4 - { 1,15, 8, 3,12, 0,11, 6, 2, 5, 4,10, 9,14, 7,13 } - 15 terms.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib4(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS4 - { 5, 0, 8, 3,10, 9, 7,14, 2,12,11, 6, 4,15,13, 1 } - 15 terms.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb5(System.Int32,System.Int32,System.Int32,System.Int32)">
            S5 - {15, 5, 2,11, 4,10, 9,12, 0, 3,14, 8,13, 6, 7, 1 } - 16 terms.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib5(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS5 - { 8,15, 2, 9, 4, 1,13,14,11, 6, 5, 3, 7,12,10, 0 } - 16 terms.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb6(System.Int32,System.Int32,System.Int32,System.Int32)">
            S6 - { 7, 2,12, 5, 8, 4, 6,11,14, 9, 1,15,13, 3,10, 0 } - 15 terms.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib6(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS6 - {15,10, 1,13, 5, 3, 6, 0, 4, 9,14, 7, 2,12, 8,11 } - 15 terms.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb7(System.Int32,System.Int32,System.Int32,System.Int32)">
            S7 - { 1,13,15, 0,14, 8, 2,11, 7, 4,12,10, 9, 3, 5, 6 } - 16 terms.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib7(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS7 - { 3, 0, 6,13, 9,14,15, 8, 5,12,11, 7,10, 1, 4, 2 } - 17 terms.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.LT">
            Apply the linear transformation to the register set.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.InverseLT">
            Apply the inverse of the linear transformation to the register set.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SkipjackEngine">
            a class that provides a basic SKIPJACK engine.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SkipjackEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a SKIPJACK cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SkipjackEngine.G(System.Int32,System.Int32)">
            The G permutation
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SkipjackEngine.H(System.Int32,System.Int32)">
            the inverse of the G permutation.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SM2Engine">
            <summary>
            SM2 public key encryption engine - based on https://tools.ietf.org/html/draft-shen-sm2-ecdsa-02.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.SM4Engine">
            <summary>SM4 Block Cipher - SM4 is a 128 bit block cipher with a 128 bit key.</summary>
            <remarks>
            The implementation here is based on the document <a href="http://eprint.iacr.org/2008/329.pdf">http://eprint.iacr.org/2008/329.pdf</a>
            by Whitfield Diffie and George Ledin, which is a translation of Prof. LU Shu-wang's original standard.
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.TeaEngine">
            An TEA engine.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.TeaEngine.#ctor">
            Create an instance of the TEA encryption algorithm
            and set some defaults
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.TeaEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.TeaEngine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine">
            <summary>
            Implementation of the Threefish tweakable large block cipher in 256, 512 and 1024 bit block
            sizes.
            </summary>
            <remarks>
            This is the 1.3 version of Threefish defined in the Skein hash function submission to the NIST
            SHA-3 competition in October 2010.
            <p/>
            Threefish was designed by Niels Ferguson - Stefan Lucks - Bruce Schneier - Doug Whiting - Mihir
            Bellare - Tadayoshi Kohno - Jon Callas - Jesse Walker.
            <p/>
            This implementation inlines all round functions, unrolls 8 rounds, and uses 1.2k of static tables
            to speed up key schedule injection. <br/>
            2 x block size state is retained by each cipher instance.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_256">
            <summary>
            256 bit block size - Threefish-256
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_512">
            <summary>
            512 bit block size - Threefish-512
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_1024">
            <summary>
            1024 bit block size - Threefish-1024
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.TWEAK_SIZE_BYTES">
            Size of the tweak in bytes (always 128 bit/16 bytes)
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ROUNDS_256">
            Rounds in Threefish-256
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ROUNDS_512">
            Rounds in Threefish-512
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ROUNDS_1024">
            Rounds in Threefish-1024
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.MAX_ROUNDS">
            Max rounds of any of the variants
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.C_240">
            Key schedule parity constant
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.blocksizeBytes">
            Block size in bytes
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.blocksizeWords">
            Block size in 64 bit words
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.currentBlock">
            Buffer for byte oriented processBytes to call internal word API
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.t">
            Tweak bytes (2 byte t1,t2, calculated t3 and repeat of t1,t2 for modulo free lookup
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.kw">
            Key schedule words
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.cipher">
            The internal cipher implementation (varies by blocksize)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.#ctor(System.Int32)">
            <summary>
            Constructs a new Threefish cipher, with a specified block size.
            </summary>
            <param name="blocksizeBits">the block size in bits, one of <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_256"/>, <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_512"/>,
                                 <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_1024"/> .</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>
            Initialise the engine.
            </summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">an instance of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.TweakableBlockCipherParameters"/> or <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.KeyParameter"/> (to
                          use a 0 tweak)</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Init(System.Boolean,System.UInt64[],System.UInt64[])">
            <summary>
            Initialise the engine, specifying the key and tweak directly.
            </summary>
            <param name="forEncryption">the cipher mode.</param>
            <param name="key">the words of the key, or <code>null</code> to use the current key.</param>
            <param name="tweak">the 2 word (128 bit) tweak, or <code>null</code> to use the current tweak.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ProcessBlock(System.UInt64[],System.UInt64[])">
            <summary>
            Process a block of data represented as 64 bit words.
            </summary>
            <returns>the number of 8 byte words processed (which will be the same as the block size).</returns>
            <param name="inWords">a block sized buffer of words to process.</param>
            <param name="outWords">a block sized buffer of words to receive the output of the operation.</param>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.DataLengthException">if either the input or output is not block sized</exception>
            <exception cref="T:System.InvalidOperationException">if this engine is not initialised</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.RotlXor(System.UInt64,System.Int32,System.UInt64)">
            Rotate left + xor part of the mix operation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.XorRotr(System.UInt64,System.Int32,System.UInt64)">
            Rotate xor + rotate right part of the unmix operation.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ThreefishCipher.t">
            The extended + repeated tweak words
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ThreefishCipher.kw">
            The extended + repeated key words
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish256Cipher.ROTATION_0_0">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish256Cipher.ROTATION_0_1">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish512Cipher.ROTATION_0_0">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish512Cipher.ROTATION_0_1">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish512Cipher.ROTATION_0_2">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish512Cipher.ROTATION_0_3">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish1024Cipher.ROTATION_0_0">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish1024Cipher.ROTATION_0_1">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish1024Cipher.ROTATION_0_2">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish1024Cipher.ROTATION_0_3">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.TnepresEngine">
            Tnepres is a 128-bit 32-round block cipher with variable key lengths,
            including 128, 192 and 256 bit keys conjectured to be at least as
            secure as three-key triple-DES.
            <p>
            Tnepres is based on Serpent which was designed by Ross Anderson, Eli Biham and Lars Knudsen as a
            candidate algorithm for the NIST AES Quest. Unfortunately there was an endianness issue
            with test vectors in the AES submission and the resulting confusion lead to the Tnepres cipher
            as well, which is a byte swapped version of Serpent.
            </p>
            <p>
            For full details see <a href="http://www.cl.cam.ac.uk/~rja14/serpent.html">The Serpent home page</a>
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.TnepresEngine.MakeWorkingKey(System.Byte[])">
             Expand a user-supplied key material into a session key.
            
             @param key  The user-key bytes (multiples of 4) to use.
             @exception ArgumentException
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.TwofishEngine">
             A class that provides Twofish encryption operations.
            
             This Java implementation is based on the Java reference
             implementation provided by Bruce Schneier and developed
             by Raif S. Naffah.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.TwofishEngine.P_00">
            Define the fixed p0/p1 permutations used in keyed S-box lookup.
            By changing the following constant definitions, the S-boxes will
            automatically Get changed in the Twofish engine.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.TwofishEngine.gSubKeys">
            gSubKeys[] and gSBox[] are eventually used in the
            encryption and decryption methods.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.TwofishEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Twofish cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.TwofishEngine.EncryptBlock(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
             Encrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
             The input will be an exact multiple of our blocksize.
            
             encryptBlock uses the pre-calculated gSBox[] and subKey[]
             arrays.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.TwofishEngine.DecryptBlock(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
            Decrypt the given input starting at the given offset and place
            the result in the provided buffer starting at the given offset.
            The input will be an exact multiple of our blocksize.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.TwofishEngine.RS_MDS_Encode(System.Int32,System.Int32)">
             Use (12, 8) Reed-Solomon code over GF(256) to produce
             a key S-box 32-bit entity from 2 key material 32-bit
             entities.
            
             @param    k0 first 32-bit entity
             @param    k1 second 32-bit entity
             @return     Remainder polynomial Generated using RS code
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.TwofishEngine.RS_rem(System.Int32)">
                    * Reed-Solomon code parameters: (12,8) reversible code:
            		* <p>
                    * <pre>
                    * G(x) = x^4 + (a+1/a)x^3 + ax^2 + (a+1/a)x + 1
                    * </pre>
                    * where a = primitive root of field generator 0x14D
            		* </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.VmpcEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            initialise a VMPC cipher.
            
            @param forEncryption
               whether or not we are for encryption.
            @param params
               the parameters required to set up the cipher.
            @exception ArgumentException
               if the params argument is inappropriate.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.XSalsa20Engine">
            <summary>
            Implementation of Daniel J. Bernstein's XSalsa20 stream cipher - Salsa20 with an extended nonce.
            </summary>
            <remarks>
            XSalsa20 requires a 256 bit key, and a 192 bit nonce.
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.XSalsa20Engine.SetKey(System.Byte[],System.Byte[])">
            <summary>
            XSalsa20 key generation: process 256 bit input key and 128 bits of the input nonce
            using a core Salsa20 function without input addition to produce 256 bit working key
            and use that with the remaining 64 bits of nonce to initialize a standard Salsa20 engine state.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.XteaEngine">
            An XTEA engine.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.XteaEngine.#ctor">
            Create an instance of the TEA encryption algorithm
            and set some defaults
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.XteaEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.XteaEngine.setKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Fpe.FpeEngine">
            <summary>Base class for format-preserving encryption.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Fpe.FpeEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Process length bytes from inBuf, writing the output to outBuf.
            </summary>
            <returns>number of bytes output.</returns>
            <param name="inBuf">input data.</param>  
            <param name="inOff">offset in input data to start at.</param>  
            <param name="length">number of bytes to process.</param>  
            <param name="outBuf">destination buffer.</param>  
            <param name="outOff">offset to start writing at in destination buffer.</param>  
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Fpe.FpeEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>
            Initialize the FPE engine for encryption/decryption.
            </summary>
            <returns>number of bytes output.</returns>
            <param name="forEncryption">true if initialising for encryption, false otherwise.</param>  
            <param name="parameters ">the key and other parameters to use to set the engine up.</param>  
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator">
            Basic KDF generator for derived keys and ivs as defined by IEEE P1363a/ISO 18033
            <br/>
            This implementation is based on ISO 18033/P1363a.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator.#ctor(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
             Construct a KDF Parameters generator.
            
             @param counterStart value of counter.
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator.Digest">
            return the underlying digest.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator.GenerateBytes(System.Byte[],System.Int32,System.Int32)">
             fill len bytes of the output buffer with bytes generated from
             the derivation function.
            
             @throws ArgumentException if the size of the request will cause an overflow.
             @throws DataLengthException if the out buffer is too small.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.BCrypt">
            Core of password hashing scheme Bcrypt,
            designed by Niels Provos and David Mazires,
            corresponds to the C reference implementation.
            <p>
            This implementation does not correspondent to the 1999 published paper
            "A Future-Adaptable Password Scheme" of Niels Provos and David Mazires,
            see: https://www.usenix.org/legacy/events/usenix99/provos/provos_html/node1.html.
            In contrast to the paper, the order of key setup and salt setup is reversed:
            state &lt;- ExpandKey(state, 0, key)
            state %lt;- ExpandKey(state, 0, salt)
            This corresponds to the OpenBSD reference implementation of Bcrypt. 
            </p><p>
            Note: 
            There is no successful cryptanalysis (status 2015), but
            the amount of memory and the band width of Bcrypt
            may be insufficient to effectively prevent attacks 
            with custom hardware like FPGAs, ASICs
            </p><p>
            This implementation uses some parts of Bouncy Castle's BlowfishEngine.
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.BCrypt.DeriveRawKey(System.Int32,System.Byte[],System.Byte[])">
             Derives a raw 192 bit Bcrypt key
            
             @param cost the cost factor, treated as an exponent of 2
             @param salt a 16 byte salt
             @param psw  the password
             @return a 192 bit key
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.BCrypt.SALT_SIZE_BYTES">
            Size of the salt parameter in bytes
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.BCrypt.MIN_COST">
            Minimum value of cost parameter, equal to log2(bytes of salt)
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.BCrypt.MAX_COST">
            Maximum value of cost parameter (31 == 2,147,483,648)
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.BCrypt.MAX_PASSWORD_BYTES">
            Maximum size of password == max (unrestricted) size of Blowfish key
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.BCrypt.PasswordToByteArray(System.Char[])">
             Converts a character password to bytes incorporating the required trailing zero byte.
            
             @param password the password to be encoded.
             @return a byte representation of the password in UTF8 + trailing zero.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.BCrypt.Generate(System.Byte[],System.Byte[],System.Int32)">
            Calculates the <b>bcrypt</b> hash of a password.
            <p>
            This implements the raw <b>bcrypt</b> function as defined in the bcrypt specification, not
            the crypt encoded version implemented in OpenBSD.
            </p>
            @param password the password bytes (up to 72 bytes) to use for this invocation.
            @param salt     the 128 bit salt to use for this invocation.
            @param cost     the bcrypt cost parameter. The cost of the bcrypt function grows as
                            <code>2^cost</code>. Legal values are 4..31 inclusive.
            @return the output of the raw bcrypt operation: a 192 bit (24 byte) hash.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.DesEdeKeyGenerator.EngineInit(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             initialise the key generator - if strength is set to zero
             the key Generated will be 192 bits in size, otherwise
             strength can be 128 or 192 (or 112 or 168 if you don't count
             parity bits), depending on whether you wish to do 2-key or 3-key
             triple DES.
            
             @param param the parameters to be used for key generation
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.DesKeyGenerator.EngineInit(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             initialise the key generator - if strength is set to zero
             the key generated will be 64 bits in size, otherwise
             strength can be 64 or 56 bits (if you don't count the parity bits).
            
             @param param the parameters to be used for key generation
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.DHBasicKeyPairGenerator">
             a basic Diffie-Hellman key pair generator.
            
             This generates keys consistent for use with the basic algorithm for
             Diffie-Hellman.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.DHKeyPairGenerator">
             a Diffie-Hellman key pair generator.
            
             This generates keys consistent for use in the MTI/A0 key agreement protocol
             as described in "Handbook of Applied Cryptography", Pages 516-519.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.DHParametersGenerator.GenerateParameters">
            which Generates the p and g values from the given parameters,
            returning the DHParameters object.
            <p>
            Note: can take a while...</p>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.DsaKeyPairGenerator">
             a DSA key pair generator.
            
             This Generates DSA keys in line with the method described
             in <i>FIPS 186-3 B.1 FFC Key Pair Generation</i>.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator">
            Generate suitable parameters for DSA, in line with FIPS 186-2, or FIPS 186-3.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator.Init(System.Int32,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>Initialise the generator</summary>
            <remarks>This form can only be used for older DSA (pre-DSA2) parameters</remarks>
            <param name="size">the size of keys in bits (from 512 up to 1024, and a multiple of 64)</param>
            <param name="certainty">measure of robustness of primes (at least 80 for FIPS 186-2 compliance)</param>
            <param name="random">the source of randomness to use</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.DsaParameterGenerationParameters)">
            <summary>Initialise the generator for DSA 2</summary>
            <remarks>You must use this Init method if you need to generate parameters for DSA 2 keys</remarks>
            <param name="parameters">An instance of <c>DsaParameterGenerationParameters</c> used to configure this generator</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator.GenerateParameters">
            <summary>Generates a set of <c>DsaParameters</c></summary>
            <remarks>Can take a while...</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator.GenerateParameters_FIPS186_3">
            generate suitable parameters for DSA, in line with
            <i>FIPS 186-3 A.1 Generation of the FFC Primes p and q</i>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.ECKeyPairGenerator.GenerateKeyPair">
            Given the domain parameters this routine generates an EC key
            pair in accordance with X9.62 section 5.2.1 pages 26, 27.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.ElGamalKeyPairGenerator">
            a ElGamal key pair generator.
            <p>
            This Generates keys consistent for use with ElGamal as described in
            page 164 of "Handbook of Applied Cryptography".</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.ElGamalParametersGenerator.GenerateParameters">
                     * which Generates the p and g values from the given parameters,
                     * returning the ElGamalParameters object.
                     * <p>
                     * Note: can take a while...
            		 * </p>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Gost3410KeyPairGenerator">
            a GOST3410 key pair generator.
            This generates GOST3410 keys in line with the method described
            in GOST R 34.10-94.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Gost3410ParametersGenerator">
            generate suitable parameters for GOST3410.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Gost3410ParametersGenerator.Init(System.Int32,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
             initialise the key generator.
            
             @param size size of the key
             @param typeProcedure type procedure A,B = 1;  A',B' - else
             @param random random byte source.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Gost3410ParametersGenerator.procedure_C(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Procedure C
            procedure generates the a value from the given p,q,
            returning the a value.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Gost3410ParametersGenerator.GenerateParameters">
            which generates the p , q and a values from the given parameters,
            returning the Gost3410Parameters object.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.HkdfBytesGenerator">
            HMAC-based Extract-and-Expand Key Derivation Function (HKDF) implemented
            according to IETF RFC 5869, May 2010 as specified by H. Krawczyk, IBM
            Research &amp; P. Eronen, Nokia. It uses a HMac internally to compute de OKM
            (output keying material) and is likely to have better security properties
            than KDF's based on just a hash function.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.HkdfBytesGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
             Creates a HKDFBytesGenerator based on the given hash function.
            
             @param hash the digest to be used as the source of generatedBytes bytes
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.HkdfBytesGenerator.Extract(System.Byte[],System.Byte[])">
             Performs the extract part of the key derivation function.
            
             @param salt the salt to use
             @param ikm  the input keying material
             @return the PRK as KeyParameter
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.HkdfBytesGenerator.ExpandNext">
             Performs the expand part of the key derivation function, using currentT
             as input and output buffer.
            
             @throws DataLengthException if the total number of bytes generated is larger than the one
             specified by RFC 5869 (255 * HashLen)
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Kdf1BytesGenerator">
            KFD1 generator for derived keys and ivs as defined by IEEE P1363a/ISO 18033
            <br/>
            This implementation is based on IEEE P1363/ISO 18033.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Kdf1BytesGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
             Construct a KDF1 byte generator.
            
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Kdf2BytesGenerator">
            KDF2 generator for derived keys and ivs as defined by IEEE P1363a/ISO 18033
            <br/>
            This implementation is based on IEEE P1363/ISO 18033.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Kdf2BytesGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
             Construct a KDF2 bytes generator. Generates key material
             according to IEEE P1363 or ISO 18033 depending on the initialisation.
            
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator">
            <summary>Generator for MGF1 as defined in Pkcs 1v2</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
            <param name="digest">the digest to be used as the source of generated bytes</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator.Digest">
            <summary>the underlying digest.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator.GenerateBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Fill <c>len</c> bytes of the output buffer with bytes generated from the derivation function.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.NaccacheSternKeyPairGenerator">
             Key generation parameters for NaccacheStern cipher. For details on this cipher, please see
            
             http://www.gemplus.com/smart/rd/publications/pdf/NS98pkcs.pdf
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.NaccacheSternKeyPairGenerator.PermuteList``1(System.Collections.Generic.IList{``0},Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
             Generates a permuted ArrayList from the original one. The original List
             is not modified
            
             @param arr
                        the ArrayList to be permuted
             @param rand
                        the source of Randomness for permutation
             @return a new IList with the permuted elements.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.NaccacheSternKeyPairGenerator.FindFirstPrimes(System.Int32)">
             Finds the first 'count' primes starting with 3
            
             @param count
                        the number of primes to find
             @return a vector containing the found primes as Integer
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.OpenBsdBCrypt">
            Password hashing scheme BCrypt,
            designed by Niels Provos and David Mazires, using the
            String format and the Base64 encoding
            of the reference implementation on OpenBSD
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.OpenBsdBCrypt.CreateBcryptString(System.String,System.Byte[],System.Byte[],System.Int32)">
             Creates a 60 character Bcrypt String, including
             version, cost factor, salt and hash, separated by '$'
            
             @param version  the version, 2y,2b or 2a. (2a is not backwards compatible.)
             @param cost     the cost factor, treated as an exponent of 2
             @param salt     a 16 byte salt
             @param password the password
             @return a 60 character Bcrypt String
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.OpenBsdBCrypt.Generate(System.Char[],System.Byte[],System.Int32)">
             Creates a 60 character Bcrypt String, including
             version, cost factor, salt and hash, separated by '$' using version
             '2y'.
            
             @param cost     the cost factor, treated as an exponent of 2
             @param salt     a 16 byte salt
             @param password the password
             @return a 60 character Bcrypt String
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.OpenBsdBCrypt.Generate(System.String,System.Char[],System.Byte[],System.Int32)">
             Creates a 60 character Bcrypt String, including
             version, cost factor, salt and hash, separated by '$'
            
             @param version  the version, may be 2b, 2y or 2a. (2a is not backwards compatible.)
             @param cost     the cost factor, treated as an exponent of 2
             @param salt     a 16 byte salt
             @param password the password
             @return a 60 character Bcrypt String
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.OpenBsdBCrypt.CheckPassword(System.String,System.Char[])">
             Checks if a password corresponds to a 60 character Bcrypt String
            
             @param bcryptString a 60 character Bcrypt String, including
                                 version, cost factor, salt and hash,
                                 separated by '$'
             @param password     the password as an array of chars
             @return true if the password corresponds to the
             Bcrypt String, otherwise false
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator">
            <description>
            Generator for PBE derived keys and IVs as usd by OpenSSL. Originally this scheme was a simple extension of
            PKCS 5 V2.0 Scheme 1 using MD5 with an iteration count of 1. The default digest was changed to SHA-256 with
            OpenSSL 1.1.0. This implementation still defaults to MD5, but the digest can now be set.
            </description>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.#ctor">
            
             <description>
             Construct a OpenSSL Parameters generator - digest the original MD5.
             </description>
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
            
             <description>
             Construct a OpenSSL Parameters generator - digest as specified.
             </description>
             <param name="digest">the digest to use as the PRF.</param>
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.Init(System.Byte[],System.Byte[])">
            Initialise - note the iteration count for this algorithm is fixed at 1.
            
            @param password password to use.
            @param salt salt to use.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.GenerateDerivedKey(System.Int32)">
            the derived key function, the ith hash of the password and the salt.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the password,
             salt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
             @exception ArgumentException if the key length larger than the base hash size.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator">
            Generator for Pbe derived keys and ivs as defined by Pkcs 12 V1.0.
            <p>
            The document this implementation is based on can be found at
            <a href="http://www.rsasecurity.com/rsalabs/pkcs/pkcs-12/index.html">
            RSA's Pkcs12 Page</a>
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
             Construct a Pkcs 12 Parameters generator.
            
             @param digest the digest to be used as the source of derived keys.
             @exception ArgumentException if an unknown digest is passed in.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.Adjust(System.Byte[],System.Int32,System.Byte[])">
            add a + b + 1, returning the result in a. The a value is treated
            as a BigInteger of length (b.Length * 8) bits. The result is
            modulo 2^b.Length in case of overflow.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.GenerateDerivedKey(System.Int32,System.Int32)">
            generation of a derived key ala Pkcs12 V1.0.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the password,
             salt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator">
            Generator for Pbe derived keys and ivs as defined by Pkcs 5 V2.0 Scheme 1.
            Note this generator is limited to the size of the hash produced by the
            digest used to drive it.
            <p>
            The document this implementation is based on can be found at
            <a href="http://www.rsasecurity.com/rsalabs/pkcs/pkcs-5/index.html">
            RSA's Pkcs5 Page</a>
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
             Construct a Pkcs 5 Scheme 1 Parameters generator.
            
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator.GenerateDerivedKey">
            the derived key function, the ith hash of the mPassword and the mSalt.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the mPassword,
             mSalt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
             @exception ArgumentException if the key length larger than the base hash size.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator">
            Generator for Pbe derived keys and ivs as defined by Pkcs 5 V2.0 Scheme 2.
            This generator uses a SHA-1 HMac as the calculation function.
            <p>
            The document this implementation is based on can be found at
            <a href="http://www.rsasecurity.com/rsalabs/pkcs/pkcs-5/index.html">
            RSA's Pkcs5 Page</a></p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator.#ctor">
            construct a Pkcs5 Scheme 2 Parameters generator.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the password,
             salt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator">
            <summary>
            Generates keys for the Poly1305 MAC.
            </summary>
            <remarks>
            Poly1305 keys are 256 bit keys consisting of a 128 bit secret key used for the underlying block
            cipher followed by a 128 bit {@code r} value used for the polynomial portion of the Mac. <br/>
            The {@code r} value has a specific format with some bits required to be cleared, resulting in an
            effective 106 bit key. <br/>
            A separately generated 256 bit key can be modified to fit the Poly1305 key format by using the
            {@link #clamp(byte[])} method to clear the required bits.
            </remarks>
            <seealso cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.EngineInit(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.KeyGenerationParameters)">
            <summary>
            Initialises the key generator.
            </summary>
            <remarks>
            Poly1305 keys are always 256 bits, so the key length in the provided parameters is ignored.
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.EngineGenerateKey">
            <summary>
            Generates a 256 bit key in the format required for Poly1305 - e.g.
            <code>k[0] ... k[15], r[0] ... r[15]</code> with the required bits in <code>r</code> cleared
            as per <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.Clamp(System.Byte[])"/>.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.Clamp(System.Byte[])">
            <summary>
            Modifies an existing 32 byte key value to comply with the requirements of the Poly1305 key by
            clearing required bits in the <code>r</code> (second 16 bytes) portion of the key.<br/>
            Specifically:
            <ul>
            <li>r[3], r[7], r[11], r[15] have top four bits clear (i.e., are {0, 1, . . . , 15})</li>
            <li>r[4], r[8], r[12] have bottom two bits clear (i.e., are in {0, 4, 8, . . . , 252})</li>
            </ul>
            </summary>
            <param name="key">a 32 byte key value <code>k[0] ... k[15], r[0] ... r[15]</code></param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.CheckKey(System.Byte[])">
            <summary>
            Checks a 32 byte key for compliance with the Poly1305 key requirements, e.g.
            <code>k[0] ... k[15], r[0] ... r[15]</code> with the required bits in <code>r</code> cleared
            as per <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.Clamp(System.Byte[])"/>.
            </summary>
            <param name="key">Key.</param>
            <exception cref="T:System.ArgumentException">if the key is of the wrong length, or has invalid bits set
                      in the <code>r</code> portion of the key.</exception>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.RsaBlindingFactorGenerator">
            Generate a random factor suitable for use with RSA blind signatures
            as outlined in Chaum's blinding and unblinding as outlined in
            "Handbook of Applied Cryptography", page 475.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.RsaBlindingFactorGenerator.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the factor generator
            
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.RsaBlindingFactorGenerator.GenerateBlindingFactor">
             Generate a suitable blind factor for the public key the generator was initialised with.
            
             @return a random blind factor
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator">
            an RSA key pair generator.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator.ChooseRandomPrime(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>Choose a random prime value for use with RSA</summary>
            <param name="bitlength">the bit-length of the returned prime</param>
            <param name="e">the RSA public exponent</param>
            <returns>a prime p, with (p-1) relatively prime to e</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.SCrypt">
            <summary>Implementation of the scrypt a password-based key derivation function.</summary>
            <remarks>
            Scrypt was created by Colin Percival and is specified in
            <a href="http://tools.ietf.org/html/draft-josefsson-scrypt-kdf-01">draft-josefsson-scrypt-kd</a>.
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.SCrypt.Generate(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Generate a key using the scrypt key derivation function.</summary>
            <param name="P">the bytes of the pass phrase.</param>
            <param name="S">the salt to use for this invocation.</param>
            <param name="N">CPU/Memory cost parameter. Must be larger than 1, a power of 2 and less than
                <code>2^(128 * r / 8)</code>.</param>
            <param name="r">the block size, must be >= 1.</param>
            <param name="p">Parallelization parameter. Must be a positive integer less than or equal to
                <code>int.MaxValue / (128 * r * 8)</code>.</param>
            <param name="dkLen">the length of the key to generate.</param>
            <returns>the generated key.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAlphabetMapper">
            Base interface for mapping from an alphabet to a set of indexes
            suitable for use with FPE.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAlphabetMapper.Radix">
            <summary>
            Return the number of characters in the alphabet.
            </summary>
            <returns>the radix for the alphabet.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAlphabetMapper.ConvertToIndexes(System.Char[])">
            <summary>
            Return the passed in char[] as a byte array of indexes (indexes
            can be more than 1 byte)
            </summary>
            <returns>an index array.</returns>
            <param name="input">characters to be mapped.</param>   
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAlphabetMapper.ConvertToChars(System.Byte[])">
            <summary>
            Return a char[] for this alphabet based on the indexes passed.
            </summary>
            <returns>an array of char corresponding to the index values.</returns>
            <param name="input">input array of indexes.</param>   
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher">
            <remarks>Base interface for a public/private key block cipher.</remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.GetInputBlockSize">
            <returns>The maximum size, in bytes, an input block may be.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.GetOutputBlockSize">
            <returns>The maximum size, in bytes, an output block will be.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="inLen">The length of the input block.</param>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.InvalidCipherTextException">Input decrypts improperly.</exception>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.DataLengthException">Input is too large for the cipher.</exception>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator">
            interface that a public/private key pair generator should conform to.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             intialise the key pair generator.
            
             @param the parameters the key pair is to be initialised with.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator.GenerateKeyPair">
             return an AsymmetricCipherKeyPair containing the Generated keys.
            
             @return an AsymmetricCipherKeyPair containing the Generated keys.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBasicAgreement">
            The basic interface that basic Diffie-Hellman implementations
            conforms to.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBasicAgreement.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            initialise the agreement engine.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBasicAgreement.GetFieldSize">
            return the field size for the agreement algorithm in bytes.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBasicAgreement.CalculateAgreement(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            given a public key from a given party calculate the next
            message in the agreement sequence.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher">
            <remarks>Base interface for a symmetric key block cipher.</remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="outBuf">The output buffer.</param>
            <param name="outOff">The offset into <paramref>outBuf</paramref> to write the output block.</param>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.DataLengthException">If input block is wrong size, or outBuf too small.</exception>
            <returns>The number of bytes processed and produced.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher.ProcessBlock(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
            <summary>Process a block.</summary>
            <param name="input">The input block as a span.</param>
            <param name="output">The output span.</param>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.DataLengthException">If input block is wrong size, or output span too small.</exception>
            <returns>The number of bytes processed and produced.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockResult">
            <summary>
            Operators that reduce their input to a single block return an object
            of this type.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockResult.Collect">
            <summary>
            Return the final result of the operation.
            </summary>
            <returns>A block of bytes, representing the result of an operation.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockResult.Collect(System.Byte[],System.Int32)">
            <summary>
            Store the final result of the operation by copying it into the destination array.
            </summary>
            <returns>The number of bytes copied into destination.</returns>
            <param name="destination">The byte array to copy the result into.</param>
            <param name="offset">The offset into destination to start copying the result at.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockResult.Collect(System.Span{System.Byte})">
            <summary>
            Store the final result of the operation by copying it into the destination span.
            </summary>
            <returns>The number of bytes copied into destination.</returns>
            <param name="destination">The span to copy the result into.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBufferedCipher">
            <remarks>Block cipher engines are expected to conform to this interface.</remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBufferedCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBufferedCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">If true the cipher is initialised for encryption,
            if false for decryption.</param>
            <param name="parameters">The key and other data required by the cipher.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBufferedCipher.Reset">
            <summary>
            Reset the cipher. After resetting the cipher is in the same state
            as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipher">
            <summary>
            Base interface for a ciphers that do not require data to be block aligned.
            <para>
            Note: In cases where the underlying algorithm is block based, these ciphers may add or remove padding as needed.
            </para>
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipher.GetMaxOutputSize(System.Int32)">
            <summary>
            Return the size of the output buffer required for a Write() plus a
            close() with the write() being passed inputLen bytes.
            <para>
            The returned size may be dependent on the initialisation of this cipher
            and may not be accurate once subsequent input data is processed as the cipher may
            add, add or remove padding, as it sees fit.
            </para>
            </summary>
            <returns>The space required to accommodate a call to processBytes and doFinal with inputLen bytes of input.</returns>
            <param name="inputLen">The length of the expected input.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipher.GetUpdateOutputSize(System.Int32)">
            <summary>
            Return the size of the output buffer required for a write() with the write() being
            passed inputLen bytes and just updating the cipher output.
            </summary>
            <returns>The space required to accommodate a call to processBytes with inputLen bytes of input.</returns>
            <param name="inputLen">The length of the expected input.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipher.Stream">
            <summary>
            Gets the stream for reading/writing data processed/to be processed.
            </summary>
            <value>The stream associated with this cipher.</value>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherBuilder">
            <summary>
            Base interface for cipher builders.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherBuilder.AlgorithmDetails">
            <summary>
            Return the algorithm and parameter details associated with any cipher built.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherBuilder.GetMaxOutputSize(System.Int32)">
            <summary>
            Return the maximum output size that a given input will produce.
            </summary>
            <param name="inputLen">the length of the expected input.</param>
            <returns>The maximum possible output size that can produced for the expected input length.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherBuilder.BuildCipher(System.IO.Stream)">
            <summary>
            Build a cipher that operates on the passed in stream.
            </summary>
            <param name="stream">The stream to write/read any encrypted/decrypted data.</param>
            <returns>A cipher based around the given stream.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherBuilderWithKey">
            <summary>
            A cipher builder that can also return the key it was initialized with.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherBuilderWithKey.Key">
            <summary>
            Return the key we were initialized with.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters">
            all parameter classes implement this.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDecryptorBuilderProvider">
            <summary>
            Interface describing a provider of cipher builders for creating decrypting ciphers.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDecryptorBuilderProvider.CreateDecryptorBuilder(System.Object)">
            <summary>
            Return a cipher builder for creating decrypting ciphers.
            </summary>
            <param name="algorithmDetails">The algorithm details/parameters to use to create the final cipher.</param>
            <returns>A new cipher builder.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDerivationFunction">
            base interface for general purpose byte derivation functions.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDerivationFunction.Digest">
            return the message digest used as the basis for the function
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDerivationParameters">
            Parameters for key/byte stream derivation classes
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest">
            <remarks>Base interface for a message digest.</remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest.AlgorithmName">
            <summary>The algorithm name.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest.GetDigestSize">
            <summary>Return the size, in bytes, of the digest produced by this message digest.</summary>
            <returns>the size, in bytes, of the digest produced by this message digest.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest.GetByteLength">
            <summary>Return the size, in bytes, of the internal buffer used by this digest.</summary>
            <returns>the size, in bytes, of the internal buffer used by this digest.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest.Update(System.Byte)">
            <summary>Update the message digest with a single byte.</summary>
            <param name="input">the input byte to be entered.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>Update the message digest with a block of bytes.</summary>
            <param name="input">the byte array containing the data.</param>
            <param name="inOff">the offset into the byte array where the data starts.</param>
            <param name="inLen">the length of the data.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest.BlockUpdate(System.ReadOnlySpan{System.Byte})">
            <summary>Update the message digest with a span of bytes.</summary>
            <param name="input">the span containing the data.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest.DoFinal(System.Byte[],System.Int32)">
            <summary>Close the digest, producing the final digest value.</summary>
            <remarks>This call leaves the digest reset.</remarks>
            <param name="output">the byte array the digest is to be copied into.</param>
            <param name="outOff">the offset into the byte array the digest is to start at.</param>
            <returns>the number of bytes written</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest.DoFinal(System.Span{System.Byte})">
            <summary>Close the digest, producing the final digest value.</summary>
            <remarks>This call leaves the digest reset.</remarks>
            <param name="output">the span the digest is to be copied into.</param>
            <returns>the number of bytes written</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest.Reset">
            <summary>Reset the digest back to its initial state.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigestFactory">
            <summary>
            Base interface for operator factories that create stream-based digest calculators.
            </summary>   
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigestFactory.AlgorithmDetails">
            <summary>The algorithm details object for calculators made by this factory.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigestFactory.DigestLength">
            <summary>Return the size of the digest associated with this factory.</summary>
            <returns>The length of the digest produced by this calculators from this factory in bytes.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigestFactory.CreateCalculator">
            <summary>
            Create a stream calculator for the digest associated with this factory. The stream
            calculator is used for the actual operation of entering the data to be digested
            and producing the digest block.
            </summary>
            <returns>A calculator producing an IBlockResult with the final digest in it.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDsa">
            <summary>Interface for classes implementing the Digital Signature Algorithm</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDsa.AlgorithmName">
            <summary>The algorithm name.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDsa.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the signer for signature generation or signature verification.</summary>
            <param name="forSigning">true if we are generating a signature, false otherwise.</param>
            <param name="parameters">key parameters for signature generation.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDsa.GenerateSignature(System.Byte[])">
            <summary>Sign the passed in message (usually the output of a hash function).</summary>
            <param name="message">the message to be signed.</param>
            <returns>two big integers representing the r and s values respectively.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDsa.Order">
            <summary>The order of the group that the r, s values in signatures belong to.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDsa.VerifySignature(System.Byte[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>Verify the message message against the signature values r and s.</summary>
            <param name="message">the message that was supposed to have been signed.</param>
            <param name="r">the r signature value.</param>
            <param name="s">the s signature value.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IEncapsulatedSecretExtractor.ExtractSecret(System.Byte[])">
            <summary>
            Generate an exchange pair based on the recipient public key.
            </summary>
            <param name="encapsulation"> the encapsulated secret.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IEncapsulatedSecretExtractor.EncapsulationLength">
            <summary>
            The length in bytes of the encapsulation.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IEncapsulatedSecretGenerator.GenerateEncapsulated(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Generate an exchange pair based on the recipient public key.
            </summary>
            <param name="recipientKey"></param>
            <returns> An SecretWithEncapsulation derived from the recipient public key.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IEntropySource">
            <summary>
            Base interface describing an entropy source for a DRBG.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IEntropySource.IsPredictionResistant">
            <summary>
            Return whether or not this entropy source is regarded as prediction resistant.
            </summary>
            <value><c>true</c> if this instance is prediction resistant; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IEntropySource.GetEntropy">
            <summary>
            Return a byte array of entropy.
            </summary>
            <returns>The entropy bytes.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IEntropySource.EntropySize">
            <summary>
            Return the number of bits of entropy this source can produce.
            </summary>
            <value>The size, in bits, of the return value of getEntropy.</value>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IEntropySourceProvider">
            <summary>
            Base interface describing a provider of entropy sources.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IEntropySourceProvider.Get(System.Int32)">
            <summary>
            Return an entropy source providing a block of entropy.
            </summary>
            <param name="bitsRequired">The size of the block of entropy required.</param>
            <returns>An entropy source providing bitsRequired blocks of entropy.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IKeyUnwrapper">
            <summary>
            Base interface for a key unwrapper.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IKeyUnwrapper.AlgorithmDetails">
            <summary>
            The parameter set used to configure this key unwrapper.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IKeyUnwrapper.Unwrap(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Unwrap the passed in data.
            </summary>
            <param name="cipherText">The array containing the data to be unwrapped.</param>
            <param name="offset">The offset into cipherText at which the unwrapped data starts.</param>
            <param name="length">The length of the data to be unwrapped.</param>
            <returns>an IBlockResult containing the unwrapped key data.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IKeyWrapper">
            <summary>
            Base interface for a key wrapper.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IKeyWrapper.AlgorithmDetails">
            <summary>
            The parameter set used to configure this key wrapper.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IKeyWrapper.Wrap(System.Byte[])">
            <summary>
            Wrap the passed in key data.
            </summary>
            <param name="keyData">The key data to be wrapped.</param>
            <returns>an IBlockResult containing the wrapped key data.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IMac">
            <summary>The base interface for implementations of message authentication codes (MACs).</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IMac.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the MAC.</summary>
            <param name="parameters">The key or other data required by the MAC.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IMac.AlgorithmName">
            <summary>The algorithm name.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IMac.GetMacSize">
            <summary>Return the size, in bytes, of the MAC produced by this implementation.</summary>
            <returns>the size, in bytes, of the MAC produced by this implementation.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IMac.Update(System.Byte)">
            <summary>Update the MAC with a single byte.</summary>
            <param name="input">the input byte to be entered.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IMac.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>Update the MAC with a block of bytes.</summary>
            <param name="input">the byte array containing the data.</param>
            <param name="inOff">the offset into the byte array where the data starts.</param>
            <param name="inLen">the length of the data.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IMac.BlockUpdate(System.ReadOnlySpan{System.Byte})">
            <summary>Update the MAC with a span of bytes.</summary>
            <param name="input">the span containing the data.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IMac.DoFinal(System.Byte[],System.Int32)">
            <summary>Perform final calculations, producing the result MAC.</summary>
            <remarks>This call leaves the MAC reset.</remarks>
            <param name="output">the byte array the MAC is to be copied into.</param>
            <param name="outOff">the offset into the byte array the MAC is to start at.</param>
            <returns>the number of bytes written</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IMac.DoFinal(System.Span{System.Byte})">
            <summary>Perform final calculations, producing the result MAC.</summary>
            <remarks>This call leaves the MAC reset.</remarks>
            <param name="output">the span the MAC is to be copied into.</param>
            <returns>the number of bytes written</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IMac.Reset">
            <summary>Reset the MAC back to its initial state.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IMacFactory.AlgorithmDetails">
            <summary>The algorithm details object for this calculator.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IMacFactory.CreateCalculator">
            <summary>
            Create a stream calculator for this signature calculator. The stream
            calculator is used for the actual operation of entering the data to be signed
            and producing the signature block.
            </summary>
            <returns>A calculator producing an IBlockResult with a signature in it.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.InvalidCipherTextException">
            <summary>This exception is thrown whenever we find something we don't expect in a message.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISecretWithEncapsulation.GetSecret">
            <summary>
             Return the secret associated with the encapsulation.
             </summary>
             <returns> the secret the encapsulation is for.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISecretWithEncapsulation.GetEncapsulation">
            <summary>
            Return the data that carries the secret in its encapsulated form.
            </summary>
            <returns> the encapsulation of the secret.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory">
            <summary>
            Base interface for operators that serve as stream-based signature calculators.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory.AlgorithmDetails">
            <summary>The algorithm details object for this calculator.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory.CreateCalculator">
            <summary>
            Create a stream calculator for this signature calculator. The stream
            calculator is used for the actual operation of entering the data to be signed
            and producing the signature block.
            </summary>
            <returns>A calculator producing an IBlockResult with a signature in it.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISigner.AlgorithmName">
            <summary>The algorithm name.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISigner.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the signer for signing or verification.</summary>
            <param name="forSigning">true if for signing, false otherwise.</param>
            <param name="parameters">necessary parameters.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISigner.Update(System.Byte)">
            <summary>Update the signer with a single byte.</summary>
            <param name="input">the input byte to be entered.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>Update the signer with a block of bytes.</summary>
            <param name="input">the byte array containing the data.</param>
            <param name="inOff">the offset into the byte array where the data starts.</param>
            <param name="inLen">the length of the data.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISigner.BlockUpdate(System.ReadOnlySpan{System.Byte})">
            <summary>Update the signer with a span of bytes.</summary>
            <param name="input">the span containing the data.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISigner.GenerateSignature">
            <summary>Generate a signature for the message we've been loaded with using the key we were initialised with.
            </summary>
            <returns>A byte array containing the signature for the message.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISigner.VerifySignature(System.Byte[])">
            <summary>Return true if the internal state represents the signature described in the passed in array.
            </summary>
            <param name="signature">an array containing the candidate signature to verify.</param>
            <returns>true if the internal state represents the signature described in the passed in array.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISigner.Reset">
            <summary>Reset the signer back to its initial state.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignerWithRecovery">
            Signer with message recovery.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignerWithRecovery.HasFullMessage">
             Returns true if the signer has recovered the full message as
             part of signature verification.
            
             @return true if full message recovered.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignerWithRecovery.GetRecoveredMessage">
             Returns a reference to what message was recovered (if any).
            
             @return full/partial message, null if nothing.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignerWithRecovery.UpdateWithRecoveredMessage(System.Byte[])">
             Perform an update with the recovered message before adding any other data. This must
             be the first update method called, and calling it will result in the signer assuming
             that further calls to update will include message content past what is recoverable.
            
             @param signature the signature that we are in the process of verifying.
             @throws IllegalStateException
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IStreamCalculator`1">
            <summary>
            Base interface for cryptographic operations such as Hashes, MACs, and Signatures which reduce a stream of data
            to a single value.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IStreamCalculator`1.Stream">
            <summary>Return a "sink" stream which only exists to update the implementing object.</summary>
            <returns>A stream to write to in order to update the implementing object.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IStreamCalculator`1.GetResult">
            <summary>
            Return the result of processing the stream. This value is only available once the stream
            has been closed.
            </summary>
            <returns>The result of processing the stream.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IStreamCipher">
            <summary>The interface stream ciphers conform to.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IStreamCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IStreamCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">If true the cipher is initialised for encryption,
            if false for decryption.</param>
            <param name="parameters">The key and other data required by the cipher.</param>
            <exception cref="T:System.ArgumentException">
            If the parameters argument is inappropriate.
            </exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IStreamCipher.ReturnByte(System.Byte)">
            <summary>encrypt/decrypt a single byte returning the result.</summary>
            <param name="input">the byte to be processed.</param>
            <returns>the result of processing the input byte.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IStreamCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Process a block of bytes from <paramref name="input"/>, putting the result into <paramref name="output"/>.
            </summary>
            <param name="input">The input byte array.</param>
            <param name="inOff">
            The offset into <c>input</c> where the data to be processed starts.
            </param>
            <param name="length">The number of bytes to be processed.</param>
            <param name="output">The output buffer the processed bytes go into.</param>
            <param name="outOff">
            The offset into <c>output</c> the processed data starts at.
            </param>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.DataLengthException">If the input buffer is too small.</exception>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.OutputLengthException">If the output buffer is too small.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IStreamCipher.ProcessBytes(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
            <summary>
            Process a block of bytes from <paramref name="input"/>, putting the result into <paramref name="output"/>.
            </summary>
            <param name="input">The input span.</param>
            <param name="output">The output span.</param>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.OutputLengthException">If the output span is too small.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IStreamCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IVerifier">
            <summary>
            Operators that reduce their input to the validation of a signature produce this type.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IVerifier.IsVerified(System.Byte[])">
            <summary>
            Return true if the passed in data matches what is expected by the verification result.
            </summary>
            <param name="data">The bytes representing the signature.</param>
            <returns>true if the signature verifies, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IVerifier.IsVerified(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Return true if the length bytes from off in the source array match the signature
            expected by the verification result.
            </summary>
            <param name="source">Byte array containing the signature.</param>
            <param name="off">The offset into the source array where the signature starts.</param>
            <param name="length">The number of bytes in source making up the signature.</param>
            <returns>true if the signature verifies, false otherwise.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IVerifierFactory">
            <summary>
            Base interface for operators that serve as stream-based signature verifiers.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IVerifierFactory.AlgorithmDetails">
            <summary>The algorithm details object for this verifier.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IVerifierFactory.CreateCalculator">
            <summary>
            Create a stream calculator for this verifier. The stream
            calculator is used for the actual operation of entering the data to be verified
            and producing a result which can be used to verify the original signature.
            </summary>
            <returns>A calculator producing an IVerifier which can verify the signature.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IVerifierFactoryProvider">
            <summary>
            Base interface for a provider to support the dynamic creation of signature verifiers.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IVerifierFactoryProvider.CreateVerifierFactory(System.Object)">
            <summary>
            Return a signature verfier for signature algorithm described in the passed in algorithm details object.
            </summary>
            <param name="algorithmDetails">The details of the signature algorithm verification is required for.</param>
            <returns>A new signature verifier.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IWrapper.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IXof">
            <remarks>
            With FIPS PUB 202 a new kind of message digest was announced which supported extendable output, or variable digest sizes.
            This interface provides the extra methods required to support variable output on a digest implementation.
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IXof.OutputFinal(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Output the results of the final calculation for this XOF to outLen number of bytes.
            </summary>
            <param name="output">output array to write the output bytes to.</param>
            <param name="outOff">offset to start writing the bytes at.</param>
            <param name="outLen">the number of output bytes requested.</param>
            <returns>the number of bytes written</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IXof.OutputFinal(System.Span{System.Byte})">
            <summary>
            Output the results of the final calculation for this XOF to fill the output span.
            </summary>
            <param name="output">span to fill with the output bytes.</param>
            <returns>the number of bytes written</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IXof.Output(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Start outputting the results of the final calculation for this XOF. Unlike DoFinal, this method
            will continue producing output until the XOF is explicitly reset, or signals otherwise.
            </summary>
            <param name="output">output array to write the output bytes to.</param>
            <param name="outOff">offset to start writing the bytes at.</param>
            <param name="outLen">the number of output bytes requested.</param>
            <returns>the number of bytes written</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IXof.Output(System.Span{System.Byte})">
            <summary>
            Start outputting the results of the final calculation for this XOF. Unlike OutputFinal, this method
            will continue producing output until the XOF is explicitly reset, or signals otherwise.
            </summary>
            <param name="output">span to fill with the output bytes.</param>
            <returns>the number of bytes written</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.KeyGenerationParameters">
            The base class for parameters to key generators.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.KeyGenerationParameters.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom,System.Int32)">
             initialise the generator with a source of randomness
             and a strength (in bits).
            
             @param random the random byte source.
             @param strength the size, in bits, of the keys we want to produce.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.KeyGenerationParameters.Random">
             return the random source associated with this
             generator.
            
             @return the generators random source.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.KeyGenerationParameters.Strength">
             return the bit strength for keys produced by this generator,
            
             @return the strength of the keys this generator produces (in bits).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac">
            standard CBC Block Cipher MAC - if no padding is specified the default of
            pad of zeroes is used.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
             create a standard MAC based on a CBC block cipher. This will produce an
             authentication code half the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             create a standard MAC based on a CBC block cipher. This will produce an
             authentication code half the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
             @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
            @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.MacCfbBlockCipher">
            implements a Cipher-FeedBack (CFB) mode on top of a simple cipher.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.MacCfbBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.MacCfbBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.MacCfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CFB"
             and the block size in bits.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.MacCfbBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.MacCfbBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
             create a standard MAC based on a CFB block cipher. This will produce an
             authentication code half the length of the block size of the cipher, with
             the CFB mode set to 8 bits.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             create a standard MAC based on a CFB block cipher. This will produce an
             authentication code half the length of the block size of the cipher, with
             the CFB mode set to 8 bits.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
             @param padding the padding to be used.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,System.Int32)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CFB mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param cfbBitSize the size of an output block produced by the CFB mode.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CFB mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param cfbBitSize the size of an output block produced by the CFB mode.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
            @param padding a padding to be used.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.CMac">
            CMAC - as specified at www.nuee.nagoya-u.ac.jp/labs/tiwata/omac/omac.html
            <p>
            CMAC is analogous to OMAC1 - see also en.wikipedia.org/wiki/CMAC
            </p><p>
            CMAC is a NIST recomendation - see 
            csrc.nist.gov/CryptoToolkit/modes/800-38_Series_Publications/SP800-38B.pdf
            </p><p>
            CMAC/OMAC1 is a blockcipher-based message authentication code designed and
            analyzed by Tetsu Iwata and Kaoru Kurosawa.
            </p><p>
            CMAC/OMAC1 is a simple variant of the CBC MAC (Cipher Block Chaining Message 
            Authentication Code). OMAC stands for One-Key CBC MAC.
            </p><p>
            It supports 128- or 64-bits block ciphers, with any key size, and returns
            a MAC with dimension less or equal to the block size of the underlying 
            cipher.
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.CMac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
             create a standard MAC based on a CBC block cipher (64 or 128 bit block).
             This will produce an authentication code the length of the block size
             of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.CMac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             create a standard MAC based on a block cipher with the size of the
             MAC been given in bits.
             <p/>
             Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
             or 16 bits if being used as a data authenticator (FIPS Publication 113),
             and in general should be less than the size of the block cipher as it reduces
             the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            
             @param cipher        the cipher to be used as the basis of the MAC generation.
             @param macSizeInBits the size of the MAC in bits, must be a multiple of 8 and @lt;= 128.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.CMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Dstu7564Mac">
            <summary>
            Implementation of DSTU7564 mac mode
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Dstu7624Mac">
            implementation of DSTU 7624 MAC
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.GMac">
            <summary>
            The GMAC specialisation of Galois/Counter mode (GCM) detailed in NIST Special Publication
            800-38D.
            </summary>
            <remarks>
            GMac is an invocation of the GCM mode where no data is encrypted (i.e. all input data to the Mac
            is processed as additional authenticated data with the underlying GCM block cipher).
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.GMac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmBlockCipher)">
            <summary>
            Creates a GMAC based on the operation of a block cipher in GCM mode.
            </summary>
            <remarks>
            This will produce an authentication code the length of the block size of the cipher.
            </remarks>
            <param name="cipher">the cipher to be used in GCM mode to generate the MAC.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.GMac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmBlockCipher,System.Int32)">
            <summary>
            Creates a GMAC based on the operation of a 128 bit block cipher in GCM mode.
            </summary>
            <remarks>
            This will produce an authentication code the length of the block size of the cipher.
            </remarks>
            <param name="cipher">the cipher to be used in GCM mode to generate the MAC.</param>
            <param name="macSizeBits">the mac size to generate, in bits. Must be a multiple of 8, between 32 and 128 (inclusive).
            Sizes less than 96 are not recommended, but are supported for specialized applications.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.GMac.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>
            Initialises the GMAC - requires a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.ParametersWithIV"/> 
            providing a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.KeyParameter"/> and a nonce.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Gost28147Mac">
            implementation of GOST 28147-89 MAC
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.HMac">
             HMAC implementation based on RFC2104
            
             H(K XOR opad, H(K XOR ipad, text))
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.HMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac">
             DES based CBC Block Cipher MAC according to ISO9797, algorithm 3 (ANSI X9.19 Retail MAC)
            
             This could as well be derived from CBCBlockCipherMac, but then the property mac in the base
             class must be changed to protected
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
             create a Retail-MAC based on a CBC block cipher. This will produce an
             authentication code of the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation. This must
             be DESEngine.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             create a Retail-MAC based on a CBC block cipher. This will produce an
             authentication code of the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
             @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
            create a Retail-MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses single DES CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses single DES CBC mode as the basis for the
            MAC generation. The final block is decrypted and then encrypted using the
            middle and right part of the key.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
            @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305">
            <summary>
            Poly1305 message authentication code, designed by D. J. Bernstein.
            </summary>
            <remarks>
            Poly1305 computes a 128-bit (16 bytes) authenticator, using a 128 bit nonce and a 256 bit key
            consisting of a 128 bit key applied to an underlying cipher, and a 128 bit key (with 106
            effective key bits) used in the authenticator.
            
            The polynomial calculation in this implementation is adapted from the public domain <a
            href="https://github.com/floodyberry/poly1305-donna">poly1305-donna-unrolled</a> C implementation
            by Andrew M (@floodyberry).
            </remarks>
            <seealso cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator"/>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.r0">
            Polynomial key 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.r1">
            Polynomial key 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.r2">
            Polynomial key 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.r3">
            Polynomial key 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.r4">
            Polynomial key 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.s1">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.s2">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.s3">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.s4">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.k0">
            Encrypted nonce 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.k1">
            Encrypted nonce 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.k2">
            Encrypted nonce 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.k3">
            Encrypted nonce 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.currentBlock">
            Current block of buffered input 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.currentBlockOffset">
            Current offset in input buffer 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.h0">
            Polynomial accumulator 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.h1">
            Polynomial accumulator 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.h2">
            Polynomial accumulator 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.h3">
            Polynomial accumulator 
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.h4">
            Polynomial accumulator 
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.#ctor">
            Constructs a Poly1305 MAC, where the key passed to init() will be used directly.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
            Constructs a Poly1305 MAC, using a 128 bit block cipher.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.Poly1305.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>
            Initialises the Poly1305 MAC.
            </summary>
            <param name="parameters">a {@link ParametersWithIV} containing a 128 bit nonce and a {@link KeyParameter} with
                     a 256 bit key complying to the {@link Poly1305KeyGenerator Poly1305 key format}.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.SipHash">
            <summary>
            Implementation of SipHash as specified in "SipHash: a fast short-input PRF", by Jean-Philippe
            Aumasson and Daniel J. Bernstein (https://131002.net/siphash/siphash.pdf).
            </summary>
            <remarks>
            "SipHash is a family of PRFs SipHash-c-d where the integer parameters c and d are the number of
            compression rounds and the number of finalization rounds. A compression round is identical to a
            finalization round and this round function is called SipRound. Given a 128-bit key k and a
            (possibly empty) byte string m, SipHash-c-d returns a 64-bit value..."
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.SipHash.#ctor">
            <summary>SipHash-2-4</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.SipHash.#ctor(System.Int32,System.Int32)">
            <summary>SipHash-c-d</summary>
            <param name="c">the number of compression rounds</param>
            <param name="d">the number of finalization rounds</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.SkeinMac">
            <summary>
            Implementation of the Skein parameterised MAC function in 256, 512 and 1024 bit block sizes,
            based on the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Engines.ThreefishEngine">Threefish</see> tweakable block cipher.
            </summary>
            <remarks>
            This is the 1.3 version of Skein defined in the Skein hash function submission to the NIST SHA-3
            competition in October 2010.
            <p/>
            Skein was designed by Niels Ferguson - Stefan Lucks - Bruce Schneier - Doug Whiting - Mihir
            Bellare - Tadayoshi Kohno - Jon Callas - Jesse Walker.
            </remarks>
            <seealso cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine"/>
            <seealso cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters"/>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.SkeinMac.SKEIN_256">
            <summary>
            256 bit block size - Skein-256
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.SkeinMac.SKEIN_512">
            <summary>
            512 bit block size - Skein-512
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.SkeinMac.SKEIN_1024">
            <summary>
            1024 bit block size - Skein-1024
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.SkeinMac.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a Skein MAC with an internal state size and output size.
            </summary>
            <param name="stateSizeBits">the internal state size in bits - one of <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.SkeinMac.SKEIN_256"/> <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.SkeinMac.SKEIN_512"/> or
                                  <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.SkeinMac.SKEIN_1024"/>.</param>
            <param name="digestSizeBits">the output/MAC size to produce in bits, which must be an integral number of
                                 bytes.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.SkeinMac.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>
            Optionally initialises the Skein digest with the provided parameters.
            </summary>
            See <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters"></see> for details on the parameterisation of the Skein hash function.
            <param name="parameters">the parameters to apply to this engine, or <code>null</code> to use no parameters.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.MaxBytesExceededException">
            <summary>This exception is thrown whenever a cipher requires a change of key, IV or similar after x amount of
            bytes enciphered.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CbcBlockCipher">
            implements Cipher-Block-Chaining (CBC) mode on top of a simple cipher.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of chaining.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CBC".
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.GetBlockSize">
             return the block size of the underlying cipher.
            
             @return the block size of the underlying cipher.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CcmBlockCipher">
            Implements the Counter with Cipher Block Chaining mode (CCM) detailed in
            NIST Special Publication 800-38C.
            <p>
            <b>Note</b>: this mode is a packet mode - it needs all the data up front.
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.GetMac">
             Returns a byte array containing the mac calculated as part of the
             last encrypt or decrypt operation.
            
             @return the last mac calculated.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.ProcessPacket(System.Byte[],System.Int32,System.Int32)">
             Process a packet of data for either CCM decryption or encryption.
            
             @param in data for processing.
             @param inOff offset at which data starts in the input array.
             @param inLen length of the data in the input array.
             @return a byte array containing the processed input..
             @throws IllegalStateException if the cipher is not appropriately set up.
             @throws InvalidCipherTextException if the input data is truncated or the mac check fails.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.ProcessPacket(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             Process a packet of data for either CCM decryption or encryption.
            
             @param in data for processing.
             @param inOff offset at which data starts in the input array.
             @param inLen length of the data in the input array.
             @param output output array.
             @param outOff offset into output array to start putting processed bytes.
             @return the number of bytes added to output.
             @throws IllegalStateException if the cipher is not appropriately set up.
             @throws InvalidCipherTextException if the input data is truncated or the mac check fails.
             @throws DataLengthException if output buffer too short.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CfbBlockCipher">
            implements a Cipher-FeedBack (CFB) mode on top of a simple cipher.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CFB"
             and the block size in bits.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CtsBlockCipher">
            A Cipher Text Stealing (CTS) mode cipher. CTS allows block ciphers to
            be used to produce cipher text which is the same outLength as the plain text.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IBlockCipherMode)">
             Create a buffered block cipher that uses Cipher Text Stealing
            
             @param cipher the underlying block cipher this buffering object wraps.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update of 'length' bytes.
            
             @param length the outLength of the input.
             @return the space required to accommodate a call to update
             with length bytes of input.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of length bytes.
            
             @param length the outLength of the input.
             @return the space required to accommodate a call to update and doFinal
             with length bytes of input.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param length the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if cipher text decrypts wrongly (in
             case the exception will never Get thrown).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.EaxBlockCipher">
            A Two-Pass Authenticated-Encryption Scheme Optimized for Simplicity and 
            Efficiency - by M. Bellare, P. Rogaway, D. Wagner.
            
            http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf
            
            EAX is an AEAD scheme based on CTR and OMAC1/CMAC, that uses a single block 
            cipher to encrypt and authenticate data. It's on-line (the length of a 
            message isn't needed to begin processing it), has good performances, it's
            simple and provably secure (provided the underlying block cipher is secure).
            
            Of course, this implementations is NOT thread-safe.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.EaxBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
             Constructor that accepts an instance of a block cipher engine.
            
             @param cipher the engine to use
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmBlockCipher">
            <summary>
            Implements the Galois/Counter mode (GCM) detailed in NIST Special Publication 800-38D.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <remarks>
            MAC sizes from 32 bits to 128 bits (must be a multiple of 8) are supported. The default is 128 bits.
            Sizes less than 96 are not recommended, but are supported for specialized applications.
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher">
            GCM-SIV Mode.
            <p>It should be noted that the specified limit of 2<sup>36</sup> bytes is not supported. This is because all bytes are
            cached in a <b>ByteArrayOutputStream</b> object (which has a limit of a little less than 2<sup>31</sup> bytes),
            and are output on the <b>DoFinal</b>() call (which can only process a maximum of 2<sup>31</sup> bytes).</p>
            <p>The practical limit of 2<sup>31</sup> - 24 bytes is policed, and attempts to breach the limit will be rejected</p>
            <p>In order to properly support the higher limit, an extended form of <b>ByteArrayOutputStream</b> would be needed
            which would use multiple arrays to store the data. In addition, a new <b>doOutput</b> method would be required (similar
            to that in <b>XOF</b> digests), which would allow the data to be output over multiple calls. Alternatively an extended
            form of <b>ByteArrayInputStream</b> could be used to deliver the data.</p>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.BUFLEN">
            <summary>The buffer length.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.HALFBUFLEN">
            <summary>The halfBuffer length.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.NONCELEN">
            <summary>The nonce length.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.MAX_DATALEN">
            The maximum data length (AEAD/PlainText). Due to implementation constraints this is restricted to the maximum
            array length (https://programming.guide/java/array-maximum-length.html) minus the BUFLEN to allow for the MAC
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.MASK">
            The top bit mask.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.ADD">
            The addition constant.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.INIT">
            The initialisation flag.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.AEAD_COMPLETE">
            The aeadComplete flag.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.theCipher">
            The cipher.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.theMultiplier">
            The multiplier.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.theGHash">
            The gHash buffer.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.theReverse">
            The reverse buffer.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.theAEADHasher">
            The aeadHasher.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.theDataHasher">
            The dataHasher.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.thePlain">
            The plainDataStream.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.theEncData">
            The encryptedDataStream (decryption only).
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.forEncryption">
            Are we encrypting?
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.theInitialAEAD">
            The initialAEAD.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.theNonce">
            The nonce.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.theFlags">
            The flags.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.#ctor">
            Constructor.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
            Constructor.
            @param pCipher the underlying cipher
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.Gcm.IGcmMultiplier)">
            Constructor.
            @param pCipher the underlying cipher
            @param pMultiplier the multiplier
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.CheckAeadStatus(System.Int32)">
            check AEAD status.
            @param pLen the aeadLength
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.CheckStatus(System.Int32)">
            check status.
            @param pLen the dataLength
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.ResetStreams">
            Reset Streams.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.bufLength(System.Byte[])">
            Obtain buffer length (allowing for null).
            @param pBuffer the buffere
            @return the length
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.CalculateTag">
            calculate tag.
            @return the calculated tag
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.completePolyVal">
            complete polyVAL.
            @return the calculated value
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.gHashLengths">
            process lengths.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.gHASH(System.Byte[])">
            perform the next GHASH step.
            @param pNext the next value
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.xorBlock(System.Byte[],System.Byte[])">
            xor a full block buffer.
            @param pLeft the left operand and result
            @param pRight the right operand
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.xorBlock(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            xor a partial block buffer.
            @param pLeft the left operand and result
            @param pRight the right operand
            @param pOffset the offset in the right operand
            @param pLength the length of data in the right operand
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.incrementCounter(System.Byte[])">
            increment the counter.
            @param pCounter the counter to increment
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.mulX(System.Byte[])">
            multiply by X.
            @param pValue the value to adjust
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.DeriveKeys(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.KeyParameter)">
            Derive Keys.
            @param pKey the keyGeneration key
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.GcmSivHasher">
            Hash Control.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.GcmSivHasher.theBuffer">
            Cache.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.GcmSivHasher.theByte">
            Single byte cache.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.GcmSivHasher.numActive">
            Count of active bytes in cache.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.GcmSivHasher.numHashed">
            Count of hashed bytes.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.GcmSivHasher.getBytesProcessed">
            Obtain the count of bytes hashed.
            @return the count
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.GcmSivHasher.Reset">
            Reset the hasher.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.GcmSivHasher.UpdateHash(System.Byte)">
            update hash.
            @param pByte the byte
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.GcmSivHasher.UpdateHash(System.Byte[],System.Int32,System.Int32)">
            update hash.
            @param pBuffer the buffer
            @param pOffset the offset within the buffer
            @param pLen the length of data
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher.GcmSivHasher.completeHash">
            complete hash.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher">
            implements the GOST 28147 OFB counter mode (GCTR).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             counter mode (must have a 64 bit block size).
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param encrypting if true the cipher is initialised for
              encryption, if false for decryption.
             @param parameters the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is inappropriate.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/GCTR"
             and the block size in bits
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.GetBlockSize">
             return the block size we are operating at (in bytes).
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.Reset">
            reset the feedback vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher">
            <summary>An IAeadCipher based on an IBlockCipher.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.UnderlyingCipher">
            <summary>The block cipher underlying this algorithm.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IAeadCipher">
            <summary>
            A cipher mode that includes authenticated encryption with a streaming mode and optional
            associated data.
            </summary>
            <remarks>
            Implementations of this interface may operate in a packet mode (where all input data is
            buffered and processed during the call to DoFinal, or in a streaming mode (where output
            data is incrementally produced with each call to ProcessByte or ProcessBytes. This is
            important to consider during decryption: in a streaming mode, unauthenticated plaintext
            data may be output prior to the call to DoFinal that results in an authentication failure.
            The higher level protocol utilising this cipher must ensure the plaintext data is handled
            appropriately until the end of data is reached and the entire ciphertext is authenticated.
            </remarks>
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.AeadParameters"/>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IAeadCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IAeadCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <remarks>Parameter can either be an AeadParameters or a ParametersWithIV object.</remarks>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IAeadCipher.ProcessAadByte(System.Byte)">
            <summary>Add a single byte to the associated data check.</summary>
            <remarks>If the implementation supports it, this will be an online operation and will not retain the associated data.</remarks>
            <param name="input">The byte to be processed.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IAeadCipher.ProcessAadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Add a sequence of bytes to the associated data check.</summary>
            <remarks>If the implementation supports it, this will be an online operation and will not retain the associated data.</remarks>
            <param name="inBytes">The input byte array.</param>
            <param name="inOff">The offset into the input array where the data to be processed starts.</param>
            <param name="len">The number of bytes to be processed.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IAeadCipher.ProcessAadBytes(System.ReadOnlySpan{System.Byte})">
            <summary>Add a span of bytes to the associated data check.</summary>
            <remarks>If the implementation supports it, this will be an online operation and will not retain the associated data.</remarks>
            <param name="input">the span containing the data.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IAeadCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             Encrypt/decrypt a single byte.
            
             @param input the byte to be processed.
             @param outBytes the output buffer the processed byte goes into.
             @param outOff the offset into the output byte array the processed data starts at.
             @return the number of bytes written to out.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IAeadCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             Process a block of bytes from in putting the result into out.
            
             @param inBytes the input byte array.
             @param inOff the offset into the in array where the data to be processed starts.
             @param len the number of bytes to be processed.
             @param outBytes the output buffer the processed bytes go into.
             @param outOff the offset into the output byte array the processed data starts at.
             @return the number of bytes written to out.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IAeadCipher.DoFinal(System.Byte[],System.Int32)">
             Finish the operation either appending or verifying the MAC at the end of the data.
            
             @param outBytes space for any resulting output data.
             @param outOff offset into out to start copying the data at.
             @return number of bytes written into out.
             @throws InvalidOperationException if the cipher is in an inappropriate state.
             @throws InvalidCipherTextException if the MAC fails to match.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IAeadCipher.GetMac">
             Return the value of the MAC associated with the last stream processed.
            
             @return MAC for plaintext data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IAeadCipher.GetUpdateOutputSize(System.Int32)">
             Return the size of the output buffer required for a ProcessBytes
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to ProcessBytes
             with len bytes of input.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IAeadCipher.GetOutputSize(System.Int32)">
             Return the size of the output buffer required for a ProcessBytes plus a
             DoFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to ProcessBytes and DoFinal
             with len bytes of input.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IAeadCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IBlockCipherMode.UnderlyingCipher">
            <summary>Return the <code cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher"/> underlying this cipher mode.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IBlockCipherMode.IsPartialBlockOkay">
            <summary>Indicates whether this cipher mode can handle partial blocks.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IBlockCipherMode.Reset">
            <summary>
            Reset the cipher mode to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.KCcmBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
            <summary>
            Base constructor. Nb value is set to 4.
            </summary>
            <param name="engine">base cipher to use under CCM.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.KCcmBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
            <summary>
            Constructor allowing Nb configuration.
            
            Nb is a parameter specified in CCM mode of DSTU7624 standard.
            This parameter specifies maximum possible length of input.It should
            be calculated as follows: Nb = 1 / 8 * (-3 + log[2]Nmax) + 1,
            where Nmax - length of input message in bits.For practical reasons
            Nmax usually less than 4Gb, e.g. for Nmax = 2^32 - 1, Nb = 4.
            </summary>
            <param name="engine">base cipher to use under CCM.</param>
            <param name="Nb">Nb value to use.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.KCtrBlockCipher">
            Implements a Gamming or Counter (CTR) mode on top of a DSTU 7624 block cipher.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.KCtrBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.KCtrBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.KCtrBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.KCtrBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/KCTR"
             and the block size in bits.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.KCtrBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.KCtrBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param input the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param output the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.KCtrBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.OcbBlockCipher">
             <summary>An implementation of <a href="https://tools.ietf.org/html/rfc7253">RFC 7253 on The OCB
             Authenticated-Encryption Algorithm</a>.</summary>
             <remarks>
             For those still concerned about the original patents around this, please see:
             <para>https://mailarchive.ietf.org/arch/msg/cfrg/qLTveWOdTJcLn4HP3ev-vrj05Vg/</para>
             Text reproduced below:
             <para>
             Phillip Rogaway&lt;rogaway@cs.ucdavis.edu&gt; Sat, 27 February 2021 02:46 UTC
            
             I can confirm that I have abandoned all OCB patents and placed into the public domain all OCB-related IP of
             mine. While I have been telling people this for quite some time, I don't think I ever made a proper announcement
             to the CFRG or on the OCB webpage. Consider that done.
             </para>
             </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.OfbBlockCipher">
            implements a Output-FeedBack (OFB) mode on top of a simple cipher.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/OFB"
             and the block size in bits
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.GetBlockSize">
             return the block size we are operating at (in bytes).
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.Reset">
            reset the feedback vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher">
                * Implements OpenPGP's rather strange version of Cipher-FeedBack (CFB) mode
                * on top of a simple cipher. This class assumes the IV has been prepended
                * to the data stream already, and just accomodates the reset after
                * (blockSize + 2) bytes have been read.
                * <p>
                * For further info see <a href="http://www.ietf.org/rfc/rfc2440.html">RFC 2440</a>.
            	* </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/PGPCFB"
             and the block size in bits.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param parameters the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.EncryptByte(System.Byte,System.Int32)">
            Encrypt one byte of data according to CFB mode.
            @param data the byte to encrypt
            @param blockOff offset in the current block
            @returns the encrypted byte
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.SicBlockCipher">
            Implements the Segmented Integer Counter (SIC) mode on top of a simple
            block cipher.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.SicBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param c the block cipher to be used.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.SicBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Operators.X509Utilities.GetDigestAlgName(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory">
            <summary>
            Calculator factory class for signature generation in ASN.1 based profiles that use an AlgorithmIdentifier to preserve
            signature algorithm details.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory.#ctor(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Base constructor.
            </summary>
            <param name="algorithm">The name of the signature algorithm to use.</param>
            <param name="privateKey">The private key to be used in the signing operation.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory.#ctor(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Constructor which also specifies a source of randomness to be used if one is required.
            </summary>
            <param name="algorithm">The name of the signature algorithm to use.</param>
            <param name="privateKey">The private key to be used in the signing operation.</param>
            <param name="random">The source of randomness to be used in signature calculation.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the verifier provider.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactory">
            <summary>
            Verifier class for signature verification in ASN.1 based profiles that use an AlgorithmIdentifier to preserve
            signature algorithm details.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactory.#ctor(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Base constructor.
            </summary>
            <param name="algorithm">The name of the signature algorithm to use.</param>
            <param name="publicKey">The public key to be used in the verification operation.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactoryProvider">
            <summary>
            Provider class which supports dynamic creation of signature verifiers.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactoryProvider.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Base constructor - specify the public key to be used in verification.
            </summary>
            <param name="publicKey">The public key to be used in creating verifiers provided by this object.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactoryProvider.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the verifier provider.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding">
            <summary>Block cipher padders are expected to conform to this interface.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>Initialise the padder.</summary>
            <param name="random">A source of randomness, if any required.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PaddingName">
            <summary>The name of the algorithm this padder implements.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.AddPadding(System.Byte[],System.Int32)">
            <summary>Add padding to the passed in block.</summary>
            <param name="input">the block to add padding to.</param>
            <param name="inOff">the offset into the block the padding is to start at.</param>
            <returns>the number of bytes of padding added.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.AddPadding(System.Span{System.Byte},System.Int32)">
            <summary>Add padding to the passed in block.</summary>
            <param name="block">the block to add padding to.</param>
            <param name="position">the offset into the block the padding is to start at.</param>
            <returns>the number of bytes of padding added.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PadCount(System.Byte[])">
            <summary>Determine the length of padding present in the passed in block.</summary>
            <param name="input">the block to check padding for.</param>
            <returns>the number of bytes of padding present.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PadCount(System.ReadOnlySpan{System.Byte})">
            <summary>Determine the length of padding present in the passed in block.</summary>
            <param name="block">the block to check padding for.</param>
            <returns>the number of bytes of padding present.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding">
            A padder that adds ISO10126-2 padding to a block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random a SecureRandom if available.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding">
            A padder that adds the padding according to the scheme referenced in
            ISO 7814-4 - scheme 2 from ISO 9797-1. The first byte is 0x80, rest is 0x00
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random - a SecureRandom if available.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding.PaddingName">
             Return the name of the algorithm the padder implements.
            
             @return the name of the algorithm the padder implements.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion with padding. The PaddedBufferedBlockCipher
            outputs a block only when the buffer is full and more data is being added,
            or on a doFinal (unless the current block in the buffer is a pad block).
            The default padding mechanism used is the one outlined in Pkcs5/Pkcs7.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IBlockCipherMode,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             Create a buffered block cipher with the desired padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             @param padding the padding type.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IBlockCipherMode)">
             Create a buffered block cipher Pkcs7 padding
            
             @param cipher the underlying block cipher this buffering object wraps.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.GetOutputSize(System.Int32)">
             return the minimum size of the output buffer required for an update
             plus a doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer. If the buffer is currently
             full and padding needs to be added a call to doFinal will produce
             2 * GetBlockSize() bytes.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output or we are decrypting and the input is not block size aligned.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding">
            A padder that adds Pkcs7/Pkcs5 padding to a block.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random - a SecureRandom if available.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.TbcPadding">
            <summary> A padder that adds Trailing-Bit-Compliment padding to a block.
            <p>
            This padding pads the block out compliment of the last bit
            of the plain text.
            </p>
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.TbcPadding.PaddingName">
            <summary> Return the name of the algorithm the cipher implements.</summary>
            <returns> the name of the algorithm the cipher implements.
            </returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.TbcPadding.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary> Initialise the padder.</summary>
            <param name="random">- a SecureRandom if available.
            </param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.TbcPadding.AddPadding(System.Byte[],System.Int32)">
            <summary> add the pad bytes to the passed in block, returning the number of bytes added.</summary>
            <remarks>
            This assumes that the last block of plain text is always passed to it inside <paramref name="input"/>.
            i.e. if <paramref name="inOff"/> is zero, indicating the padding will fill the entire block,the value of
            <paramref name="input"/> should be the same as the last block of plain text.
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.TbcPadding.AddPadding(System.Span{System.Byte},System.Int32)">
            <summary> add the pad bytes to the passed in block, returning the number of bytes added.</summary>
            <remarks>
            This assumes that the last block of plain text is always passed to it inside <paramref name="block"/>.
            i.e. if <paramref name="position"/> is zero, indicating the padding will fill the entire block,the value of
            <paramref name="block"/> should be the same as the last block of plain text.
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.X923Padding">
            A padder that adds X9.23 padding to a block - if a SecureRandom is
            passed in random padding is assumed, otherwise padding with zeros is used.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.X923Padding.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random a SecureRandom if one is available.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.X923Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding">
            <summary> A padder that adds Null byte padding to a block.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding.PaddingName">
             <summary> Return the name of the algorithm the cipher implements.
            
             </summary>
             <returns> the name of the algorithm the cipher implements.
             </returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
             <summary> Initialise the padder.
            
             </summary>
             <param name="random">- a SecureRandom if available.
             </param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.AeadParameters.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Int32,System.Byte[])">
             Base constructor.
            
             @param key key to be used by underlying cipher
             @param macSize macSize in bits
             @param nonce nonce to be used
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.AeadParameters.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Int32,System.Byte[],System.Byte[])">
             Base constructor.
            
             @param key key to be used by underlying cipher
             @param macSize macSize in bits
             @param nonce nonce to be used
             @param associatedText associated text, if any
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.Blake3Parameters">
            <summary>Blake3 Parameters.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.Blake3Parameters.Context(System.Byte[])">
            <summary>Create a key parameter.</summary>
            <param name="pContext">the context</param>
            <returns>the parameter</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.Blake3Parameters.Key(System.Byte[])">
            <summary>Create a key parameter.</summary>
            <param name="pKey">the key</param>
            <returns>the parameter</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.Blake3Parameters.GetKey">
            <summary>Obtain the key.</summary>
            <returns>the key</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.Blake3Parameters.ClearKey">
            <summary>Clear the key bytes.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.Blake3Parameters.GetContext">
            <summary>Obtain the salt.</summary>
            <returns>the salt</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsWeakKey(System.Byte[],System.Int32,System.Int32)">
             return true if the passed in key is a DES-EDE weak key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
             @param length number of bytes making up the key
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsWeakKey(System.Byte[],System.Int32)">
             return true if the passed in key is a DES-EDE weak key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsRealEdeKey(System.Byte[],System.Int32)">
             return true if the passed in key is a real 2/3 part DES-EDE key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsReal2Key(System.Byte[],System.Int32)">
             return true if the passed in key is a real 2 part DES-EDE key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsReal3Key(System.Byte[],System.Int32)">
             return true if the passed in key is a real 3 part DES-EDE key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.DesParameters.IsWeakKey(System.Byte[],System.Int32)">
            DES has 16 weak keys.  This method will check
            if the given DES key material is weak or semi-weak.
            Key material that is too short is regarded as weak.
            <p>
            See <a href="http://www.counterpane.com/applied.html">"Applied
            Cryptography"</a> by Bruce Schneier for more information.
            </p>
            @return true if the given DES key material is weak or semi-weak,
                false otherwise.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.DesParameters.SetOddParity(System.Byte[])">
             DES Keys use the LSB as the odd parity bit.  This can
             be used to check for corrupt keys.
            
             @param bytes the byte array to set the parity on.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.DHParameters.M">
            <summary>The minimum bitlength of the private value.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.DHParameters.L">
            <summary>The bitlength of the private value.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.DsaParameterGenerationParameters.#ctor(System.Int32,System.Int32,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
             Construct without a usage index, this will do a random construction of G.
            
             @param L desired length of prime P in bits (the effective key size).
             @param N desired length of prime Q in bits.
             @param certainty certainty level for prime number generation.
             @param random the source of randomness to use.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.DsaParameterGenerationParameters.#ctor(System.Int32,System.Int32,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom,System.Int32)">
             Construct for a specific usage index - this has the effect of using verifiable canonical generation of G.
            
             @param L desired length of prime P in bits (the effective key size).
             @param N desired length of prime Q in bits.
             @param certainty certainty level for prime number generation.
             @param random the source of randomness to use.
             @param usageIndex a valid usage index.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.ElGamalParameters.G">
            return the generator - g
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.ElGamalParameters.L">
            return private value limit - l
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.HkdfParameters">
            Parameter class for the HkdfBytesGenerator class.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.HkdfParameters.#ctor(System.Byte[],System.Byte[],System.Byte[])">
             Generates parameters for HKDF, specifying both the optional salt and
             optional info. Step 1: Extract won't be skipped.
            
             @param ikm  the input keying material or seed
             @param salt the salt to use, may be null for a salt for hashLen zeros
             @param info the info to use, may be null for an info field of zero bytes
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.HkdfParameters.SkipExtractParameters(System.Byte[],System.Byte[])">
             Factory method that makes the HKDF skip the extract part of the key
             derivation function.
            
             @param ikm  the input keying material or seed, directly used for step 2:
                         Expand
             @param info the info to use, may be null for an info field of zero bytes
             @return HKDFParameters that makes the implementation skip step 1
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.HkdfParameters.GetIkm">
             Returns the input keying material or seed.
            
             @return the keying material
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.HkdfParameters.SkipExtract">
             Returns if step 1: extract has to be skipped or not
            
             @return true for skipping, false for no skipping of step 1
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.HkdfParameters.GetSalt">
             Returns the salt, or null if the salt should be generated as a byte array
             of HashLen zeros.
            
             @return the salt, or null
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.HkdfParameters.GetInfo">
             Returns the info field, which may be empty (null is converted to empty).
            
             @return the info field, never null
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.IesParameters">
            parameters for using an integrated cipher in stream mode.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.IesParameters.#ctor(System.Byte[],System.Byte[],System.Int32)">
            @param derivation the derivation parameter for the KDF function.
            @param encoding the encoding parameter for the KDF function.
            @param macKeySize the size of the MAC key (in bits).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.IesWithCipherParameters.#ctor(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            @param derivation the derivation parameter for the KDF function.
            @param encoding the encoding parameter for the KDF function.
            @param macKeySize the size of the MAC key (in bits).
            @param cipherKeySize the size of the associated Cipher key (in bits).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.Iso18033KdfParameters">
            parameters for Key derivation functions for ISO-18033
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.KdfCounterParameters.#ctor(System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Base constructor - suffix fixed input data only.
            </summary>
            <param name="ki">the KDF seed</param>
            <param name="fixedInputDataCounterSuffix">fixed input data to follow counter.</param>
            <param name="r">length of the counter in bits</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.KdfCounterParameters.#ctor(System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Base constructor - prefix and suffix fixed input data.
            </summary>
            <param name="ki">the KDF seed</param>
            <param name="fixedInputDataCounterPrefix">fixed input data to precede counter</param>
            <param name="fixedInputDataCounterSuffix">fixed input data to follow counter.</param>
            <param name="r">length of the counter in bits.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.KdfParameters">
            parameters for Key derivation functions for IEEE P1363a
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.MgfParameters">
            <remarks>Parameters for mask derivation functions.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters">
             Parameters for NaccacheStern public private key generation. For details on
             this cipher, please see
            
             http://www.gemplus.com/smart/rd/publications/pdf/NS98pkcs.pdf
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom,System.Int32,System.Int32,System.Int32)">
             Parameters for generating a NaccacheStern KeyPair.
            
             @param random
                        The source of randomness
             @param strength
                        The desired strength of the Key in Bits
             @param certainty
                        the probability that the generated primes are not really prime
                        as integer: 2^(-certainty) is then the probability
             @param countSmallPrimes
                        How many small key factors are desired
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters.Certainty">
            @return Returns the certainty.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters.CountSmallPrimes">
            @return Returns the countSmallPrimes.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters">
             Public key parameters for NaccacheStern cipher. For details on this cipher,
             please see
            
             http://www.gemplus.com/smart/rd/publications/pdf/NS98pkcs.pdf
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters.#ctor(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.Int32)">
            @param privateKey
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters.G">
            @return Returns the g.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters.LowerSigmaBound">
            @return Returns the lowerSigmaBound.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters.Modulus">
            @return Returns the n.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.NaccacheSternPrivateKeyParameters">
             Private key parameters for NaccacheStern cipher. For details on this cipher,
             please see
            
             http://www.gemplus.com/smart/rd/publications/pdf/NS98pkcs.pdf
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.NaccacheSternPrivateKeyParameters.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.Int32,System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger},Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
             Constructs a NaccacheSternPrivateKey
            
             @param g
                        the public enryption parameter g
             @param n
                        the public modulus n = p*q
             @param lowerSigmaBound
                        the public lower sigma bound up to which data can be encrypted
             @param smallPrimes
                        the small primes, of which sigma is constructed in the right
                        order
             @param phi_n
                        the private modulus phi(n) = (p-1)(q-1)
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.ParametersWithSalt">
            <summary> Cipher parameters with a fixed salt value associated with them.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters">
            <summary>
            Parameters for the Skein hash function - a series of byte[] strings identified by integer tags.
            </summary>
            <remarks>
            Parameterised Skein can be used for:
            <ul> 
            <li>MAC generation, by providing a <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetKey(System.Byte[])">key</see>.</li>
            <li>Randomised hashing, by providing a <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetNonce(System.Byte[])">nonce</see>.</li>
            <li>A hash function for digital signatures, associating a
            <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPublicKey(System.Byte[])">public key</see> with the message digest.</li>
            <li>A key derivation function, by providing a
            <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetKeyIdentifier(System.Byte[])">key identifier</see>.</li>
            <li>Personalised hashing, by providing a
            <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPersonalisation(System.DateTime,System.String,System.String)">recommended format</see> or
            <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPersonalisation(System.Byte[])">arbitrary</see> personalisation string.</li>
            </ul>
            </remarks>
            <seealso cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinEngine"/>
            <seealso cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Digests.SkeinDigest"/>
            <seealso cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.SkeinMac"/>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY">
            <summary>
            The parameter type for a secret key, supporting MAC or KDF functions: 0
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_CONFIG">
            <summary>
            The parameter type for the Skein configuration block: 4
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_PERSONALISATION">
            <summary>
            The parameter type for a personalisation string: 8
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_PUBLIC_KEY">
            <summary>
            The parameter type for a public key: 12
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY_IDENTIFIER">
            <summary>
            The parameter type for a key identifier string: 16
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_NONCE">
            <summary>
            The parameter type for a nonce: 20
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_MESSAGE">
            <summary>
            The parameter type for the message: 48
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_OUTPUT">
            <summary>
            The parameter type for the output transformation: 63
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetParameters">
            <summary>
            Obtains a map of type (int) to value (byte[]) for the parameters tracked in this object.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetKey">
            <summary>
            Obtains the value of the <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY">key parameter</see>, or <code>null</code> if not
            set.
            </summary>
            <returns>The key.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetPersonalisation">
            <summary>
            Obtains the value of the <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_PERSONALISATION">personalisation parameter</see>, or
            <code>null</code> if not set.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetPublicKey">
            <summary>
            Obtains the value of the <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_PUBLIC_KEY">public key parameter</see>, or
            <code>null</code> if not set.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetKeyIdentifier">
            <summary>
            Obtains the value of the <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY_IDENTIFIER">key identifier parameter</see>, or
            <code>null</code> if not set.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetNonce">
            <summary>
            Obtains the value of the <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_NONCE">nonce parameter</see>, or <code>null</code> if
            not set.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder">
            <summary>
            A builder for <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters"/>.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.Set(System.Int32,System.Byte[])">
            <summary>
            Sets a parameters to apply to the Skein hash function.
            </summary>
            <remarks>
            Parameter types must be in the range 0,5..62, and cannot use the value 48
            (reserved for message body).
            <p/>
            Parameters with type &lt; 48 are processed before
            the message content, parameters with type &gt; 48
            are processed after the message and prior to output.
            </remarks>
            <param name="type">the type of the parameter, in the range 5..62.</param>
            <param name="value">the byte sequence of the parameter.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetKey(System.Byte[])">
            <summary>
            Sets the <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY"/> parameter.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPersonalisation(System.Byte[])">
            <summary>
            Sets the <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_PERSONALISATION"/> parameter.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPersonalisation(System.DateTime,System.String,System.String)">
            <summary>
            Implements the recommended personalisation format for Skein defined in Section 4.11 of
            the Skein 1.3 specification.
            </summary>
            <remarks>
            The format is <code>YYYYMMDD email@address distinguisher</code>, encoded to a byte
            sequence using UTF-8 encoding.
            </remarks>
            <param name="date">the date the personalised application of the Skein was defined.</param>
            <param name="emailAddress">the email address of the creation of the personalised application.</param>
            <param name="distinguisher">an arbitrary personalisation string distinguishing the application.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPublicKey(System.Byte[])">
            <summary>
            Sets the <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY_IDENTIFIER"/> parameter.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetKeyIdentifier(System.Byte[])">
            <summary>
            Sets the <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY_IDENTIFIER"/> parameter.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetNonce(System.Byte[])">
            <summary>
            Sets the <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_NONCE"/> parameter.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.Build">
            <summary>
            Constructs a new <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SkeinParameters"/> instance with the parameters provided to this
            builder.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SM2KeyExchangePrivateParameters">
            <summary>Private parameters for an SM2 key exchange.</summary>
            <remarks>The ephemeralPrivateKey is used to calculate the random point used in the algorithm.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.SM2KeyExchangePublicParameters">
            <summary>Public parameters for an SM2 key exchange.</summary>
            <remarks>In this case the ephemeralPublicKey provides the random point used in the algorithm.</remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.TweakableBlockCipherParameters">
            <summary>
            Parameters for tweakable block ciphers.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.TweakableBlockCipherParameters.Key">
            <summary>
            Gets the key.
            </summary>
            <value>the key to use, or <code>null</code> to use the current key.</value>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.TweakableBlockCipherParameters.Tweak">
            <summary>
            Gets the tweak value.
            </summary>
            <value>The tweak to use, or <code>null</code> to use the current tweak.</value>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.PbeParametersGenerator">
            super class for all Password Based Encyrption (Pbe) parameter generator classes.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.PbeParametersGenerator.#ctor">
            base constructor.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.PbeParametersGenerator.Init(System.Byte[],System.Byte[],System.Int32)">
             initialise the Pbe generator.
            
             @param password the password converted into bytes (see below).
             @param salt the salt to be mixed with the password.
             @param iterationCount the number of iterations the "mixing" function
             is to be applied for.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.PbeParametersGenerator.IterationCount">
             return the iteration count.
            
             @return the iteration count.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.PbeParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate derived parameters for a key of length keySize, specifically
             for use with a MAC.
            
             @param keySize the length, in bits, of the key required.
             @return a parameters object representing a key.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.PbeParametersGenerator.Pkcs5PasswordToBytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             Pkcs5 (ascii, no padding)
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.PbeParametersGenerator.Pkcs5PasswordToUtf8Bytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             PKCS5 (UTF-8, no padding)
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.PbeParametersGenerator.Pkcs12PasswordToBytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             Pkcs12 (unicode, big endian, 2 zero pad bytes at the end).
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.BasicEntropySourceProvider">
            An EntropySourceProvider where entropy generation is based on a SecureRandom output using SecureRandom.generateSeed().
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.BasicEntropySourceProvider.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom,System.Boolean)">
             Create a entropy source provider based on the passed in SecureRandom.
            
             @param secureRandom the SecureRandom to base EntropySource construction on.
             @param isPredictionResistant boolean indicating if the SecureRandom is based on prediction resistant entropy or not (true if it is).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.BasicEntropySourceProvider.Get(System.Int32)">
             Return an entropy source that will create bitsRequired bits of entropy on
             each invocation of getEntropy().
            
             @param bitsRequired size (in bits) of entropy to be created by the provided source.
             @return an EntropySource that generates bitsRequired bits of entropy on each call to its getEntropy() method.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.CryptoApiRandomGenerator">
            <summary>
            Uses RandomNumberGenerator.Create() to get randomness generator
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.DigestRandomGenerator">
            Random generation based on the digest with counter. Calling AddSeedMaterial will
            always increase the entropy of the hash.
            <p>
            Internal access to the digest is synchronized so a single one of these can be shared.
            </p>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.CtrSP800Drbg">
            A SP800-90A CTR DRBG.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.CtrSP800Drbg.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IEntropySource,System.Byte[],System.Byte[])">
            Construct a SP800-90A CTR DRBG.
            <p>
            Minimum entropy requirement is the security strength requested.
            </p>
            @param engine underlying block cipher to use to support DRBG
            @param keySizeInBits size of the key to use with the block cipher.
            @param securityStrength security strength required (in bits)
            @param entropySource source of entropy to use for seeding/reseeding.
            @param personalizationString personalization string to distinguish this DRBG (may be null).
            @param nonce nonce to further distinguish this DRBG (may be null).
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.CtrSP800Drbg.BlockSize">
             Return the block size (in bits) of the DRBG.
            
             @return the number of bits produced on each internal round of the DRBG.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.CtrSP800Drbg.Generate(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Boolean)">
             Populate a passed in array with random data.
            
             @param output output array for generated bits.
             @param additionalInput additional input to be added to the DRBG in this step.
             @param predictionResistant true if a reseed should be forced, false otherwise.
            
             @return number of bits generated, -1 if a reseed required.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.CtrSP800Drbg.Reseed(System.Byte[])">
             Reseed the DRBG.
            
             @param additionalInput additional input to be added to the DRBG in this step.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.CtrSP800Drbg.PadKey(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Pad out a key for TDEA, setting odd parity for each byte.
            
             @param keyMaster
             @param keyOff
             @param tmp
             @param tmpOff
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.DrbgUtilities.HashDF(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,System.ReadOnlySpan{System.Byte},System.Int32,System.Span{System.Byte})">
            Used by both Dual EC and Hash.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.HashSP800Drbg">
            A SP800-90A Hash DRBG.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.HashSP800Drbg.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IEntropySource,System.Byte[],System.Byte[])">
            Construct a SP800-90A Hash DRBG.
            <p>
            Minimum entropy requirement is the security strength requested.
            </p>
            @param digest  source digest to use for DRB stream.
            @param securityStrength security strength required (in bits)
            @param entropySource source of entropy to use for seeding/reseeding.
            @param personalizationString personalization string to distinguish this DRBG (may be null).
            @param nonce nonce to further distinguish this DRBG (may be null).
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.HashSP800Drbg.BlockSize">
             Return the block size (in bits) of the DRBG.
            
             @return the number of bits produced on each internal round of the DRBG.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.HashSP800Drbg.Generate(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Boolean)">
             Populate a passed in array with random data.
            
             @param output output array for generated bits.
             @param additionalInput additional input to be added to the DRBG in this step.
             @param predictionResistant true if a reseed should be forced, false otherwise.
            
             @return number of bits generated, -1 if a reseed required.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.HashSP800Drbg.Reseed(System.Byte[])">
             Reseed the DRBG.
            
             @param additionalInput additional input to be added to the DRBG in this step.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.HMacSP800Drbg">
            A SP800-90A HMAC DRBG.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.HMacSP800Drbg.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IMac,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IEntropySource,System.Byte[],System.Byte[])">
            Construct a SP800-90A Hash DRBG.
            <p>
            Minimum entropy requirement is the security strength requested.
            </p>
            @param hMac Hash MAC to base the DRBG on.
            @param securityStrength security strength required (in bits)
            @param entropySource source of entropy to use for seeding/reseeding.
            @param personalizationString personalization string to distinguish this DRBG (may be null).
            @param nonce nonce to further distinguish this DRBG (may be null).
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.HMacSP800Drbg.BlockSize">
             Return the block size (in bits) of the DRBG.
            
             @return the number of bits produced on each round of the DRBG.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.HMacSP800Drbg.Generate(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Boolean)">
             Populate a passed in array with random data.
            
             @param output output array for generated bits.
             @param additionalInput additional input to be added to the DRBG in this step.
             @param predictionResistant true if a reseed should be forced, false otherwise.
            
             @return number of bits generated, -1 if a reseed required.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.HMacSP800Drbg.Reseed(System.Byte[])">
             Reseed the DRBG.
            
             @param additionalInput additional input to be added to the DRBG in this step.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.ISP80090Drbg">
            Interface to SP800-90A deterministic random bit generators.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.ISP80090Drbg.BlockSize">
             Return the block size of the DRBG.
            
             @return the block size (in bits) produced by each round of the DRBG.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.ISP80090Drbg.Generate(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Boolean)">
             Populate a passed in array with random data.
            
             @param output output array for generated bits.
             @param additionalInput additional input to be added to the DRBG in this step.
             @param predictionResistant true if a reseed should be forced, false otherwise.
            
             @return number of bits generated, -1 if a reseed required.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.Drbg.ISP80090Drbg.Reseed(System.Byte[])">
             Reseed the DRBG.
            
             @param additionalInput additional input to be added to the DRBG in this step.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.EntropyUtilities.GenerateSeed(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IEntropySource,System.Int32)">
             Generate numBytes worth of entropy from the passed in entropy source.
            
             @param entropySource the entropy source to request the data from.
             @param numBytes the number of bytes of entropy requested.
             @return a byte array populated with the random data.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.IRandomGenerator">
            <remarks>Generic interface for objects generating random bytes.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.IRandomGenerator.AddSeedMaterial(System.Byte[])">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A byte array to be mixed into the generator's state.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.IRandomGenerator.AddSeedMaterial(System.Int64)">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A long value to be mixed into the generator's state.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.IRandomGenerator.NextBytes(System.Byte[])">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to be filled.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.IRandomGenerator.NextBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to receive bytes.</param>
            <param name="start">Index to start filling at.</param>
            <param name="len">Length of segment to fill.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.SP800SecureRandom.Reseed(System.Byte[])">
            <summary>Force a reseed of the DRBG.</summary>
            <param name="additionalInput">optional additional input</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder">
            Builder class for making SecureRandom objects based on SP 800-90A Deterministic Random Bit Generators (DRBG).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.#ctor">
            Basic constructor, creates a builder using an EntropySourceProvider based on the default SecureRandom with
            predictionResistant set to false.
            <p>
            Any SecureRandom created from a builder constructed like this will make use of input passed to SecureRandom.setSeed() if
            the default SecureRandom does for its generateSeed() call.
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom,System.Boolean)">
            Construct a builder with an EntropySourceProvider based on the passed in SecureRandom and the passed in value
            for prediction resistance.
            <p>
            Any SecureRandom created from a builder constructed like this will make use of input passed to SecureRandom.setSeed() if
            the passed in SecureRandom does for its generateSeed() call.
            </p>
            @param entropySource
            @param predictionResistant
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IEntropySourceProvider)">
            Create a builder which makes creates the SecureRandom objects from a specified entropy source provider.
            <p>
            <b>Note:</b> If this constructor is used any calls to setSeed() in the resulting SecureRandom will be ignored.
            </p>
            @param entropySourceProvider a provider of EntropySource objects.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.SetPersonalizationString(System.Byte[])">
            Set the personalization string for DRBG SecureRandoms created by this builder
            @param personalizationString  the personalisation string for the underlying DRBG.
            @return the current builder.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.SetSecurityStrength(System.Int32)">
             Set the security strength required for DRBGs used in building SecureRandom objects.
            
             @param securityStrength the security strength (in bits)
             @return the current builder.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.SetEntropyBitsRequired(System.Int32)">
             Set the amount of entropy bits required for seeding and reseeding DRBGs used in building SecureRandom objects.
            
             @param entropyBitsRequired the number of bits of entropy to be requested from the entropy source on each seed/reseed.
             @return the current builder.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.BuildHash(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,System.Byte[],System.Boolean)">
             Build a SecureRandom based on a SP 800-90A Hash DRBG.
            
             @param digest digest algorithm to use in the DRBG underneath the SecureRandom.
             @param nonce  nonce value to use in DRBG construction.
             @param predictionResistant specify whether the underlying DRBG in the resulting SecureRandom should reseed on each request for bytes.
             @return a SecureRandom supported by a Hash DRBG.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.BuildCtr(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,System.Byte[],System.Boolean)">
             Build a SecureRandom based on a SP 800-90A CTR DRBG.
            
             @param cipher the block cipher to base the DRBG on.
             @param keySizeInBits key size in bits to be used with the block cipher.
             @param nonce nonce value to use in DRBG construction.
             @param predictionResistant  specify whether the underlying DRBG in the resulting SecureRandom should reseed on each request for bytes.
             @return  a SecureRandom supported by a CTR DRBG.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.BuildHMac(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IMac,System.Byte[],System.Boolean)">
             Build a SecureRandom based on a SP 800-90A HMAC DRBG.
            
             @param hMac HMAC algorithm to use in the DRBG underneath the SecureRandom.
             @param nonce  nonce value to use in DRBG construction.
             @param predictionResistant specify whether the underlying DRBG in the resulting SecureRandom should reseed on each request for bytes.
             @return a SecureRandom supported by a HMAC DRBG.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.VmpcRandomGenerator.P">
            <remarks>
            Permutation generated by code:
            <code>
            // First 1850 fractional digit of Pi number. 
            byte[] key = new BigInteger("14159265358979323846...5068006422512520511").ToByteArray();
            s = 0;
            P = new byte[256];
            for (int i = 0; i &lt; 256; i++) 
            {
                P[i] = (byte) i;
            }
            for (int m = 0; m &lt; 768; m++) 
            {
                s = P[(s + P[m &amp; 0xff] + key[m % key.length]) &amp; 0xff];
                byte temp = P[m &amp; 0xff];
                P[m &amp; 0xff] = P[s &amp; 0xff];
                P[s &amp; 0xff] = temp;
            } </code>
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.VmpcRandomGenerator.s">
            <remarks>Value generated in the same way as <c>P</c>.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.X931Rng.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,System.Byte[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IEntropySource)">
            
             @param engine
             @param entropySource
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.X931Rng.Reseed">
            Reseed the RNG.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.X931SecureRandomBuilder.#ctor">
            Basic constructor, creates a builder using an EntropySourceProvider based on the default SecureRandom with
            predictionResistant set to false.
            <p>
            Any SecureRandom created from a builder constructed like this will make use of input passed to SecureRandom.setSeed() if
            the default SecureRandom does for its generateSeed() call.
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.X931SecureRandomBuilder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom,System.Boolean)">
            Construct a builder with an EntropySourceProvider based on the passed in SecureRandom and the passed in value
            for prediction resistance.
            <p>
            Any SecureRandom created from a builder constructed like this will make use of input passed to SecureRandom.setSeed() if
            the passed in SecureRandom does for its generateSeed() call.
            </p>
            @param entropySource
            @param predictionResistant
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.X931SecureRandomBuilder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IEntropySourceProvider)">
            Create a builder which makes creates the SecureRandom objects from a specified entropy source provider.
            <p>
            <b>Note:</b> If this constructor is used any calls to setSeed() in the resulting SecureRandom will be ignored.
            </p>
            @param entropySourceProvider a provider of EntropySource objects.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.X931SecureRandomBuilder.Build(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Boolean)">
             Construct a X9.31 secure random generator using the passed in engine and key. If predictionResistant is true the
             generator will be reseeded on each request.
            
             @param engine a block cipher to use as the operator.
             @param key the block cipher key to initialise engine with.
             @param predictionResistant true if engine to be reseeded on each use, false otherwise.
             @return a SecureRandom.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.DsaSigner">
            The Digital Signature Algorithm - as described in "Handbook of Applied
            Cryptography", pages 452 - 453.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.DsaSigner.#ctor">
            Default configuration, random K values.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.DsaSigner.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.IDsaKCalculator)">
             Configuration with an alternate, possibly deterministic calculator of K.
            
             @param kCalculator a K value calculator.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.DsaSigner.GenerateSignature(System.Byte[])">
             Generate a signature for the given message using the key we were
             initialised with. For conventional DSA the message should be a SHA-1
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.DsaSigner.VerifySignature(System.Byte[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a DSA signature for
            the passed in message for standard DSA the message should be a
            SHA-1 hash of the real message to be verified.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.ECDsaSigner">
            EC-DSA as described in X9.62
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.ECDsaSigner.#ctor">
            Default configuration, random K values.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.ECDsaSigner.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.IDsaKCalculator)">
             Configuration with an alternate, possibly deterministic calculator of K.
            
             @param kCalculator a K value calculator.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.ECDsaSigner.GenerateSignature(System.Byte[])">
             Generate a signature for the given message using the key we were
             initialised with. For conventional DSA the message should be a SHA-1
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.ECDsaSigner.VerifySignature(System.Byte[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a DSA signature for
            the passed in message (for standard DSA the message should be
            a SHA-1 hash of the real message to be verified).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.ECGost3410Signer">
            GOST R 34.10-2001 Signature Algorithm
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.ECGost3410Signer.GenerateSignature(System.Byte[])">
             generate a signature for the given message using the key we were
             initialised with. For conventional GOST3410 the message should be a GOST3411
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.ECGost3410Signer.VerifySignature(System.Byte[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a GOST3410 signature for
            the passed in message (for standard GOST3410 the message should be
            a GOST3411 hash of the real message to be verified).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.ECNRSigner">
            EC-NR as described in IEEE 1363-2000
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.ECNRSigner.GenerateSignature(System.Byte[])">
             generate a signature for the given message using the key we were
             initialised with.  Generally, the order of the curve should be at
             least as long as the hash of the message of interest, and with
             ECNR it *must* be at least as long.
            
             @param digest  the digest to be signed.
             @exception DataLengthException if the digest is longer than the key allows
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.ECNRSigner.VerifySignature(System.Byte[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
             return true if the value r and s represent a signature for the
             message passed in. Generally, the order of the curve should be at
             least as long as the hash of the message of interest, and with
             ECNR, it *must* be at least as long.  But just in case the signer
             applied mod(n) to the longer digest, this implementation will
             apply mod(n) during verification.
            
             @param digest  the digest to be verified.
             @param r       the r value of the signature.
             @param s       the s value of the signature.
             @exception DataLengthException if the digest is longer than the key allows
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.GenericSigner.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the signer for signing or verification.
            
             @param forSigning
                        true if for signing, false otherwise
             @param parameters
                        necessary parameters.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Gost3410Signer">
            Gost R 34.10-94 Signature Algorithm
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Gost3410Signer.GenerateSignature(System.Byte[])">
             generate a signature for the given message using the key we were
             initialised with. For conventional Gost3410 the message should be a Gost3411
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Gost3410Signer.VerifySignature(System.Byte[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a Gost3410 signature for
            the passed in message for standard Gost3410 the message should be a
            Gost3411 hash of the real message to be verified.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.HMacDsaKCalculator">
            A deterministic K calculator based on the algorithm in section 3.2 of RFC 6979.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.HMacDsaKCalculator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
             Base constructor.
            
             @param digest digest to build the HMAC on.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.HMacDsaKCalculator.InitAdditionalInput0(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.HMac)">
            <summary>Supports use of additional input.</summary>
            <remarks>
            RFC 6979 3.6. Additional data may be added to the input of HMAC [..]. A use case may be a protocol that
            requires a non-deterministic signature algorithm on a system that does not have access to a high-quality
            random source. It suffices that the additional data[..] is non-repeating(e.g., a signature counter or a
            monotonic clock) to ensure "random-looking" signatures are indistinguishable, in a cryptographic way, from
            plain (EC)DSA signatures.
            <para/>
            By default there is no additional input. Override this method to supply additional input, bearing in mind
            that this calculator may be used for many signatures.
            </remarks>
            <param name="hmac0">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Macs.HMac"/> to which the additional input should be added.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.IDsaEncoding">
            <summary>
            An interface for different encoding formats for DSA signatures.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.IDsaEncoding.Decode(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.Byte[])">
            <summary>Decode the (r, s) pair of a DSA signature.</summary>
            <param name="n">The order of the group that r, s belong to.</param>
            <param name="encoding">An encoding of the (r, s) pair of a DSA signature.</param>
            <returns>The (r, s) of a DSA signature, stored in an array of exactly two elements, r followed by s.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.IDsaEncoding.Encode(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>Encode the (r, s) pair of a DSA signature.</summary>
            <param name="n">The order of the group that r, s belong to.</param>
            <param name="r">The r value of a DSA signature.</param>
            <param name="s">The s value of a DSA signature.</param>
            <returns>An encoding of the DSA signature given by the provided (r, s) pair.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.IDsaKCalculator">
            Interface define calculators of K values for DSA/ECDSA.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.IDsaKCalculator.IsDeterministic">
             Return true if this calculator is deterministic, false otherwise.
            
             @return true if deterministic, otherwise false.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.IDsaKCalculator.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
             Non-deterministic initialiser.
            
             @param n the order of the DSA group.
             @param random a source of randomness.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.IDsaKCalculator.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.Byte[])">
             Deterministic initialiser.
            
             @param n the order of the DSA group.
             @param d the DSA private value.
             @param message the message being signed.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.IDsaKCalculator.NextK">
             Return the next valid value of K.
            
             @return a K value.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner">
            <summary> ISO9796-2 - mechanism using a hash function with recovery (scheme 2 and 3).
            <p>
            Note: the usual length for the salt is the length of the hash
            function used in bytes.</p>
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.GetRecoveredMessage">
            <summary>
            Return a reference to the recoveredMessage message.
            </summary>
            <returns>The full/partial recoveredMessage message.</returns>
            <seealso cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignerWithRecovery.GetRecoveredMessage"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,System.Int32,System.Boolean)">
            <summary>
            Generate a signer with either implicit or explicit trailers for ISO9796-2, scheme 2 or 3.
            </summary>
            <param name="cipher">base cipher to use for signature creation/verification</param>
            <param name="digest">digest to use.</param>
            <param name="saltLength">length of salt in bytes.</param>
            <param name="isImplicit">whether or not the trailer is implicit or gives the hash.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,System.Int32)">
             <summary> Constructor for a signer with an explicit digest trailer.
            
             </summary>
             <param name="cipher">cipher to use.
             </param>
             <param name="digest">digest to sign with.
             </param>
             <param name="saltLength">length of salt in bytes.
             </param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the signer.</summary>
            <param name="forSigning">true if for signing, false if for verification.</param>
            <param name="parameters">parameters for signature generation/verification. If the
            parameters are for generation they should be a ParametersWithRandom,
            a ParametersWithSalt, or just an RsaKeyParameters object. If RsaKeyParameters
            are passed in a SecureRandom will be created.
            </param>
            <exception cref="T:System.ArgumentException">if wrong parameter type or a fixed
            salt is passed in which is the wrong length.
            </exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.IsSameAs(System.Byte[],System.Byte[])">
            <summary> compare two byte arrays - constant time.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.Update(System.Byte)">
            <summary> update the internal digest with the byte b</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.Reset">
            <summary> reset the internal state</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.GenerateSignature">
            <summary> Generate a signature for the loaded message using the key we were
            initialised with.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.VerifySignature(System.Byte[])">
            <summary> return true if the signature represents a ISO9796-2 signature
            for the passed in message.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.HasFullMessage">
            <summary>
            Return true if the full message was recoveredMessage.
            </summary>
            <returns>true on full message recovery, false otherwise, or if not sure.</returns>
            <seealso cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignerWithRecovery.HasFullMessage"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.ItoOSP(System.Int32,System.Byte[])">
            <summary> int to octet string.</summary>
            <summary> int to octet string.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.LtoOSP(System.Int64,System.Byte[])">
            <summary> long to octet string.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.MaskGeneratorFunction1(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary> mask generator function, as described in Pkcs1v2.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer">
            <summary> ISO9796-2 - mechanism using a hash function with recovery (scheme 1)</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.GetRecoveredMessage">
            <summary>
            Return a reference to the recoveredMessage message.
            </summary>
            <returns>The full/partial recoveredMessage message.</returns>
            <seealso cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignerWithRecovery.GetRecoveredMessage"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,System.Boolean)">
            <summary>
            Generate a signer with either implicit or explicit trailers for ISO9796-2.
            </summary>
            <param name="cipher">base cipher to use for signature creation/verification</param>
            <param name="digest">digest to use.</param>
            <param name="isImplicit">whether or not the trailer is implicit or gives the hash.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
             <summary> Constructor for a signer with an explicit digest trailer.
            
             </summary>
             <param name="cipher">cipher to use.
             </param>
             <param name="digest">digest to sign with.
             </param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.IsSameAs(System.Byte[],System.Byte[])">
            <summary> compare two byte arrays - constant time.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.Reset">
            <summary> reset the internal state</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.GenerateSignature">
            <summary> Generate a signature for the loaded message using the key we were
            initialised with.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.VerifySignature(System.Byte[])">
            <summary> return true if the signature represents a ISO9796-2 signature
            for the passed in message.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.HasFullMessage">
            <summary>
            Return true if the full message was recoveredMessage.
            </summary>
            <returns> true on full message recovery, false otherwise.</returns>
            <seealso cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignerWithRecovery.HasFullMessage"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.PssSigner">
            <summary> RSA-PSS as described in Pkcs# 1 v 2.1.
            <p>
            Note: the usual value for the salt length is the number of
            bytes in the hash function.</p>
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.PssSigner.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,System.Int32)">
            <summary>Basic constructor</summary>
            <param name="cipher">the asymmetric cipher to use.</param>
            <param name="digest">the digest to use.</param>
            <param name="saltLen">the length of the salt to use (in bytes).</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.PssSigner.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,System.Byte[])">
            <summary>Basic constructor</summary>
            <param name="cipher">the asymmetric cipher to use.</param>
            <param name="digest">the digest to use.</param>
            <param name="salt">the fixed salt to be used.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.PssSigner.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.PssSigner.ItoOSP(System.Int32,System.Byte[])">
            <summary> int to octet string.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.PssSigner.MaskGeneratorFunction1(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary> mask generator function, as described in Pkcs1v2.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.#cctor">
            <summary>
            Load oid table.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the signer for signing or verification.
            
             @param forSigning true if for signing, false otherwise
             @param param necessary parameters.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.SM2Signer">
            <summary>The SM2 Digital Signature algorithm.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.X931Signer">
            X9.31-1998 - signing using a hash.
            <p>
            The message digest hash, H, is encapsulated to form a byte string as follows
            </p>
            <pre>
            EB = 06 || PS || 0xBA || H || TRAILER
            </pre>
            where PS is a string of bytes all of value 0xBB of length such that |EB|=|n|, and TRAILER is the ISO/IEC 10118 part number for the digest. The byte string, EB, is converted to an integer value, the message representative, f.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.X931Signer.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,System.Boolean)">
             Generate a signer with either implicit or explicit trailers for X9.31.
            
             @param cipher base cipher to use for signature creation/verification
             @param digest digest to use.
             @param implicit whether or not the trailer is implicit or gives the hash.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Signers.X931Signer.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
             Constructor for a signer with an explicit digest trailer.
            
             @param cipher cipher to use.
             @param digest digest to sign with.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.SimpleBlockResult">
            <summary>
            A simple block result object which just carries a byte array.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.SimpleBlockResult.#ctor(System.Byte[])">
            <summary>
            Base constructor - a wrapper for the passed in byte array.
            </summary>
            <param name="result">The byte array to be wrapped.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.SimpleBlockResult.Length">
            <summary>
            Return the number of bytes in the result
            </summary>
            <value>The length of the result in bytes.</value>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.SimpleBlockResult.Collect">
            <summary>
            Return the final result of the operation.
            </summary>
            <returns>A block of bytes, representing the result of an operation.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.SimpleBlockResult.Collect(System.Byte[],System.Int32)">
            <summary>
            Store the final result of the operation by copying it into the destination array.
            </summary>
            <returns>The number of bytes copied into destination.</returns>
            <param name="destination">The byte array to copy the result into.</param>
            <param name="offset">The offset into destination to start copying the result at.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.StreamBlockCipher">
            a wrapper for block ciphers with a single byte block size, so that they
            can be treated like stream ciphers.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.StreamBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Modes.IBlockCipherMode)">
             basic constructor.
            
             @param cipher the block cipher to be wrapped.
             @exception ArgumentException if the cipher has a block size other than
             one.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.StreamBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the underlying cipher.
            
             @param forEncryption true if we are setting up for encryption, false otherwise.
             @param param the necessary parameters for the underlying cipher to be initialised.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.StreamBlockCipher.AlgorithmName">
             return the name of the algorithm we are wrapping.
            
             @return the name of the algorithm we are wrapping.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.StreamBlockCipher.ReturnByte(System.Byte)">
             encrypt/decrypt a single byte returning the result.
            
             @param in the byte to be processed.
             @return the result of processing the input byte.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.StreamBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process a block of bytes from in putting the result into out.
            
             @param in the input byte array.
             @param inOff the offset into the in array where the data to be processed starts.
             @param len the number of bytes to be processed.
             @param out the output buffer the processed bytes go into.
             @param outOff the offset into the output byte array the processed data stars at.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.StreamBlockCipher.Reset">
            reset the underlying cipher. This leaves it in the same state
            it was at after the last init (if there was one).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Utilities.AlgorithmIdentifierFactory.GenerateEncryptionAlgID(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
             Create an AlgorithmIdentifier for the passed in encryption algorithm.
            
             @param encryptionOID OID for the encryption algorithm
             @param keySize key size in bits (-1 if unknown)
             @param random SecureRandom to use for parameter generation.
             @return a full AlgorithmIdentifier including parameters
             @throws IllegalArgumentException if encryptionOID cannot be matched
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Utilities.BasicAlphabetMapper">
            A basic alphabet mapper that just creates a mapper based on the
            passed in array of characters.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Utilities.BasicAlphabetMapper.#ctor(System.String)">
             Base constructor.
            
             @param alphabet a string of characters making up the alphabet.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Utilities.BasicAlphabetMapper.#ctor(System.Char[])">
             Base constructor.
            
             @param alphabet an array of characters making up the alphabet.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Utilities.CipherKeyGeneratorFactory.CreateKeyGenerator(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
             Create a key generator for the passed in Object Identifier.
            
             @param algorithm the Object Identifier indicating the algorithn the generator is for.
             @param random a source of random to initialise the generator with.
             @return an initialised CipherKeyGenerator.
             @throws IllegalArgumentException if the algorithm cannot be identified.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Operators.CmsKeyTransRecipientInfoGenerator">
            <deprecated>Use KeyTransRecipientInfoGenerator</deprecated>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger.AddMagnitudes(System.Int32[],System.Int32[])">
            return a = a + b - b preserved.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger.CompareTo(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            unsigned comparison on two arrays - note the arrays may
            start with leading zeros.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger.Divide(System.Int32[],System.Int32[])">
            return z = x / y - done in place (z value preserved, x contains the
            remainder)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger.IsProbablePrime(System.Int32)">
            return whether or not a BigInteger is probably prime with a
            probability of 1 - (1/2)**certainty.
            <p>From Knuth Vol 2, pg 395.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger.ExtEuclid(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger@)">
             Calculate the numbers u1, u2, and u3 such that:
            
             u1 * a + u2 * b = u3
            
             where u3 is the greatest common divider of a and b.
             a and b using the extended Euclid algorithm (refer p. 323
             of The Art of Computer Programming vol 2, 2nd ed).
             This also seems to have the side effect of calculating
             some form of multiplicative inverse.
            
             @param a    First number to calculate gcd for
             @param b    Second number to calculate gcd for
             @param u1Out      the return object for the u1 value
             @return     The greatest common divisor of a and b
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger.Square(System.Int32[],System.Int32[])">
            return w with w = x * x - w is assumed to have enough space.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger.Multiply(System.Int32[],System.Int32[],System.Int32[])">
            return x with x = y * z - x is assumed to have enough space.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger.GetMQuote">
            Calculate mQuote = -m^(-1) mod b with b = 2^32 (32 = word size)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger.MultiplyMonty(System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.UInt32,System.Boolean)">
            Montgomery multiplication: a = x * y * R^(-1) mod m
            <br/>
            Based algorithm 14.36 of Handbook of Applied Cryptography.
            <br/>
            <li> m, x, y should have length n </li>
            <li> a should have length (n + 1) </li>
            <li> b = 2^32, R = b^n </li>
            <br/>
            The result is put in x
            <br/>
            NOTE: the indices of x, y, m, a different in HAC and in Java
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger.Remainder(System.Int32[],System.Int32[])">
            return x = x % y - done in place (y value preserved)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger.ShiftLeft(System.Int32[],System.Int32)">
            do a left shift - this returns a new array.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger.ShiftRightInPlace(System.Int32,System.Int32[],System.Int32)">
            do a right shift - this does it in place.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger.ShiftRightOneInPlace(System.Int32,System.Int32[])">
            do a right shift by one - this does it in place.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger.Subtract(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            returns x = x - y - we assume x is >= y
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal">
            Class representing a simple version of a big decimal. A
            <code>SimpleBigDecimal</code> is basically a
            {@link java.math.BigInteger BigInteger} with a few digits on the right of
            the decimal point. The number of (binary) digits on the right of the decimal
            point is called the <code>scale</code> of the <code>SimpleBigDecimal</code>.
            Unlike in {@link java.math.BigDecimal BigDecimal}, the scale is not adjusted
            automatically, but must be set manually. All <code>SimpleBigDecimal</code>s
            taking part in the same arithmetic operation must have equal scale. The
            result of a multiplication of two <code>SimpleBigDecimal</code>s returns a
            <code>SimpleBigDecimal</code> with double scale.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.Int32)">
            Returns a <code>SimpleBigDecimal</code> representing the same numerical
            value as <code>value</code>.
            @param value The value of the <code>SimpleBigDecimal</code> to be
            created. 
            @param scale The scale of the <code>SimpleBigDecimal</code> to be
            created. 
            @return The such created <code>SimpleBigDecimal</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.Int32)">
            Constructor for <code>SimpleBigDecimal</code>. The value of the
            constructed <code>SimpleBigDecimal</code> Equals <code>bigInt / 
            2<sup>scale</sup></code>.
            @param bigInt The <code>bigInt</code> value parameter.
            @param scale The scale of the constructed <code>SimpleBigDecimal</code>.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf">
            Class holding methods for point multiplication based on the window
            &#964;-adic nonadjacent form (WTNAF). The algorithms are based on the
            paper "Improved Algorithms for Arithmetic on Anomalous Binary Curves"
            by Jerome A. Solinas. The paper first appeared in the Proceedings of
            Crypto 1997.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.Width">
            The window width of WTNAF. The standard value of 4 is slightly less
            than optimal for running time, but keeps space requirements for
            precomputation low. For typical curves, a value of 5 or 6 results in
            a better running time. When changing this value, the
            <code>&#945;<sub>u</sub></code>'s must be computed differently, see
            e.g. "Guide to Elliptic Curve Cryptography", Darrel Hankerson,
            Alfred Menezes, Scott Vanstone, Springer-Verlag New York Inc., 2004,
            p. 121-122
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.Pow2Width">
            2<sup>4</sup>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha0">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha0Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of TNAFs.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha1">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha1Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of TNAFs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.Norm(System.SByte,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.Norm(System.SByte,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>, where <code>&#955; = u + v&#964;</code>
            and <code>u</code> and <code>u</code> are real numbers (elements of
            <code><b>R</b></code>). 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param u The real part of the element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>.
            @param v The <code>&#964;</code>-adic part of the element
            <code>&#955;</code> of <code><b>R</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.Round(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,System.SByte)">
            Rounds an element <code>&#955;</code> of <code><b>R</b>[&#964;]</code>
            to an element of <code><b>Z</b>[&#964;]</code>, such that their difference
            has minimal norm. <code>&#955;</code> is given as
            <code>&#955; = &#955;<sub>0</sub> + &#955;<sub>1</sub>&#964;</code>.
            @param lambda0 The component <code>&#955;<sub>0</sub></code>.
            @param lambda1 The component <code>&#955;<sub>1</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve. Must
            equal 1 or -1.
            @return The rounded element of <code><b>Z</b>[&#964;]</code>.
            @throws ArgumentException if <code>lambda0</code> and
            <code>lambda1</code> do not have same scale.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.ApproximateDivisionByN(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.SByte,System.Int32,System.Int32)">
            Approximate division by <code>n</code>. For an integer
            <code>k</code>, the value <code>&#955; = s k / n</code> is
            computed to <code>c</code> bits of accuracy.
            @param k The parameter <code>k</code>.
            @param s The curve parameter <code>s<sub>0</sub></code> or
            <code>s<sub>1</sub></code>.
            @param vm The Lucas Sequence element <code>V<sub>m</sub></code>.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param m The bit length of the finite field
            <code><b>F</b><sub>m</sub></code>.
            @param c The number of bits of accuracy, i.e. the scale of the returned
            <code>SimpleBigDecimal</code>.
            @return The value <code>&#955; = s k / n</code> computed to
            <code>c</code> bits of accuracy.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.TauAdicNaf(System.SByte,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Computes the <code>&#964;</code>-adic NAF (non-adjacent form) of an
            element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The <code>&#964;</code>-adic NAF of <code>&#955;</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.Tau(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.AbstractF2mPoint)">
            Applies the operation <code>&#964;()</code> to an
            <code>AbstractF2mPoint</code>. 
            @param p The AbstractF2mPoint to which <code>&#964;()</code> is applied.
            @return <code>&#964;(p)</code>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.GetMu(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.AbstractF2mCurve)">
            Returns the parameter <code>&#956;</code> of the elliptic curve.
            @param curve The elliptic curve from which to obtain <code>&#956;</code>.
            The curve must be a Koblitz curve, i.e. <code>a</code> Equals
            <code>0</code> or <code>1</code> and <code>b</code> Equals
            <code>1</code>. 
            @return <code>&#956;</code> of the elliptic curve.
            @throws ArgumentException if the given ECCurve is not a Koblitz
            curve.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.GetLucas(System.SByte,System.Int32,System.Boolean)">
            Calculates the Lucas Sequence elements <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param k The index of the second element of the Lucas Sequence to be
            returned.
            @param doV If set to true, computes <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>, otherwise <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code>.
            @return An array with 2 elements, containing <code>U<sub>k-1</sub></code>
            and <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code>
            and <code>V<sub>k</sub></code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.GetTw(System.SByte,System.Int32)">
            Computes the auxiliary value <code>t<sub>w</sub></code>. If the width is
            4, then for <code>mu = 1</code>, <code>t<sub>w</sub> = 6</code> and for
            <code>mu = -1</code>, <code>t<sub>w</sub> = 10</code> 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param w The window width of the WTNAF.
            @return the auxiliary value <code>t<sub>w</sub></code>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.GetSi(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.AbstractF2mCurve)">
            Computes the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction. 
            @param curve The elliptic curve for which to compute
            <code>s<sub>0</sub></code> and <code>s<sub>1</sub></code>.
            @throws ArgumentException if <code>curve</code> is not a
            Koblitz curve (Anomalous Binary Curve, ABC).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.PartModReduction(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.Int32,System.SByte,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger[],System.SByte,System.SByte)">
            Partial modular reduction modulo
            <code>(&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>.
            @param k The integer to be reduced.
            @param m The bitlength of the underlying finite field.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param s The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param c The precision (number of bits of accuracy) of the partial
            modular reduction.
            @return <code>&#961; := k partmod (&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyRTnaf(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.AbstractF2mPoint,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by a <code>BigInteger</code> using the reduced <code>&#964;</code>-adic
            NAF (RTNAF) method.
            @param p The AbstractF2mPoint to Multiply.
            @param k The <code>BigInteger</code> by which to Multiply <code>p</code>.
            @return <code>k * p</code>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyTnaf(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.AbstractF2mPoint,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The AbstractF2mPoint to Multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return <code>&#955; * p</code>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyFromTnaf(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte[])">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method, given the TNAF
            of <code>&#955;</code>.
            @param p The AbstractF2mPoint to Multiply.
            @param u The the TNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.TauAdicWNaf(System.SByte,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.ZTauElement,System.SByte,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.ZTauElement[])">
            Computes the <code>[&#964;]</code>-adic window NAF of an element
            <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @param width The window width of the resulting WNAF.
            @param pow2w 2<sup>width</sup>.
            @param tw The auxiliary value <code>t<sub>w</sub></code>.
            @param alpha The <code>&#945;<sub>u</sub></code>'s for the window width.
            @return The <code>[&#964;]</code>-adic window NAF of
            <code>&#955;</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.Tnaf.GetPreComp(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte)">
            Does the precomputation for WTNAF multiplication.
            @param p The <code>ECPoint</code> for which to do the precomputation.
            @param a The parameter <code>a</code> of the elliptic curve.
            @return The precomputation array for <code>p</code>. 
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.ZTauElement">
            Class representing an element of <code><b>Z</b>[&#964;]</code>. Let
            <code>&#955;</code> be an element of <code><b>Z</b>[&#964;]</code>. Then
            <code>&#955;</code> is given as <code>&#955; = u + v&#964;</code>. The
            components <code>u</code> and <code>v</code> may be used directly, there
            are no accessor methods.
            Immutable class.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.ZTauElement.u">
            The &quot;real&quot; part of <code>&#955;</code>.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.ZTauElement.v">
            The &quot;<code>&#964;</code>-adic&quot; part of <code>&#955;</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.ZTauElement.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Constructor for an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param u The &quot;real&quot; part of <code>&#955;</code>.
            @param v The &quot;<code>&#964;</code>-adic&quot; part of
            <code>&#955;</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Custom.GM.SM2P256V1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECAlgorithms.ReferenceMultiply(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECPoint,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Simple shift-and-add multiplication. Serves as reference implementation to verify (possibly
            faster) implementations, and for very small scalars. CAUTION: This implementation is NOT
            constant-time in any way. It is only intended to be used for diagnostics.
            
            @param p
                       The point to multiply.
            @param k
                       The multiplier.
            @return The result of the point multiplication <code>kP</code>.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve">
            <remarks>Base class for an elliptic curve.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve.Precompute(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECPoint,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.IPreCompCallback)">
            Compute a <code>PreCompInfo</code> for a point on this curve, under a given name. Used by
            <code>ECMultiplier</code>s to save the precomputation for this <code>ECPoint</code> for use
            by subsequent multiplication.
            
            @param point
                       The <code>ECPoint</code> to store precomputations for.
            @param name
                       A <code>String</code> used to index precomputations of different types.
            @param callback
                       Called to calculate the <code>PreCompInfo</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve.NormalizeAll(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECPoint[])">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system. Where more
            than one point is to be normalized, this method will generally be more efficient than
            normalizing each point separately.
            
            @param points
                       An array of points that will be updated in place with their normalized versions,
                       where necessary
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve.NormalizeAll(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECPoint[],System.Int32,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECFieldElement)">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system. Where more
            than one point is to be normalized, this method will generally be more efficient than
            normalizing each point separately. An (optional) z-scaling factor can be applied; effectively
            each z coordinate is scaled by this value prior to normalization (but only one
            actual multiplication is needed).
            
            @param points
                       An array of points that will be updated in place with their normalized versions,
                       where necessary
            @param off
                       The start of the range of points to normalize
            @param len
                       The length of the range of points to normalize
            @param iso
                       The (optional) z-scaling factor - can be null
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve.CreateCacheSafeLookupTable(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECPoint[],System.Int32,System.Int32)">
            Create a cache-safe lookup table for the specified sequence of points. All the points MUST
            belong to this <code>ECCurve</code> instance, and MUST already be normalized.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve.GetMultiplier">
             Sets the default <code>ECMultiplier</code>, unless already set.
            
             We avoid locking for performance reasons, so there is no uniqueness guarantee.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECCurve.DecodePoint(System.Byte[])">
            Decode a point on this curve from its ASN.1 encoding. The different
            encodings are taken account of, including point compression for
            <code>F<sub>p</sub></code> (X9.62 s 4.2.1 pg 17).
            @return The decoded point.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.FpCurve">
            Elliptic curve over Fp
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.AbstractF2mCurve.si">
            The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction for
            Koblitz curves.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.AbstractF2mCurve.SolveQuadraticEquation(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECFieldElement)">
             Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
             D.1.6) The other solution is <code>z + 1</code>.
            
             @param beta
                        The value to solve the quadratic equation for.
             @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                     <code>null</code> if no solution exists.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.AbstractF2mCurve.GetSi">
            @return the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction for
            Koblitz curves.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.AbstractF2mCurve.IsKoblitz">
            Returns true if this is a Koblitz curve (ABC curve).
            @return true if this is a Koblitz curve (ABC curve), false otherwise
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mCurve">
            Elliptic curves over F2m. The Weierstrass equation is given by
            <code>y<sup>2</sup> + xy = x<sup>3</sup> + ax<sup>2</sup> + b</code>.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mCurve.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mCurve.k1">
            TPB: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            PPB: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mCurve.k2">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mCurve.k3">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mCurve.m_infinity">
            The point at infinity on this curve.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param order The order of the main subgroup of the elliptic curve.
            @param cofactor The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param order The order of the main subgroup of the elliptic curve.
            @param cofactor The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mCurve.IsTrinomial">
             Return true if curve uses a Trinomial basis.
            
             @return true if curve Trinomial, false otherwise.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.FpFieldElement.FieldName">
             return the field name for this field.
            
             @return the string "Fp".
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.FpFieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation
            returns the right value - if none exists it returns null.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mFieldElement">
            Class representing the Elements of the finite field
            <code>F<sub>2<sup>m</sup></sub></code> in polynomial basis (PB)
            representation. Both trinomial (Tpb) and pentanomial (Ppb) polynomial
            basis representations are supported. Gaussian normal basis (GNB)
            representation is not supported.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mFieldElement.Gnb">
            Indicates gaussian normal basis representation (GNB). Number chosen
            according to X9.62. GNB is not implemented at present.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mFieldElement.Tpb">
            Indicates trinomial basis representation (Tpb). Number chosen
            according to X9.62.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mFieldElement.Ppb">
            Indicates pentanomial basis representation (Ppb). Number chosen
            according to X9.62.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mFieldElement.representation">
            Tpb or Ppb.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mFieldElement.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mFieldElement.x">
            The <code>LongArray</code> holding the bits.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mFieldElement.CheckFieldElements(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECFieldElement,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECFieldElement)">
            Checks, if the ECFieldElements <code>a</code> and <code>b</code>
            are elements of the same field <code>F<sub>2<sup>m</sup></sub></code>
            (having the same representation).
            @param a field element.
            @param b field element to be compared.
            @throws ArgumentException if <code>a</code> and <code>b</code>
            are not elements of the same field
            <code>F<sub>2<sup>m</sup></sub></code> (having the same
            representation).
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mFieldElement.Representation">
            @return the representation of the field
            <code>F<sub>2<sup>m</sup></sub></code>, either of
            {@link F2mFieldElement.Tpb} (trinomial
            basis representation) or
            {@link F2mFieldElement.Ppb} (pentanomial
            basis representation).
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mFieldElement.M">
            @return the degree <code>m</code> of the reduction polynomial
            <code>f(z)</code>.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mFieldElement.K1">
            @return Tpb: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            Ppb: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mFieldElement.K2">
            @return Tpb: Always returns <code>0</code><br/>
            Ppb: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mFieldElement.K3">
            @return Tpb: Always set to <code>0</code><br/>
            Ppb: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECPoint">
            base class for points on elliptic curves.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECPoint.AffineXCoord">
            Returns the affine x-coordinate after checking that this point is normalized.
            
            @return The affine x-coordinate of this point
            @throws IllegalStateException if the point is not normalized
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECPoint.AffineYCoord">
            Returns the affine y-coordinate after checking that this point is normalized
            
            @return The affine y-coordinate of this point
            @throws IllegalStateException if the point is not normalized
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECPoint.XCoord">
            Returns the x-coordinate.
            
            Caution: depending on the curve's coordinate system, this may not be the same value as in an
            affine coordinate system; use Normalize() to get a point where the coordinates have their
            affine values, or use AffineXCoord if you expect the point to already have been normalized.
            
            @return the x-coordinate of this point
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECPoint.YCoord">
            Returns the y-coordinate.
            
            Caution: depending on the curve's coordinate system, this may not be the same value as in an
            affine coordinate system; use Normalize() to get a point where the coordinates have their
            affine values, or use AffineYCoord if you expect the point to already have been normalized.
            
            @return the y-coordinate of this point
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECPoint.Normalize">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system.
            
            @return a new ECPoint instance representing the same point, but with normalized coordinates
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECPointBase.GetEncoded(System.Boolean)">
            return the field element encoded with point compression. (S 4.3.6)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECPointBase.Multiply(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Multiplies this <code>ECPoint</code> by the given number.
            @param k The multiplicator.
            @return <code>k * this</code>.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.FpPoint">
            Elliptic curve points over Fp
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.F2mPoint">
            Elliptic curve points over F2m
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.ECMultiplier">
            Interface for classes encapsulating a point multiplication algorithm
            for <code>ECPoint</code>s.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.ECMultiplier.Multiply(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECPoint,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Multiplies the <code>ECPoint p</code> by <code>k</code>, i.e.
            <code>p</code> is added <code>k</code> times to itself.
            @param p The <code>ECPoint</code> to be multiplied.
            @param k The factor by which <code>p</code> is multiplied.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo">
            Class holding precomputation data for fixed-point multiplications.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo.m_lookupTable">
            Lookup table for the precomputed <code>ECPoint</code>s used for a fixed point multiplication.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo.m_width">
            The width used for the precomputation. If a larger width precomputation
            is already available this may be larger than was requested, so calling
            code should refer to the actual width.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo">
            Interface for classes storing precomputation data for multiplication
            algorithms. Used as a Memento (see GOF patterns) for
            <code>WNafMultiplier</code>.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier">
            Class implementing the WNAF (Window Non-Adjacent Form) multiplication
            algorithm.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier.MultiplyPositive(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECPoint,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Multiplies <code>this</code> by an integer <code>k</code> using the
            Window NAF method.
            @param k The integer by which <code>this</code> is multiplied.
            @return A new <code>ECPoint</code> which equals <code>this</code>
            multiplied by <code>k</code>.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo">
            Class holding precomputation data for the WNAF (Window Non-Adjacent Form)
            algorithm.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_preComp">
            Array holding the precomputed <code>ECPoint</code>s used for a Window
            NAF multiplication.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_preCompNeg">
            Array holding the negations of the precomputed <code>ECPoint</code>s used
            for a Window NAF multiplication.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_twice">
            Holds an <code>ECPoint</code> representing Twice(this). Used for the
            Window NAF multiplication to create or extend the precomputed values.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GenerateWindowNaf(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Computes the Window NAF (non-adjacent Form) of an integer.
            @param width The width <code>w</code> of the Window NAF. The width is
            defined as the minimal number <code>w</code>, such that for any
            <code>w</code> consecutive digits in the resulting representation, at
            most one is non-zero.
            @param k The integer of which the Window NAF is computed.
            @return The Window NAF of the given width, such that the following holds:
            <code>k = &amp;sum;<sub>i=0</sub><sup>l-1</sup> k<sub>i</sub>2<sup>i</sup>
            </code>, where the <code>k<sub>i</sub></code> denote the elements of the
            returned <code>byte[]</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @return the window size to use
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32,System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @param maxWidth the maximum window width to return 
            @return the window size to use
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32,System.Int32[])">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @param windowSizeCutoffs a monotonically increasing list of bit sizes at which to increment the window width
            @return the window size to use
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32,System.Int32[],System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @param windowSizeCutoffs a monotonically increasing list of bit sizes at which to increment the window width
            @param maxWidth the maximum window width to return 
            @return the window size to use
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier">
            Class implementing the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyPositive(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.ECPoint,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by <code>k</code> using the reduced <code>&#964;</code>-adic NAF (RTNAF)
            method.
            @param p The AbstractF2mPoint to multiply.
            @param k The integer by which to multiply <code>k</code>.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyWTnaf(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.AbstractF2mPoint,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Abc.ZTauElement,System.SByte,System.SByte)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code> using
            the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The AbstractF2mPoint to multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @return <code>p</code> multiplied by <code>&#955;</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyFromWTnaf(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte[])">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the window <code>&#964;</code>-adic NAF (TNAF) method, given the
            WTNAF of <code>&#955;</code>.
            @param p The AbstractF2mPoint to multiply.
            @param u The the WTNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo">
            Class holding precomputation data for the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo.m_preComp">
            Array holding the precomputed <code>AbstractF2mPoint</code>s used for the
            WTNAF multiplication in <code>
            {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
            WTauNafMultiplier.multiply()}</code>.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Rfc8032.Ed25519">
            <summary>
            A low-level implementation of the Ed25519, Ed25519ctx, and Ed25519ph instantiations of the Edwards-Curve Digital
            Signature Algorithm specified in <a href="https://www.rfc-editor.org/rfc/rfc8032">RFC 8032</a>.
            </summary>
            <remarks>
            The implementation strategy is mostly drawn from <a href="https://ia.cr/2012/309">
            Mike Hamburg, "Fast and compact elliptic-curve cryptography"</a>, notably the "signed multi-comb" algorithm (for
            scalar multiplication by a fixed point), the "half Niels coordinates" (for precomputed points), and the
            "extensible coordinates" (for accumulators). Standard
            <a href="https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html">extended coordinates</a> are used during
            precomputations, needing only a single extra point addition formula.
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.EC.Rfc8032.Ed448">
            <summary>
            A low-level implementation of the Ed448 and Ed448ph instantiations of the Edwards-Curve Digital Signature
            Algorithm specified in <a href="https://www.rfc-editor.org/rfc/rfc8032">RFC 8032</a>.
            </summary>
            <remarks>
            The implementation uses the "signed mult-comb" algorithm (for scalar multiplication by a fixed point) from
            <a href="https://ia.cr/2012/309">Mike Hamburg, "Fast and compact elliptic-curve cryptography"</a>. Standard
            <a href="https://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html">projective coordinates</a> are used
            for most point arithmetic.
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.Primes">
            <summary>Utility methods for generating primes and testing for primality.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.Primes.MROutput">
            <summary>Used to return the output from the
            <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.Primes.EnhancedMRProbablePrimeTest(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom,System.Int32)">
            Enhanced Miller-Rabin Probabilistic Primality Test</see></summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.Primes.STOutput">
            <summary>Used to return the output from the <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.Primes.GenerateSTRandomPrime(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,System.Int32,System.Byte[])">
            Shawe-Taylor Random_Prime Routine</see></summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.Primes.GenerateSTRandomPrime(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest,System.Int32,System.Byte[])">
            <summary>FIPS 186-4 C.6 Shawe-Taylor Random_Prime Routine.</summary>
            <remarks>Construct a provable prime number using a hash function.</remarks>
            <param name="hash">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest"/> instance to use (as "Hash()"). Cannot be null.</param>
            <param name="length">The length (in bits) of the prime to be generated. Must be at least 2.</param>
            <param name="inputSeed">The seed to be used for the generation of the requested prime. Cannot be null or
            empty.</param>
            <returns>An <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.Primes.STOutput"/> instance containing the requested prime.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.Primes.EnhancedMRProbablePrimeTest(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom,System.Int32)">
            <summary>FIPS 186-4 C.3.2 Enhanced Miller-Rabin Probabilistic Primality Test.</summary>
            <remarks>
            Run several iterations of the Miller-Rabin algorithm with randomly-chosen bases. This is an alternative to
            <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.Primes.IsMRProbablePrime(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom,System.Int32)"/> that provides more information about a
            composite candidate, which may be useful when generating or validating RSA moduli.
            </remarks>
            <param name="candidate">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger"/> instance to test for primality.</param>
            <param name="random">The source of randomness to use to choose bases.</param>
            <param name="iterations">The number of randomly-chosen bases to perform the test for.</param>
            <returns>An <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.Primes.MROutput"/> instance that can be further queried for details.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.Primes.HasAnySmallFactors(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>A fast check for small divisors, up to some implementation-specific limit.</summary>
            <param name="candidate">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger"/> instance to test for division by small factors.</param>
            <returns><c>true</c> if the candidate is found to have any small factors, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.Primes.IsMRProbablePrime(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom,System.Int32)">
            <summary>FIPS 186-4 C.3.1 Miller-Rabin Probabilistic Primality Test.</summary>
            <remarks>Run several iterations of the Miller-Rabin algorithm with randomly-chosen bases.</remarks>
            <param name="candidate">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger"/> instance to test for primality.</param>
            <param name="random">The source of randomness to use to choose bases.</param>
            <param name="iterations">The number of randomly-chosen bases to perform the test for.</param>
            <returns>
            <c>false</c> if any witness to compositeness is found amongst the chosen bases (so
            <paramref name="candidate"/> is definitely NOT prime), or else <c>true</c> (indicating primality with some
            probability dependent on the number of iterations that were performed).
            </returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.Primes.IsMRProbablePrimeToBase(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>FIPS 186-4 C.3.1 Miller-Rabin Probabilistic Primality Test (to a fixed base).</summary>
            <remarks>Run a single iteration of the Miller-Rabin algorithm against the specified base.</remarks>
            <param name="candidate">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger"/> instance to test for primality.</param>
            <param name="baseValue">The base value to use for this iteration.</param>
            <returns><c>false</c> if <paramref name="baseValue"/> is a witness to compositeness (so
            <paramref name="candidate"/> is definitely NOT prime), or else <c>true</c>.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.BasicOcspResp">
            <remarks>
            <code>
            BasicOcspResponse ::= SEQUENCE {
            	tbsResponseData		ResponseData,
            	signatureAlgorithm	AlgorithmIdentifier,
            	signature			BIT STRING,
            	certs				[0] EXPLICIT SEQUENCE OF Certificate OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.BasicOcspResp.GetTbsResponseData">
            <returns>The DER encoding of the tbsResponseData field.</returns>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OcspException">In the event of an encoding error.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.BasicOcspResp.GetCertificates">
            <returns>The certificates, if any, associated with the response.</returns>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OcspException">In the event of an encoding error.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.BasicOcspResp.Verify(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Verify the signature against the tbsResponseData object we contain.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.BasicOcspResp.GetEncoded">
            <returns>The ASN.1 encoded representation of this object.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.BasicOcspRespGenerator">
            Generator for basic OCSP response objects.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.RespID)">
            basic constructor
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            construct with the responderID to be the SHA-1 keyHash of the passed in public key.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.AddResponse(Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.CertificateID,Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.CertificateStatus)">
             Add a response for a particular Certificate ID.
            
             @param certID certificate ID details
             @param certStatus status of the certificate - null if okay
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.AddResponse(Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.CertificateID,Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.CertificateStatus,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a response for a particular Certificate ID.
            
             @param certID certificate ID details
             @param certStatus status of the certificate - null if okay
             @param singleExtensions optional extensions
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.AddResponse(Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.CertificateID,Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.CertificateStatus,System.Nullable{System.DateTime},Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a response for a particular Certificate ID.
            
             @param certID certificate ID details
             @param nextUpdate date when next update should be requested
             @param certStatus status of the certificate - null if okay
             @param singleExtensions optional extensions
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.AddResponse(Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.CertificateID,Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.CertificateStatus,System.DateTime,System.Nullable{System.DateTime},Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a response for a particular Certificate ID.
            
             @param certID certificate ID details
             @param thisUpdate date this response was valid on
             @param nextUpdate date when next update should be requested
             @param certStatus status of the certificate - null if okay
             @param singleExtensions optional extensions
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.SetResponseExtensions(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Set the extensions for the response.
            
             @param responseExtensions the extension object to carry.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.Generate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate[],System.DateTime)">
            <summary>
            Generate the signed response using the passed in signature calculator.
            </summary>
            <param name="signatureCalculatorFactory">Implementation of signing calculator factory.</param>
            <param name="chain">The certificate chain associated with the response signer.</param>
            <param name="producedAt">"produced at" date.</param>
            <returns></returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.SignatureAlgNames">
             Return an IEnumerable of the signature names supported by the generator.
            
             @return an IEnumerable containing recognised names.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.CertificateID.#ctor(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            create from an issuer certificate and the serial number of the
            certificate it signed.
            @exception OcspException if any problems occur creating the id fields.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.CertificateID.SerialNumber">
            return the serial number for the certificate associated
            with this request.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.CertificateID.DeriveCertificateID(Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.CertificateID,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
             Create a new CertificateID for a new serial number derived from a previous one
             calculated for the same CA certificate.
            
             @param original the previously calculated CertificateID for the CA.
             @param newSerialNumber the serial number for the new certificate of interest.
            
             @return a new CertificateID for newSerialNumber
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OcspReq">
             <pre>
             OcspRequest     ::=     SEQUENCE {
                   tbsRequest                  TBSRequest,
                   optionalSignature   [0]     EXPLICIT Signature OPTIONAL }
            
               TBSRequest      ::=     SEQUENCE {
                   version             [0]     EXPLICIT Version DEFAULT v1,
                   requestorName       [1]     EXPLICIT GeneralName OPTIONAL,
                   requestList                 SEQUENCE OF Request,
                   requestExtensions   [2]     EXPLICIT Extensions OPTIONAL }
            
               Signature       ::=     SEQUENCE {
                   signatureAlgorithm      AlgorithmIdentifier,
                   signature               BIT STRING,
                   certs               [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL}
            
               Version         ::=             INTEGER  {  v1(0) }
            
               Request         ::=     SEQUENCE {
                   reqCert                     CertID,
                   singleRequestExtensions     [0] EXPLICIT Extensions OPTIONAL }
            
               CertID          ::=     SEQUENCE {
                   hashAlgorithm       AlgorithmIdentifier,
                   issuerNameHash      OCTET STRING, -- Hash of Issuer's DN
                   issuerKeyHash       OCTET STRING, -- Hash of Issuers public key
                   serialNumber        CertificateSerialNumber }
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OcspReq.GetTbsRequest">
            Return the DER encoding of the tbsRequest field.
            @return DER encoding of tbsRequest
            @throws OcspException in the event of an encoding error.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OcspReq.SignatureAlgOid">
            return the object identifier representing the signature algorithm
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OcspReq.GetCertificates">
             If the request is signed return a possibly empty CertStore containing the certificates in the
             request. If the request is not signed the method returns null.
            
             @return null if not signed, a CertStore otherwise
             @throws OcspException
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OcspReq.IsSigned">
             Return whether or not this request is signed.
            
             @return true if signed false otherwise.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OcspReq.Verify(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            Verify the signature against the TBSRequest object we contain.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OcspReq.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OcspReqGenerator.AddRequest(Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.CertificateID)">
             Add a request for the given CertificateID.
            
             @param certId certificate ID of interest
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OcspReqGenerator.AddRequest(Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.CertificateID,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a request with extensions
            
             @param certId certificate ID of interest
             @param singleRequestExtensions the extensions to attach to the request
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OcspReqGenerator.SetRequestorName(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name)">
             Set the requestor name to the passed in X509Principal
            
             @param requestorName a X509Principal representing the requestor name.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OcspReqGenerator.Generate">
             Generate an unsigned request
            
             @return the OcspReq
             @throws OcspException
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OcspReqGenerator.SignatureAlgNames">
             Return an IEnumerable of the signature names supported by the generator.
            
             @return an IEnumerable containing recognised names.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OcspResp.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OCSPRespGenerator">
            base generator for an OCSP response - at the moment this only supports the
            generation of responses containing BasicOCSP responses.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.OcspRespStatus.Successful">
            note 4 is not used.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.RespID">
            Carrier for a ResponderID.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.RevokedStatus">
            <summary>Wrapper for the RevokedInfo object</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.RevokedStatus.RevocationReason">
            <summary>Return the revocation reason, if there is one.</summary>
            <remarks>This field is optional; test for it with <see cref="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.RevokedStatus.HasRevocationReason"/> first.</remarks>
            <returns>The revocation reason, if available.</returns>
            <exception cref="T:System.InvalidOperationException">If no revocation reason is available.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.SingleResp.GetCertStatus">
             Return the status object for the response - null indicates good.
            
             @return the status object for the response, null if it is good.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.SingleResp.NextUpdate">
             return the NextUpdate value - note: this is an optional field so may
             be returned as null.
            
             @return nextUpdate, or null if not present.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Ocsp.UnknownStatus">
            wrapper for the UnknownInfo object
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.AgreementUtilities">
            <remarks>
             Utility class for creating IBasicAgreement objects from their names/Oids
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.CipherUtilities">
            <remarks>
             Cipher Utility class contains methods that can not be specifically grouped into other classes.
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.DigestUtilities">
            <remarks>
             Utility class for creating IDigest objects from their names/Oids
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.DigestUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns a ObjectIdentifier for a given digest mechanism.
            </summary>
            <param name="mechanism">A string representation of the digest meanism.</param>
            <returns>A DerObjectIdentifier, null if the Oid is not available.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.DotNetUtilities">
            <summary>
            A class containing methods to interface the BouncyCastle world to the .NET Crypto world.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.DotNetUtilities.ToX509Certificate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509CertificateStructure)">
            <summary>
            Create an System.Security.Cryptography.X509Certificate from an X509Certificate Structure.
            </summary>
            <param name="x509Struct"></param>
            <returns>A System.Security.Cryptography.X509Certificate.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.JksStore.Probe(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.JksStore.GetKey(System.String,System.Char[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.JksStore.SetKeyEntry(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Char[],Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.JksStore.SetKeyEntry(System.String,System.Byte[],Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.JksStore.SetCertificateEntry(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.JksStore.Save(System.IO.Stream,System.Char[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.JksStore.Load(System.IO.Stream,System.Char[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.JksStore.ValidateStream(System.IO.Stream,System.Char[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.JksStore.JksTrustedCertEntry">
            JksTrustedCertEntry is a internal container for the certificate entry.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.MacUtilities">
            <remarks>
             Utility class for creating HMac object from their names/Oids
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.PbeUtilities">
             <summary>
            
             </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.PbeUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns a ObjectIdentifier for a give encoding.
            </summary>
            <param name="mechanism">A string representation of the encoding.</param>
            <returns>A DerObjectIdentifier, null if the Oid is not available.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom.GetInstance(System.String)">
            <summary>
            Create and auto-seed an instance based on the given algorithm.
            </summary>
            <remarks>Equivalent to GetInstance(algorithm, true)</remarks>
            <param name="algorithm">e.g. "SHA256PRNG"</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom.GetInstance(System.String,System.Boolean)">
            <summary>
            Create an instance based on the given algorithm, with optional auto-seeding
            </summary>
            <param name="algorithm">e.g. "SHA256PRNG"</param>
            <param name="autoSeed">If true, the instance will be auto-seeded.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Prng.IRandomGenerator)">
            <summary>Use the specified instance of IRandomGenerator as random source.</summary>
            <remarks>
            This constructor performs no seeding of either the <c>IRandomGenerator</c> or the
            constructed <c>SecureRandom</c>. It is the responsibility of the client to provide
            proper seed material as necessary/appropriate for the given <c>IRandomGenerator</c>
            implementation.
            </remarks>
            <param name="generator">The source to generate all random bytes from.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SignerUtilities">
            <summary>
             Signer Utility class contains methods that can not be specifically grouped into other classes.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SignerUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns an ObjectIdentifier for a given encoding.
            </summary>
            <param name="mechanism">A string representation of the encoding.</param>
            <returns>A DerObjectIdentifier, null if the OID is not available.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.WrapperUtilities">
            <remarks>
             Utility class for creating IWrapper objects from their names/Oids
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.OpenSsl.MiscPemGenerator">
            PEM generator for the original set of PEM objects used in Open SSL.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.OpenSsl.PemReader">
            Class for reading OpenSSL PEM encoded streams containing 
            X509 certificates, PKCS8 encoded keys and PKCS7 objects.
            <p>
            In the case of PKCS7 objects the reader will return a CMS ContentInfo object. Keys and
            Certificates will be returned using the appropriate java.security type.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.OpenSsl.PemReader.#ctor(System.IO.TextReader)">
             Create a new PemReader
            
             @param reader the Reader
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.OpenSsl.PemReader.#ctor(System.IO.TextReader,Best.HTTP.SecureProtocol.Org.BouncyCastle.OpenSsl.IPasswordFinder)">
             Create a new PemReader with a password finder
            
             @param reader the Reader
             @param pFinder the password finder
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.OpenSsl.PemReader.ReadCertificate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a X509Certificate.
            
             @return the X509Certificate
             @throws IOException if an I/O error occured
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.OpenSsl.PemReader.ReadCrl(Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a X509CRL.
            
             @return the X509Certificate
             @throws IOException if an I/O error occured
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.OpenSsl.PemReader.ReadCertificateRequest(Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a PKCS10 certification request.
            
             @return the certificate request.
             @throws IOException if an I/O error occured
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.OpenSsl.PemReader.ReadAttributeCertificate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a X509 Attribute Certificate.
            
             @return the X509 Attribute Certificate
             @throws IOException if an I/O error occured
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.OpenSsl.PemReader.ReadPkcs7(Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a PKCS7 object. This returns a ContentInfo object suitable for use with the CMS
             API.
            
             @return the X509Certificate
             @throws IOException if an I/O error occured
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.OpenSsl.PemReader.ReadPrivateKey(Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
            Read a Key Pair
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.OpenSsl.PemWriter">
            <remarks>General purpose writer for OpenSSL PEM objects.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.OpenSsl.PemWriter.#ctor(System.IO.TextWriter)">
            <param name="writer">The TextWriter object to write the output to.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.OpenSsl.Pkcs8Generator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
             Constructor for an unencrypted private key PEM object.
            
             @param key private key to be encoded.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.OpenSsl.Pkcs8Generator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.String)">
             Constructor for an encrypted private key PEM object.
            
             @param key       private key to be encoded
             @param algorithm encryption algorithm to use
             @param provider  provider to use
             @throws NoSuchAlgorithmException if algorithm/mode cannot be found
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest">
             <remarks>
             A class for verifying and creating Pkcs10 Certification requests.
             </remarks>
             <code>
             CertificationRequest ::= Sequence {
               certificationRequestInfo  CertificationRequestInfo,
               signatureAlgorithm        AlgorithmIdentifier{{ SignatureAlgorithms }},
               signature                 BIT STRING
             }
            
             CertificationRequestInfo ::= Sequence {
               version             Integer { v1(0) } (v1,...),
               subject             Name,
               subjectPKInfo   SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
               attributes          [0] Attributes{{ CRIAttributes }}
              }
            
              Attributes { ATTRIBUTE:IOSet } ::= Set OF Attr{{ IOSet }}
            
              Attr { ATTRIBUTE:IOSet } ::= Sequence {
                type    ATTRIBUTE.&amp;id({IOSet}),
                values  Set SIZE(1..MAX) OF ATTRIBUTE.&amp;Type({IOSet}{\@type})
              }
             </code>
             see <a href="http://www.rsasecurity.com/rsalabs/node.asp?id=2132"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.#ctor(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Set,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
             <summary>
             Instantiate a Pkcs10CertificationRequest object with the necessary credentials.
             </summary>
            <param name="signatureAlgorithm">Name of Sig Alg.</param>
             <param name="subject">X509Name of subject eg OU="My unit." O="My Organisatioin" C="au" </param>
             <param name="publicKey">Public Key to be included in cert reqest.</param>
             <param name="attributes">ASN1Set of Attributes.</param>
             <param name="signingKey">Matching Private key for nominated (above) public key to be used to sign the request.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Set)">
             <summary>
             Instantiate a Pkcs10CertificationRequest object with the necessary credentials.
             </summary>
            <param name="signatureFactory">The factory for signature calculators to sign the PKCS#10 request with.</param>
             <param name="subject">X509Name of subject eg OU="My unit." O="My Organisatioin" C="au" </param>
             <param name="publicKey">Public Key to be included in cert reqest.</param>
             <param name="attributes">ASN1Set of Attributes.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.GetPublicKey">
            <summary>
            Get the public key.
            </summary>
            <returns>The public key.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.Verify">
            <summary>
            Verify Pkcs10 Cert Request is valid.
            </summary>
            <returns>true = valid.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.GetRequestedExtensions">
            <summary>
            Returns X509Extensions if the Extensions Request attribute can be found and returns the extensions block.
            </summary>
            <returns>X509Extensions block or null if one cannot be found.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestDelaySigned">
             <remarks>
             A class for creating and verifying Pkcs10 Certification requests (this is an extension on <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest"/>).
             The requests are made using delay signing. This is useful for situations where
             the private key is in another environment and not directly accessible (e.g. HSM)
             So the first step creates the request, then the signing is done outside this
             object and the signature is then used to complete the request.
             </remarks>
             <code>
             CertificationRequest ::= Sequence {
               certificationRequestInfo  CertificationRequestInfo,
               signatureAlgorithm        AlgorithmIdentifier{{ SignatureAlgorithms }},
               signature                 BIT STRING
             }
            
             CertificationRequestInfo ::= Sequence {
               version             Integer { v1(0) } (v1,...),
               subject             Name,
               subjectPKInfo   SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
               attributes          [0] Attributes{{ CRIAttributes }}
              }
            
              Attributes { ATTRIBUTE:IOSet } ::= Set OF Attr{{ IOSet }}
            
              Attr { ATTRIBUTE:IOSet } ::= Sequence {
                type    ATTRIBUTE.&amp;id({IOSet}),
                values  Set SIZE(1..MAX) OF ATTRIBUTE.&amp;Type({IOSet}{\@type})
              }
             </code>
             see <a href="http://www.rsasecurity.com/rsalabs/node.asp?id=2132"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestDelaySigned.#ctor(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Set)">
            <summary>
            Instantiate a Pkcs10CertificationRequest object with the necessary credentials.
            </summary>
            <param name="signatureAlgorithm">Name of Sig Alg.</param>
            <param name="subject">X509Name of subject eg OU="My unit." O="My Organisatioin" C="au" </param>
            <param name="publicKey">Public Key to be included in cert reqest.</param>
            <param name="attributes">ASN1Set of Attributes.</param>
            <remarks>
            After the object is constructed use the <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestDelaySigned.GetDataToSign"/> and finally the
            SignRequest methods to finalize the request.
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs12Store.GetCertificate(System.String)">
            simply return the cert entry for the private key
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs12Utilities">
            Utility class for reencoding PKCS#12 files to definite length.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs12Utilities.ConvertToDefiniteLength(System.Byte[])">
             Just re-encode the outer layer of the PKCS#12 file to definite length encoding.
            
             @param berPKCS12File - original PKCS#12 file
             @return a byte array representing the DER encoding of the PFX structure
             @throws IOException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs12Utilities.ConvertToDefiniteLength(System.Byte[],System.Char[])">
             Re-encode the PKCS#12 structure to definite length encoding at the inner layer
             as well, recomputing the MAC accordingly.
            
             @param berPKCS12File - original PKCS12 file.
             @param provider - provider to use for MAC calculation.
             @return a byte array representing the DER encoding of the PFX structure.
             @throws IOException on parsing, encoding errors.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfo">
            <summary>
            A holding class for a PKCS#8 encrypted private key info object that allows for its decryption.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfo.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Pkcs.EncryptedPrivateKeyInfo)">
            <summary>
            Base constructor from a PKCS#8 EncryptedPrivateKeyInfo object.
            </summary>
            <param name="encryptedPrivateKeyInfo">A PKCS#8 EncryptedPrivateKeyInfo object.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfo.#ctor(System.Byte[])">
            <summary>
            Base constructor from a BER encoding of a PKCS#8 EncryptedPrivateKeyInfo object.
            </summary>
            <param name="encryptedPrivateKeyInfo">A BER encoding of a PKCS#8 EncryptedPrivateKeyInfo objects.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfo.ToAsn1Structure">
            <summary>
            Returns the underlying ASN.1 structure inside this object.
            </summary>
            <returns>Return the EncryptedPrivateKeyInfo structure in this object.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfo.GetEncryptedData">
            <summary>
            Returns a copy of the encrypted data in this structure.
            </summary>
            <returns>Return a copy of the encrypted data in this object.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfo.GetEncoded">
            <summary>
            Return a binary ASN.1 encoding of the EncryptedPrivateKeyInfo structure in this object.
            </summary>
            <returns>A byte array containing the encoded object.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfo.DecryptPrivateKeyInfo(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDecryptorBuilderProvider)">
            <summary>
            Get a decryptor from the passed in provider and decrypt the encrypted private key info, returning the result.
            </summary>
            <param name="inputDecryptorProvider">A provider to query for decryptors for the object.</param>
            <returns>The decrypted private key info structure.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfoBuilder.Build(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherBuilder)">
            <summary>
            Create the encrypted private key info using the passed in encryptor.
            </summary>
            <param name="encryptor">The encryptor to use.</param>
            <returns>An encrypted private key info containing the original private key info.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.PkcsException">
            <summary>Base exception for PKCS related issues.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.PkcsIOException">
            <summary>Base exception for parsing related issues in the PKCS namespace.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkcs.PrivateKeyInfoFactory.CreatePrivateKeyInfo(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Set)">
             Create a PrivateKeyInfo representation of a private key with attributes.
            
             @param privateKey the key to be encoded into the info object.
             @param attributes the set of attributes to be included.
             @return the appropriate PrivateKeyInfo
             @throws java.io.IOException on an error encoding the key
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.CertStatus.RevocationDate">
            <summary>
            Returns the revocationDate.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.CertStatus.Status">
            <summary>
            Returns the certStatus.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixAttrCertChecker.GetSupportedExtensions">
            Returns an immutable <code>Set</code> of X.509 attribute certificate
            extensions that this <code>PkixAttrCertChecker</code> supports or
            <code>null</code> if no extensions are supported.
            <p>
            Each element of the set is a <code>String</code> representing the
            Object Identifier (OID) of the X.509 extension that is supported.
            </p>
            <p>
            All X.509 attribute certificate extensions that a
            <code>PkixAttrCertChecker</code> might possibly be able to process
            should be included in the set.
            </p>
            
            @return an immutable <code>Set</code> of X.509 extension OIDs (in
                    <code>String</code> format) supported by this
                    <code>PkixAttrCertChecker</code>, or <code>null</code> if no
                    extensions are supported
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixAttrCertChecker.Check(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificate,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,System.Collections.Generic.ICollection{System.String})">
            Performs checks on the specified attribute certificate. Every handled
            extension is rmeoved from the <code>unresolvedCritExts</code>
            collection.
            
            @param attrCert The attribute certificate to be checked.
            @param certPath The certificate path which belongs to the attribute
                       certificate issuer public key certificate.
            @param holderCertPath The certificate path which belongs to the holder
                       certificate.
            @param unresolvedCritExts a <code>Collection</code> of OID strings
                       representing the current set of unresolved critical extensions
            @throws CertPathValidatorException if the specified attribute certificate
                        does not pass the check.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixAttrCertChecker.Clone">
            Returns a clone of this object.
            
            @return a copy of this <code>PkixAttrCertChecker</code>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixAttrCertPathBuilder.Build(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixBuilderParameters)">
             Build and validate a CertPath using the given parameter.
            
             @param params PKIXBuilderParameters object containing all information to
                        build the CertPath
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixAttrCertPathValidator">
            CertPathValidatorSpi implementation for X.509 Attribute Certificates la RFC 3281.
            
            @see org.bouncycastle.x509.ExtendedPkixParameters
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixAttrCertPathValidator.Validate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters)">
            Validates an attribute certificate with the given certificate path.
            
            <p>
            <code>params</code> must be an instance of
            <code>ExtendedPkixParameters</code>.
            </p><p>
            The target constraints in the <code>params</code> must be an
            <code>X509AttrCertStoreSelector</code> with at least the attribute
            certificate criterion set. Obey that also target informations may be
            necessary to correctly validate this attribute certificate.
            </p><p>
            The attribute certificate issuer must be added to the trusted attribute
            issuers with {@link ExtendedPkixParameters#setTrustedACIssuers(Set)}.
            </p>
            @param certPath The certificate path which belongs to the attribute
                       certificate issuer public key certificate.
            @param params The PKIX parameters.
            @return A <code>PKIXCertPathValidatorResult</code> of the result of
                    validating the <code>certPath</code>.
            @throws InvalidAlgorithmParameterException if <code>params</code> is
                        inappropriate for this validator.
            @throws CertPathValidatorException if the verification fails.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixBuilderParameters">
            <summary>
            Summary description for PkixBuilderParameters.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixBuilderParameters.GetInstance(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters)">
             Returns an instance of <code>PkixBuilderParameters</code>.
             <p>
             This method can be used to get a copy from other
             <code>PKIXBuilderParameters</code>, <code>PKIXParameters</code>,
             and <code>ExtendedPKIXParameters</code> instances.
             </p>
            
             @param pkixParams The PKIX parameters to create a copy of.
             @return An <code>PkixBuilderParameters</code> instance.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixBuilderParameters.GetExcludedCerts">
            <summary>
            Excluded certificates are not used for building a certification path.
            </summary>
            <returns>the excluded certificates.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixBuilderParameters.SetExcludedCerts(System.Collections.Generic.ISet{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate})">
            <summary>
            Sets the excluded certificates which are not used for building a
            certification path. If the <code>ISet</code> is <code>null</code> an
            empty set is assumed.
            </summary>
            <remarks>
            The given set is cloned to protect it against subsequent modifications.
            </remarks>
            <param name="excludedCerts">The excluded certificates to set.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixBuilderParameters.SetParams(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters)">
            Can alse handle <code>ExtendedPKIXBuilderParameters</code> and
            <code>PKIXBuilderParameters</code>.
            
            @param params Parameters to set.
            @see org.bouncycastle.x509.ExtendedPKIXParameters#setParams(java.security.cert.PKIXParameters)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixBuilderParameters.Clone">
             Makes a copy of this <code>PKIXParameters</code> object. Changes to the
             copy will not affect the original and vice versa.
            
             @return a copy of this <code>PKIXParameters</code> object
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath">
             An immutable sequence of certificates (a certification path).<br />
             <br />
             This is an abstract class that defines the methods common to all CertPaths.
             Subclasses can handle different kinds of certificates (X.509, PGP, etc.).<br />
             <br />
             All CertPath objects have a type, a list of Certificates, and one or more
             supported encodings. Because the CertPath class is immutable, a CertPath
             cannot change in any externally visible way after being constructed. This
             stipulation applies to all public fields and methods of this class and any
             added or overridden by subclasses.<br />
             <br />
             The type is a string that identifies the type of Certificates in the
             certification path. For each certificate cert in a certification path
             certPath, cert.getType().equals(certPath.getType()) must be true.<br />
             <br />
             The list of Certificates is an ordered List of zero or more Certificates.
             This List and all of the Certificates contained in it must be immutable.<br />
             <br />
             Each CertPath object must support one or more encodings so that the object
             can be translated into a byte array for storage or transmission to other
             parties. Preferably, these encodings should be well-documented standards
             (such as PKCS#7). One of the encodings supported by a CertPath is considered
             the default encoding. This encoding is used if no encoding is explicitly
             requested (for the {@link #getEncoded()} method, for instance).<br />
             <br />
             All CertPath objects are also Serializable. CertPath objects are resolved
             into an alternate {@link CertPathRep} object during serialization. This
             allows a CertPath object to be serialized into an equivalent representation
             regardless of its underlying implementation.<br />
             <br />
             CertPath objects can be created with a CertificateFactory or they can be
             returned by other classes, such as a CertPathBuilder.<br />
             <br />
             By convention, X.509 CertPaths (consisting of X509Certificates), are ordered
             starting with the target certificate and ending with a certificate issued by
             the trust anchor. That is, the issuer of one certificate is the subject of
             the following one. The certificate representing the
             {@link TrustAnchor TrustAnchor} should not be included in the certification
             path. Unvalidated X.509 CertPaths may not follow these conventions. PKIX
             CertPathValidators will detect any departure from these conventions that
             cause the certification path to be invalid and throw a
             CertPathValidatorException.<br />
             <br />
             <strong>Concurrent Access</strong><br />
             <br />
             All CertPath objects must be thread-safe. That is, multiple threads may
             concurrently invoke the methods defined in this class on a single CertPath
             object (or more than one) with no ill effects. This is also true for the List
             returned by CertPath.getCertificates.<br />
             <br />
             Requiring CertPath objects to be immutable and thread-safe allows them to be
             passed around to various pieces of code without worrying about coordinating
             access. Providing this thread-safety is generally not difficult, since the
             CertPath and List objects in question are immutable.
            
             @see CertificateFactory
             @see CertPathBuilder
            <summary>
            CertPath implementation for X.509 certificates.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath.#ctor(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate})">
             Creates a CertPath of the specified type.
             This constructor is protected because most users should use
             a CertificateFactory to create CertPaths.
             @param type the standard name of the type of Certificatesin this path
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath.#ctor(System.IO.Stream,System.String)">
             Creates a CertPath of the specified type.
             This constructor is protected because most users should use
             a CertificateFactory to create CertPaths.
            
             @param type the standard name of the type of Certificatesin this path
            
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath.Encodings">
             Returns an iteration of the encodings supported by this
             certification path, with the default encoding
             first. Attempts to modify the returned Iterator via its
             remove method result in an UnsupportedOperationException.
            
             @return an Iterator over the names of the supported encodings (as Strings)
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath.Equals(System.Object)">
             Compares this certification path for equality with the specified object.
             Two CertPaths are equal if and only if their types are equal and their
             certificate Lists (and by implication the Certificates in those Lists)
             are equal. A CertPath is never equal to an object that is not a CertPath.<br />
             <br />
             This algorithm is implemented by this method. If it is overridden, the
             behavior specified here must be maintained.
            
             @param other
                        the object to test for equality with this certification path
            
             @return true if the specified object is equal to this certification path,
                     false otherwise
            
             @see Object#hashCode() Object.hashCode()
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath.GetEncoded">
             Returns the encoded form of this certification path, using
             the default encoding.
            
             @return the encoded bytes
             @exception CertificateEncodingException if an encoding error occurs
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath.GetEncoded(System.String)">
             Returns the encoded form of this certification path, using
             the specified encoding.
            
             @param encoding the name of the encoding to use
             @return the encoded bytes
             @exception CertificateEncodingException if an encoding error
             occurs or the encoding requested is not supported
            
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath.Certificates">
            <summary>
            Returns the list of certificates in this certification
            path.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath.ToAsn1Object(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate)">
             Return a DERObject containing the encoded certificate.
            
             @param cert the X509Certificate object to be encoded
            
             @return the DERObject
            
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathBuilder">
             Implements the PKIX CertPathBuilding algorithm for BouncyCastle.
            
             @see CertPathBuilderSpi
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathBuilder.Build(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixBuilderParameters)">
             Build and validate a CertPath using the given parameter.
            
             @param params PKIXBuilderParameters object containing all information to
                        build the CertPath
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathBuilderResult">
            <summary>
            Summary description for PkixCertPathBuilderResult.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathChecker.Init(System.Boolean)">
                     * Initializes the internal state of this <code>PKIXCertPathChecker</code>.
                     * <p>
                     * The <code>forward</code> flag specifies the order that certificates
                     * will be passed to the {@link #check check} method (forward or reverse). A
                     * <code>PKIXCertPathChecker</code> <b>must</b> support reverse checking
                     * and <b>may</b> support forward checking.
            		 * </p>
                     * 
                     * @param forward
                     *            the order that certificates are presented to the
                     *            <code>check</code> method. If <code>true</code>,
                     *            certificates are presented from target to most-trusted CA
                     *            (forward); if <code>false</code>, from most-trusted CA to
                     *            target (reverse).
                     * @exception CertPathValidatorException
                     *                if this <code>PKIXCertPathChecker</code> is unable to
                     *                check certificates in the specified order; it should never
                     *                be thrown if the forward flag is false since reverse
                     *                checking must be supported
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathChecker.IsForwardCheckingSupported">
            Indicates if forward checking is supported. Forward checking refers to
            the ability of the <code>PKIXCertPathChecker</code> to perform its
            checks when certificates are presented to the <code>check</code> method
            in the forward direction (from target to most-trusted CA).
            
            @return <code>true</code> if forward checking is supported,
                    <code>false</code> otherwise
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathChecker.GetSupportedExtensions">
                     * Returns an immutable <code>Set</code> of X.509 certificate extensions
                     * that this <code>PKIXCertPathChecker</code> supports (i.e. recognizes,
                     * is able to process), or <code>null</code> if no extensions are
                     * supported.
                     * <p>
                     * Each element of the set is a <code>String</code> representing the
                     * Object Identifier (OID) of the X.509 extension that is supported. The OID
                     * is represented by a set of nonnegative integers separated by periods.
                     * </p><p>
                     * All X.509 certificate extensions that a <code>PKIXCertPathChecker</code>
                     * might possibly be able to process should be included in the set.
            		 * </p>
                     * 
                     * @return an immutable <code>Set</code> of X.509 extension OIDs (in
                     *         <code>String</code> format) supported by this
                     *         <code>PKIXCertPathChecker</code>, or <code>null</code> if no
                     *         extensions are supported
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathChecker.Check(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.Collections.Generic.ISet{System.String})">
            Performs the check(s) on the specified certificate using its internal
            state and removes any critical extensions that it processes from the
            specified collection of OID strings that represent the unresolved
            critical extensions. The certificates are presented in the order
            specified by the <code>init</code> method.
            
            @param cert
                       the <code>Certificate</code> to be checked
            @param unresolvedCritExts
                       a <code>Collection</code> of OID strings representing the
                       current set of unresolved critical extensions
            @exception CertPathValidatorException
                           if the specified certificate does not pass the check
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathChecker.Clone">
            Returns a clone of this object. Calls the <code>Object.clone()</code>
            method. All subclasses which maintain state must support and override
            this method, if necessary.
            
            @return a copy of this <code>PKIXCertPathChecker</code>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidator">
            The <i>Service Provider Interface</i> (<b>SPI</b>)
            for the {@link CertPathValidator CertPathValidator} class. All
            <code>CertPathValidator</code> implementations must include a class (the
            SPI class) that extends this class (<code>CertPathValidatorSpi</code>)
            and implements all of its methods. In general, instances of this class
            should only be accessed through the <code>CertPathValidator</code> class.
            For details, see the Java Cryptography Architecture.<br />
            <br />
            <b>Concurrent Access</b><br />
            <br />
            Instances of this class need not be protected against concurrent
            access from multiple threads. Threads that need to access a single
            <code>CertPathValidatorSpi</code> instance concurrently should synchronize
            amongst themselves and provide the necessary locking before calling the
            wrapping <code>CertPathValidator</code> object.<br />
            <br />
            However, implementations of <code>CertPathValidatorSpi</code> may still
            encounter concurrency issues, since multiple threads each
            manipulating a different <code>CertPathValidatorSpi</code> instance need not
            synchronize.
            <summary>
            CertPathValidatorSpi implementation for X.509 Certificate validation a la RFC
            3280.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException">
             An exception indicating one of a variety of problems encountered when 
             validating a certification path. <br />
             <br />
             A <code>CertPathValidatorException</code> provides support for wrapping
             exceptions. The {@link #getCause getCause} method returns the throwable, 
             if any, that caused this exception to be thrown. <br />
             <br />
             A <code>CertPathValidatorException</code> may also include the 
             certification path that was being validated when the exception was thrown 
             and the index of the certificate in the certification path that caused the 
             exception to be thrown. Use the {@link #getCertPath getCertPath} and
             {@link #getIndex getIndex} methods to retrieve this information.<br />
             <br />
             <b>Concurrent Access</b><br />
             <br />
             Unless otherwise specified, the methods defined in this class are not
             thread-safe. Multiple threads that need to access a single
             object concurrently should synchronize amongst themselves and
             provide the necessary locking. Multiple threads each manipulating
             separate objects need not synchronize.
            
             @see CertPathValidator
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException.#ctor(System.String,System.Exception,System.Int32)">
            <summary>
            Creates a <code>PkixCertPathValidatorException</code> with the specified
            detail message, cause, certification path, and index.
            </summary>
            <param name="message">the detail message (or <code>null</code> if none)</param>
            <param name="innerException">the cause (or <code>null</code> if none)</param>
            <param name="index">the index of the certificate in the certification path that</param>																																																																																   * 
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException.Index">
            <summary> eturns the index of the certificate in the certification path that caused the exception to be
            thrown.</summary>
            <remarks>
            Note that the list of certificates in a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath"/> is zero based. If no index has been set,
            -1 is returned.
            </remarks>
            <returns>The index that has been set, or -1 if none has been set.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorResult">
            <summary>
            Summary description for PkixCertPathValidatorResult.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities">
            <summary>
            Summary description for PkixCertPathValidatorUtilities.
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.KEY_CERT_SIGN">
            <summary>
            key usage bits
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.FindTrustAnchor(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.Collections.Generic.ISet{Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.TrustAnchor})">
            <summary>
            Search the given Set of TrustAnchor's for one that is the
            issuer of the given X509 certificate.
            </summary>
            <param name="cert">the X509 certificate</param>
            <param name="trustAnchors">a Set of TrustAnchor's</param>
            <returns>the <code>TrustAnchor</code> object if found or
            <code>null</code> if not.
            </returns>
            @exception
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetIssuerPrincipal(System.Object)">
            <summary>
            Returns the issuer of an attribute certificate or certificate.
            </summary>
            <param name="obj">The attribute certificate or certificate.</param>
            <returns>The issuer as <code>X500Principal</code>.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetNextWorkingKey(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate},System.Int32)">
             Return the next working key inheriting DSA parameters if necessary.
             <p>
             This methods inherits DSA parameters from the indexed certificate or
             previous certificates in the certificate chain to the returned
             <code>PublicKey</code>. The list is searched upwards, meaning the end
             certificate is at position 0 and previous certificates are following.
             </p>
             <p>
             If the indexed certificate does not contain a DSA key this method simply
             returns the public key. If the DSA key already contains DSA parameters
             the key is also only returned.
             </p>
            
             @param certs The certification path.
             @param index The index of the certificate which contains the public key
                        which should be extended with DSA parameters.
             @return The public key of the certificate in list position
                     <code>index</code> extended with DSA parameters if applicable.
             @throws Exception if DSA parameters cannot be inherited.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetCrlIssuersFromDistributionPoint(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DistributionPoint,System.Collections.Generic.ICollection{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name},Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509CrlStoreSelector,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters)">
             Add the CRL issuers from the cRLIssuer field of the distribution point or
             from the certificate if not given to the issuer criterion of the
             <code>selector</code>.
             <p>
             The <code>issuerPrincipals</code> are a collection with a single
             <code>X500Principal</code> for <code>X509Certificate</code>s. For
             {@link X509AttributeCertificate}s the issuer may contain more than one
             <code>X500Principal</code>.
             </p>
            
             @param dp The distribution point.
             @param issuerPrincipals The issuers of the certificate or attribute
                        certificate which contains the distribution point.
             @param selector The CRL selector.
             @param pkixParams The PKIX parameters containing the cert stores.
             @throws Exception if an exception occurs while processing.
             @throws ClassCastException if <code>issuerPrincipals</code> does not
             contain only <code>X500Principal</code>s.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetCompleteCrls(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DistributionPoint,System.Object,System.DateTime,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters)">
             Fetches complete CRLs according to RFC 3280.
            
             @param dp The distribution point for which the complete CRL
             @param cert The <code>X509Certificate</code> or
                        {@link org.bouncycastle.x509.X509AttributeCertificate} for
                        which the CRL should be searched.
             @param currentDate The date for which the delta CRLs must be valid.
             @param paramsPKIX The extended PKIX parameters.
             @return A <code>Set</code> of <code>X509CRL</code>s with complete
                     CRLs.
             @throws Exception if an exception occurs while picking the CRLs
                         or no CRLs are found.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetDeltaCrls(System.DateTime,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl)">
             Fetches delta CRLs according to RFC 3280 section 5.2.4.
            
             @param currentDate The date for which the delta CRLs must be valid.
             @param paramsPKIX The extended PKIX parameters.
             @param completeCRL The complete CRL the delta CRL is for.
             @return A <code>Set</code> of <code>X509CRL</code>s with delta CRLs.
             @throws Exception if an exception occurs while picking the delta
                         CRLs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.FindIssuerCerts(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixBuilderParameters)">
             Find the issuer certificates of a given certificate.
            
             @param cert
                        The certificate for which an issuer should be found.
             @param pkixParams
             @return A <code>Collection</code> object containing the issuer
                     <code>X509Certificate</code>s. Never <code>null</code>.
            
             @exception Exception
                            if an error occurs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCrlUtilities.FindCrls(Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Collections.ISelector{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl},System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Collections.IStore{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl}})">
            <summary>
            crl checking
            Return a Collection of all CRLs found in the X509Store's that are
            matching the crlSelect criteriums.
            </summary>
            <param name="crlSelector">a {@link X509CRLStoreSelector} object that will be used
            to select the CRLs</param>
            <param name="crlStores">a List containing only {@link org.bouncycastle.x509.X509Store
            X509Store} objects. These are used to search for CRLs</param>
            <returns>a Collection of all found {@link X509CRL X509CRL} objects. May be
            empty but never <code>null</code>.
            </returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IntersectIP(System.Collections.Generic.ISet{System.Byte[]},System.Collections.Generic.ISet{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralSubtree})">
             Returns the intersection of the permitted IP ranges in
             <code>permitted</code> with <code>ip</code>.
            
             @param permitted A <code>Set</code> of permitted IP addresses with
                              their subnet mask as byte arrays.
             @param ips       The IP address with its subnet mask.
             @return The <code>Set</code> of permitted IP ranges intersected with
                     <code>ip</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.UnionIP(System.Collections.Generic.ISet{System.Byte[]},System.Byte[])">
             Returns the union of the excluded IP ranges in <code>excluded</code>
             with <code>ip</code>.
            
             @param excluded A <code>Set</code> of excluded IP addresses with their
                             subnet mask as byte arrays.
             @param ip       The IP address with its subnet mask.
             @return The <code>Set</code> of excluded IP ranges unified with
                     <code>ip</code> as byte arrays.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.UnionIPRange(System.Byte[],System.Byte[])">
             Calculates the union if two IP ranges.
            
             @param ipWithSubmask1 The first IP address with its subnet mask.
             @param ipWithSubmask2 The second IP address with its subnet mask.
             @return A <code>Set</code> with the union of both addresses.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IntersectIPRange(System.Byte[],System.Byte[])">
             Calculates the interesction if two IP ranges.
            
             @param ipWithSubmask1 The first IP address with its subnet mask.
             @param ipWithSubmask2 The second IP address with its subnet mask.
             @return A <code>Set</code> with the single IP address with its subnet
                     mask as a byte array or an empty <code>Set</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IpWithSubnetMask(System.Byte[],System.Byte[])">
             Concatenates the IP address with its subnet mask.
            
             @param ip         The IP address.
             @param subnetMask Its subnet mask.
             @return The concatenated IP address with its subnet mask.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.ExtractIPsAndSubnetMasks(System.Byte[],System.Byte[])">
             Splits the IP addresses and their subnet mask.
            
             @param ipWithSubmask1 The first IP address with the subnet mask.
             @param ipWithSubmask2 The second IP address with the subnet mask.
             @return An array with two elements. Each element contains the IP address
                     and the subnet mask in this order.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.MinMaxIPs(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
             Based on the two IP addresses and their subnet masks the IP range is
             computed for each IP address - subnet mask pair and returned as the
             minimum IP address and the maximum address of the range.
            
             @param ip1         The first IP address.
             @param subnetmask1 The subnet mask of the first IP address.
             @param ip2         The second IP address.
             @param subnetmask2 The subnet mask of the second IP address.
             @return A array with two elements. The first/second element contains the
                     min and max IP address of the first/second IP address and its
                     subnet mask.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IsIPConstrained(System.Byte[],System.Byte[])">
             Checks if the IP address <code>ip</code> is constrained by
             <code>constraint</code>.
            
             @param constraint The constraint. This is an IP address concatenated with
                               its subnetmask.
             @param ip         The IP address.
             @return <code>true</code> if constrained, <code>false</code>
                     otherwise.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.CheckPermittedIP(System.Collections.Generic.ISet{System.Byte[]},System.Byte[])">
             Checks if the IP <code>ip</code> is included in the permitted ISet
             <code>permitted</code>.
            
             @param permitted A <code>Set</code> of permitted IP addresses with
                              their subnet mask as byte arrays.
             @param ip        The IP address.
             @throws PkixNameConstraintValidatorException
                      if the IP is not permitted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.CheckExcludedIP(System.Collections.Generic.ISet{System.Byte[]},System.Byte[])">
             Checks if the IP <code>ip</code> is included in the excluded ISet
             <code>excluded</code>.
            
             @param excluded A <code>Set</code> of excluded IP addresses with their
                             subnet mask as byte arrays.
             @param ip       The IP address.
             @throws PkixNameConstraintValidatorException
                      if the IP is excluded.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.UnionEmail(System.String,System.String,System.Collections.Generic.ISet{System.String})">
             The common part of <code>email1</code> and <code>email2</code> is
             added to the union <code>union</code>. If <code>email1</code> and
             <code>email2</code> have nothing in common they are added both.
            
             @param email1 Email address constraint 1.
             @param email2 Email address constraint 2.
             @param union  The union.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IntersectEmail(System.String,System.String,System.Collections.Generic.ISet{System.String})">
             The most restricting part from <code>email1</code> and
             <code>email2</code> is added to the intersection <code>intersect</code>.
            
             @param email1    Email address constraint 1.
             @param email2    Email address constraint 2.
             @param intersect The intersection.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.checkPermitted(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName)">
             Checks if the given GeneralName is in the permitted ISet.
            
             @param name The GeneralName
             @throws PkixNameConstraintValidatorException
                      If the <code>name</code>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.checkExcluded(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName)">
             Check if the given GeneralName is contained in the excluded ISet.
            
             @param name The GeneralName.
             @throws PkixNameConstraintValidatorException
                      If the <code>name</code> is
                      excluded.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IntersectPermittedSubtree(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Sequence)">
             Updates the permitted ISet of these name constraints with the intersection
             with the given subtree.
            
             @param permitted The permitted subtrees
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.AddExcludedSubtree(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralSubtree)">
             Adds a subtree to the excluded ISet of these name constraints.
            
             @param subtree A subtree with an excluded GeneralName.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.Max(System.Byte[],System.Byte[])">
             Returns the maximum IP address.
            
             @param ip1 The first IP address.
             @param ip2 The second IP address.
             @return The maximum IP address.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.Min(System.Byte[],System.Byte[])">
             Returns the minimum IP address.
            
             @param ip1 The first IP address.
             @param ip2 The second IP address.
             @return The minimum IP address.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.CompareTo(System.Byte[],System.Byte[])">
             Compares IP address <code>ip1</code> with <code>ip2</code>. If ip1
             is equal to ip2 0 is returned. If ip1 is bigger 1 is returned, -1
             otherwise.
            
             @param ip1 The first IP address.
             @param ip2 The second IP address.
             @return 0 if ip1 is equal to ip2, 1 if ip1 is bigger, -1 otherwise.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.Or(System.Byte[],System.Byte[])">
             Returns the logical OR of the IP addresses <code>ip1</code> and
             <code>ip2</code>.
            
             @param ip1 The first IP address.
             @param ip2 The second IP address.
             @return The OR of <code>ip1</code> and <code>ip2</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator.StringifyIP(System.Byte[])">
             Stringifies an IPv4 or v6 address with subnet mask.
            
             @param ip The IP with subnet mask.
             @return The stringified IP address.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters">
            <summary>
            Summary description for PkixParameters.
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.PkixValidityModel">
            This is the default PKIX validity model. Actually there are two variants
            of this: The PKIX model and the modified PKIX model. The PKIX model
            verifies that all involved certificates must have been valid at the
            current time. The modified PKIX model verifies that all involved
            certificates were valid at the signing time. Both are indirectly choosen
            with the {@link PKIXParameters#setDate(java.util.Date)} method, so this
            methods sets the Date when <em>all</em> certificates must have been
            valid.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.ChainValidityModel">
            This model uses the following validity model. Each certificate must have
            been valid at the moment where is was used. That means the end
            certificate must have been valid at the time the signature was done. The
            CA certificate which signed the end certificate must have been valid,
            when the end certificate was signed. The CA (or Root CA) certificate must
            have been valid, when the CA certificate was signed and so on. So the
            {@link PKIXParameters#setDate(java.util.Date)} method sets the time, when
            the <em>end certificate</em> must have been valid. <p/> It is used e.g.
            in the German signature law.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.#ctor(System.Collections.Generic.ISet{Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.TrustAnchor})">
             Creates an instance of PKIXParameters with the specified Set of
             most-trusted CAs. Each element of the set is a TrustAnchor.<br />
             <br />
             Note that the Set is copied to protect against subsequent modifications.
            
             @param trustAnchors
                        a Set of TrustAnchors
            
             @exception InvalidAlgorithmParameterException
                            if the specified Set is empty
                            <code>(trustAnchors.isEmpty() == true)</code>
             @exception NullPointerException
                            if the specified Set is <code>null</code>
             @exception ClassCastException
                            if any of the elements in the Set are not of type
                            <code>java.security.cert.TrustAnchor</code>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.GetTargetConstraintsAttrCert">
             Returns the required constraints on the target certificate or attribute
             certificate. The constraints are returned as an instance of
             <code>IX509Selector</code>. If <code>null</code>, no constraints are
             defined.
            
             <p>
             The target certificate in a PKIX path may be a certificate or an
             attribute certificate.
             </p><p>
             Note that the <code>IX509Selector</code> returned is cloned to protect
             against subsequent modifications.
             </p>
             @return a <code>IX509Selector</code> specifying the constraints on the
                     target certificate or attribute certificate (or <code>null</code>)
             @see #setTargetConstraints
             @see X509CertStoreSelector
             @see X509AttributeCertStoreSelector
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.SetTargetConstraintsAttrCert(Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Collections.ISelector{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificate})">
             Sets the required constraints on the target certificate or attribute
             certificate. The constraints are specified as an instance of
             <code>IX509Selector</code>. If <code>null</code>, no constraints are
             defined.
             <p>
             The target certificate in a PKIX path may be a certificate or an
             attribute certificate.
             </p><p>
             Note that the <code>IX509Selector</code> specified is cloned to protect
             against subsequent modifications.
             </p>
            
             @param selector a <code>IX509Selector</code> specifying the constraints on
                        the target certificate or attribute certificate (or
                        <code>null</code>)
             @see #getTargetConstraints
             @see X509CertStoreSelector
             @see X509AttributeCertStoreSelector
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.GetTargetConstraintsCert">
             Returns the required constraints on the target certificate. The
             constraints are returned as an instance of CertSelector. If
             <code>null</code>, no constraints are defined.<br />
             <br />
             Note that the CertSelector returned is cloned to protect against
             subsequent modifications.
            
             @return a CertSelector specifying the constraints on the target
                     certificate (or <code>null</code>)
            
             @see #setTargetCertConstraints(CertSelector)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.SetTargetConstraintsCert(Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Collections.ISelector{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate})">
             Sets the required constraints on the target certificate. The constraints
             are specified as an instance of CertSelector. If null, no constraints are
             defined.<br />
             <br />
             Note that the CertSelector specified is cloned to protect against
             subsequent modifications.
            
             @param selector
                        a CertSelector specifying the constraints on the target
                        certificate (or <code>null</code>)
            
             @see #getTargetCertConstraints()
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.GetInitialPolicies">
             Returns an immutable Set of initial policy identifiers (OID strings),
             indicating that any one of these policies would be acceptable to the
             certificate user for the purposes of certification path processing. The
             default return value is an empty <code>Set</code>, which is
             interpreted as meaning that any policy would be acceptable.
            
             @return an immutable <code>Set</code> of initial policy OIDs in String
                     format, or an empty <code>Set</code> (implying any policy is
                     acceptable). Never returns <code>null</code>.
            
             @see #setInitialPolicies(java.util.Set)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.SetInitialPolicies(System.Collections.Generic.ISet{System.String})">
             Sets the <code>Set</code> of initial policy identifiers (OID strings),
             indicating that any one of these policies would be acceptable to the
             certificate user for the purposes of certification path processing. By
             default, any policy is acceptable (i.e. all policies), so a user that
             wants to allow any policy as acceptable does not need to call this
             method, or can call it with an empty <code>Set</code> (or
             <code>null</code>).<br />
             <br />
             Note that the Set is copied to protect against subsequent modifications.<br />
             <br />
            
             @param initialPolicies
                        a Set of initial policy OIDs in String format (or
                        <code>null</code>)
            
             @exception ClassCastException
                            if any of the elements in the set are not of type String
            
             @see #getInitialPolicies()
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.SetCertPathCheckers(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathChecker})">
             Sets a <code>List</code> of additional certification path checkers. If
             the specified List contains an object that is not a PKIXCertPathChecker,
             it is ignored.<br />
             <br />
             Each <code>PKIXCertPathChecker</code> specified implements additional
             checks on a certificate. Typically, these are checks to process and
             verify private extensions contained in certificates. Each
             <code>PKIXCertPathChecker</code> should be instantiated with any
             initialization parameters needed to execute the check.<br />
             <br />
             This method allows sophisticated applications to extend a PKIX
             <code>CertPathValidator</code> or <code>CertPathBuilder</code>. Each
             of the specified PKIXCertPathCheckers will be called, in turn, by a PKIX
             <code>CertPathValidator</code> or <code>CertPathBuilder</code> for
             each certificate processed or validated.<br />
             <br />
             Regardless of whether these additional PKIXCertPathCheckers are set, a
             PKIX <code>CertPathValidator</code> or <code>CertPathBuilder</code>
             must perform all of the required PKIX checks on each certificate. The one
             exception to this rule is if the RevocationEnabled flag is set to false
             (see the {@link #setRevocationEnabled(boolean) setRevocationEnabled}
             method).<br />
             <br />
             Note that the List supplied here is copied and each PKIXCertPathChecker
             in the list is cloned to protect against subsequent modifications.
            
             @param checkers
                        a List of PKIXCertPathCheckers. May be null, in which case no
                        additional checkers will be used.
             @exception ClassCastException
                            if any of the elements in the list are not of type
                            <code>java.security.cert.PKIXCertPathChecker</code>
             @see #getCertPathCheckers()
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.GetCertPathCheckers">
             Returns the List of certification path checkers. Each PKIXCertPathChecker
             in the returned IList is cloned to protect against subsequent modifications.
            
             @return an immutable List of PKIXCertPathCheckers (may be empty, but not
                     <code>null</code>)
            
             @see #setCertPathCheckers(java.util.List)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.AddCertPathChecker(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathChecker)">
             Adds a <code>PKIXCertPathChecker</code> to the list of certification
             path checkers. See the {@link #setCertPathCheckers setCertPathCheckers}
             method for more details.
             <p>
             Note that the <code>PKIXCertPathChecker</code> is cloned to protect
             against subsequent modifications.</p>
            
             @param checker a <code>PKIXCertPathChecker</code> to add to the list of
             checks. If <code>null</code>, the checker is ignored (not added to list).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.SetParams(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters)">
             Method to support <code>Clone()</code> under J2ME.
             <code>super.Clone()</code> does not exist and fields are not copied.
            
             @param params Parameters to set. If this are
                        <code>ExtendedPkixParameters</code> they are copied to.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.IsUseDeltasEnabled">
            Whether delta CRLs should be used for checking the revocation status.
            Defaults to <code>false</code>.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.ValidityModel">
            The validity model.
            @see #CHAIN_VALIDITY_MODEL
            @see #PKIX_VALIDITY_MODEL
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.IsAdditionalLocationsEnabled">
             Returns if additional {@link X509Store}s for locations like LDAP found
             in certificates or CRLs should be used.
            
             @return Returns <code>true</code> if additional stores are used.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.SetAdditionalLocationsEnabled(System.Boolean)">
             Sets if additional {@link X509Store}s for locations like LDAP found in
             certificates or CRLs should be used.
            
             @param enabled <code>true</code> if additional stores are used.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.GetTrustedACIssuers">
             Returns the trusted attribute certificate issuers. If attribute
             certificates is verified the trusted AC issuers must be set.
             <p>
             The returned <code>ISet</code> consists of <code>TrustAnchor</code>s.
             </p><p>
             The returned <code>ISet</code> is immutable. Never <code>null</code>
             </p>
            
             @return Returns an immutable set of the trusted AC issuers.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.SetTrustedACIssuers(System.Collections.Generic.ISet{Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.TrustAnchor})">
             Sets the trusted attribute certificate issuers. If attribute certificates
             is verified the trusted AC issuers must be set.
             <p>
             The <code>trustedACIssuers</code> must be a <code>ISet</code> of
             <code>TrustAnchor</code>
             </p><p>
             The given set is cloned.
             </p>
            
             @param trustedACIssuers The trusted AC issuers to set. Is never
                        <code>null</code>.
             @throws ClassCastException if an element of <code>stores</code> is not
                         a <code>TrustAnchor</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.GetNecessaryACAttributes">
             Returns the necessary attributes which must be contained in an attribute
             certificate.
             <p>
             The returned <code>ISet</code> is immutable and contains
             <code>String</code>s with the OIDs.
             </p>
            
             @return Returns the necessary AC attributes.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.SetNecessaryACAttributes(System.Collections.Generic.ISet{System.String})">
             Sets the necessary which must be contained in an attribute certificate.
             <p>
             The <code>ISet</code> must contain <code>String</code>s with the
             OIDs.
             </p><p>
             The set is cloned.
             </p>
            
             @param necessaryACAttributes The necessary AC attributes to set.
             @throws ClassCastException if an element of
                         <code>necessaryACAttributes</code> is not a
                         <code>String</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.GetProhibitedACAttributes">
             Returns the attribute certificates which are not allowed.
             <p>
             The returned <code>ISet</code> is immutable and contains
             <code>String</code>s with the OIDs.
             </p>
            
             @return Returns the prohibited AC attributes. Is never <code>null</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.SetProhibitedACAttributes(System.Collections.Generic.ISet{System.String})">
             Sets the attribute certificates which are not allowed.
             <p>
             The <code>ISet</code> must contain <code>String</code>s with the
             OIDs.
             </p><p>
             The set is cloned.
             </p>
            
             @param prohibitedACAttributes The prohibited AC attributes to set.
             @throws ClassCastException if an element of
                         <code>prohibitedACAttributes</code> is not a
                         <code>String</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.GetAttrCertCheckers">
             Returns the attribute certificate checker. The returned set contains
             {@link PKIXAttrCertChecker}s and is immutable.
            
             @return Returns the attribute certificate checker. Is never
                     <code>null</code>.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters.SetAttrCertCheckers(System.Collections.Generic.ISet{Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixAttrCertChecker})">
             Sets the attribute certificate checkers.
             <p>
             All elements in the <code>ISet</code> must a {@link PKIXAttrCertChecker}.
             </p>
             <p>
             The given set is cloned.
             </p>
            
             @param attrCertCheckers The attribute certificate checkers to set. Is
                        never <code>null</code>.
             @throws ClassCastException if an element of <code>attrCertCheckers</code>
                         is not a <code>PKIXAttrCertChecker</code>.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixPolicyNode">
            <summary>
            Summary description for PkixPolicyNode.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixPolicyNode.#ctor(System.Collections.Generic.IEnumerable{Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixPolicyNode},System.Int32,System.Collections.Generic.ISet{System.String},Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixPolicyNode,System.Collections.Generic.ISet{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo},System.String,System.Boolean)">
            Constructors
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.ReasonsMask">
            <summary>
            This class helps to handle CRL revocation reasons mask. Each CRL handles a
            certain set of revocation reasons.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.ReasonsMask.#ctor(System.Int32)">
            <summary>
            Constructs are reason mask with the reasons.
            </summary>
            <param name="reasons">The reasons.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.ReasonsMask.#ctor">
            <summary>
            A reason mask with no reason.
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.ReasonsMask.AllReasons">
            <summary>
            A mask with all revocation reasons.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.ReasonsMask.AddReasons(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.ReasonsMask)">
             Adds all reasons from the reasons mask to this mask.
            
             @param mask The reasons mask to add.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.ReasonsMask.IsAllReasons">
            <summary>
            Returns <code>true</code> if this reasons mask contains all possible
            reasons.
            </summary>
            <returns>true if this reasons mask contains all possible reasons.
            </returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.ReasonsMask.Intersect(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.ReasonsMask)">
            <summary>
            Intersects this mask with the given reasons mask.
            </summary>
            <param name="mask">mask The mask to intersect with.</param>
            <returns>The intersection of this and teh given mask.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.ReasonsMask.HasNewReasons(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.ReasonsMask)">
            <summary>
            Returns <c>true</c> if the passed reasons mask has new reasons.
            </summary>
            <param name="mask">The reasons mask which should be tested for new reasons.</param>
            <returns><c>true</c> if the passed reasons mask has new reasons.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.ReasonsMask.Reasons">
            <summary>
            Returns the reasons in this mask.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCrlB2(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DistributionPoint,System.Object,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl)">
             If the complete CRL includes an issuing distribution point (IDP) CRL
             extension check the following:
             <p>
             (i) If the distribution point name is present in the IDP CRL extension
             and the distribution field is present in the DP, then verify that one of
             the names in the IDP matches one of the names in the DP. If the
             distribution point name is present in the IDP CRL extension and the
             distribution field is omitted from the DP, then verify that one of the
             names in the IDP matches one of the names in the cRLIssuer field of the
             DP.
             </p>
             <p>
             (ii) If the onlyContainsUserCerts boolean is asserted in the IDP CRL
             extension, verify that the certificate does not include the basic
             constraints extension with the cA boolean asserted.
             </p>
             <p>
             (iii) If the onlyContainsCACerts boolean is asserted in the IDP CRL
             extension, verify that the certificate includes the basic constraints
             extension with the cA boolean asserted.
             </p>
             <p>
             (iv) Verify that the onlyContainsAttributeCerts boolean is not asserted.
             </p>
            
             @param dp   The distribution point.
             @param cert The certificate.
             @param crl  The CRL.
             @throws AnnotatedException if one of the conditions is not met or an error occurs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCertBC(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator)">
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.PrepareNextCertA(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,System.Int32)">
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCertD(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,System.Int32,System.Collections.Generic.ISet{System.String},Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixPolicyNode,System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixPolicyNode}[],System.Int32)">
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCrlB1(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DistributionPoint,System.Object,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl)">
             If the DP includes cRLIssuer, then verify that the issuer field in the
             complete CRL matches cRLIssuer in the DP and that the complete CRL
             contains an
                  g distribution point extension with the indirectCRL
             boolean asserted. Otherwise, verify that the CRL issuer matches the
             certificate issuer.
            
             @param dp   The distribution point.
             @param cert The certificate ot attribute certificate.
             @param crl  The CRL for <code>cert</code>.
             @throws AnnotatedException if one of the above conditions does not apply or an error
                                        occurs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCrlF(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl,System.Object,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters,System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate})">
             Obtain and validate the certification path for the complete CRL issuer.
             If a key usage extension is present in the CRL issuer's certificate,
             verify that the cRLSign bit is set.
            
             @param crl                CRL which contains revocation information for the certificate
                                       <code>cert</code>.
             @param cert               The attribute certificate or certificate to check if it is
                                       revoked.
             @param defaultCRLSignCert The issuer certificate of the certificate <code>cert</code>.
             @param defaultCRLSignKey  The public key of the issuer certificate
                                       <code>defaultCRLSignCert</code>.
             @param paramsPKIX         paramsPKIX PKIX parameters.
             @param certPathCerts      The certificates on the certification path.
             @return A <code>Set</code> with all keys of possible CRL issuer
                     certificates.
             @throws AnnotatedException if the CRL is not valid or the status cannot be checked or
                                        some error occurs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.CheckCrl(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DistributionPoint,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.DateTime,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.CertStatus,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.ReasonsMask,System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate})">
             Checks a distribution point for revocation information for the
             certificate <code>cert</code>.
            
             @param dp                 The distribution point to consider.
             @param paramsPKIX         PKIX parameters.
             @param cert               Certificate to check if it is revoked.
             @param validDate          The date when the certificate revocation status should be
                                       checked.
             @param defaultCRLSignCert The issuer certificate of the certificate <code>cert</code>.
             @param defaultCRLSignKey  The public key of the issuer certificate
                                       <code>defaultCRLSignCert</code>.
             @param certStatus         The current certificate revocation status.
             @param reasonMask         The reasons mask which is already checked.
             @param certPathCerts      The certificates of the certification path.
             @throws AnnotatedException if the certificate is revoked or the status cannot be checked
                                        or some error occurs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.CheckCrls(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.DateTime,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate})">
             Checks a certificate if it is revoked.
            
             @param paramsPKIX       PKIX parameters.
             @param cert             Certificate to check if it is revoked.
             @param validDate        The date when the certificate revocation status should be
                                     checked.
             @param sign             The issuer certificate of the certificate <code>cert</code>.
             @param workingPublicKey The public key of the issuer certificate <code>sign</code>.
             @param certPathCerts    The certificates of the certification path.
             @throws AnnotatedException if the certificate is revoked or the status cannot be checked
                                        or some error occurs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.PrepareCertB(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,System.Int32,System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixPolicyNode}[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixPolicyNode,System.Int32)">
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.PrepareNextCertI2(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,System.Int32,System.Int32)">
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.PrepareNextCertG(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixNameConstraintValidator)">
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.PrepareNextCertJ(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,System.Int32,System.Int32)">
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.PrepareNextCertK(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,System.Int32)">
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.PrepareNextCertL(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,System.Int32,System.Int32)">
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.PrepareNextCertM(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,System.Int32,System.Int32)">
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.PrepareNextCertN(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,System.Int32)">
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.PrepareNextCertO(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,System.Int32,System.Collections.Generic.ISet{System.String},System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathChecker})">
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.WrapupCertB(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,System.Int32,System.Int32)">
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.WrapupCertF(Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPath,System.Int32,System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathChecker},System.Collections.Generic.ISet{System.String})">
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixCertPathValidatorException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCrlC(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters)">
             If use-deltas is set, verify the issuer and scope of the delta CRL.
            
             @param deltaCRL    The delta CRL.
             @param completeCRL The complete CRL.
             @param pkixParams  The PKIX paramaters.
             @throws AnnotatedException if an exception occurs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3281CertPathUtilities.CheckCrls(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificate,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.DateTime,System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate})">
            Checks if an attribute certificate is revoked.
            
            @param attrCert Attribute certificate to check if it is revoked.
            @param paramsPKIX PKIX parameters.
            @param issuerCert The issuer certificate of the attribute certificate
                       <code>attrCert</code>.
            @param validDate The date when the certificate revocation status should
                       be checked.
            @param certPathCerts The certificates of the certification path to be
                       checked.
            
            @throws CertPathValidatorException if the certificate is revoked or the
                        status cannot be checked or some error occurs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3281CertPathUtilities.ProcessAttrCert1(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificate,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters)">
            Searches for a holder public key certificate and verifies its
            certification path.
            
            @param attrCert the attribute certificate.
            @param pkixParams The PKIX parameters.
            @return The certificate path of the holder certificate.
            @throws Exception if
                        <ul>
                        <li>no public key certificate can be found although holder
                        information is given by an entity name or a base certificate
                        ID</li>
                        <li>support classes cannot be created</li>
                        <li>no certification path for the public key certificate can
                        be built</li>
                        </ul>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.Rfc3281CertPathUtilities.CheckCrl(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.DistributionPoint,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificate,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.PkixParameters,System.DateTime,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.CertStatus,Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.ReasonsMask,System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate})">
            
            Checks a distribution point for revocation information for the
            certificate <code>attrCert</code>.
            
            @param dp The distribution point to consider.
            @param attrCert The attribute certificate which should be checked.
            @param paramsPKIX PKIX parameters.
            @param validDate The date when the certificate revocation status should
                       be checked.
            @param issuerCert Certificate to check if it is revoked.
            @param reasonMask The reasons mask which is already checked.
            @param certPathCerts The certificates of the certification path to be
                       checked.
            @throws Exception if the certificate is revoked or the status
                        cannot be checked or some error occurs.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.TrustAnchor">
            <summary>
            A trust anchor or most-trusted Certification Authority (CA).
            
            This class represents a "most-trusted CA", which is used as a trust anchor
            for validating X.509 certification paths. A most-trusted CA includes the
            public key of the CA, the CA's name, and any constraints upon the set of
            paths which may be validated using this key. These parameters can be
            specified in the form of a trusted X509Certificate or as individual
            parameters.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.TrustAnchor.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.Byte[])">
             <summary>
             Creates an instance of TrustAnchor with the specified X509Certificate and
             optional name constraints, which are intended to be used as additional
             constraints when validating an X.509 certification path.
            	The name constraints are specified as a byte array. This byte array
            	should contain the DER encoded form of the name constraints, as they
            	would appear in the NameConstraints structure defined in RFC 2459 and
            	X.509. The ASN.1 definition of this structure appears below.
            	
            	<pre>
            	NameConstraints ::= SEQUENCE {
            		permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,
            		excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }
            	   
             GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree
             
            		GeneralSubtree ::= SEQUENCE {
            		base                    GeneralName,
            		minimum         [0]     BaseDistance DEFAULT 0,
            		maximum         [1]     BaseDistance OPTIONAL }
            		
            		BaseDistance ::= INTEGER (0..MAX)
            
            		GeneralName ::= CHOICE {
            		otherName                       [0]     OtherName,
            		rfc822Name                      [1]     IA5String,
            		dNSName                         [2]     IA5String,
            		x400Address                     [3]     ORAddress,
            		directoryName                   [4]     Name,
            		ediPartyName                    [5]     EDIPartyName,
            		uniformResourceIdentifier       [6]     IA5String,
            		iPAddress                       [7]     OCTET STRING,
            		registeredID                    [8]     OBJECT IDENTIFIER}
            	</pre>
            	
            	Note that the name constraints byte array supplied is cloned to protect
            	against subsequent modifications.
             </summary>
             <param name="trustedCert">a trusted X509Certificate</param>
             <param name="nameConstraints">a byte array containing the ASN.1 DER encoding of a
             NameConstraints extension to be used for checking name
             constraints. Only the value of the extension is included, not
             the OID or criticality flag. Specify null to omit the
             parameter.</param>
             <exception cref="T:System.ArgumentNullException">if the specified X509Certificate is null</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.TrustAnchor.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[])">
            <summary>
            Creates an instance of <c>TrustAnchor</c> where the
            most-trusted CA is specified as an X500Principal and public key.
            </summary>
            <remarks>
            <p>
            Name constraints are an optional parameter, and are intended to be used
            as additional constraints when validating an X.509 certification path.
            </p><p>
            The name constraints are specified as a byte array. This byte array
            contains the DER encoded form of the name constraints, as they
            would appear in the NameConstraints structure defined in RFC 2459
            and X.509. The ASN.1 notation for this structure is supplied in the
            documentation for the other constructors.
            </p><p>
            Note that the name constraints byte array supplied here is cloned to
            protect against subsequent modifications.
            </p>
            </remarks>
            <param name="caPrincipal">the name of the most-trusted CA as X509Name</param>
            <param name="pubKey">the public key of the most-trusted CA</param>
            <param name="nameConstraints">
            a byte array containing the ASN.1 DER encoding of a NameConstraints extension to
            be used for checking name constraints. Only the value of the extension is included,
            not the OID or criticality flag. Specify <c>null</c> to omit the parameter.
            </param>
            <exception cref="T:System.ArgumentNullException">
            if <c>caPrincipal</c> or <c>pubKey</c> is null
            </exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.TrustAnchor.#ctor(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[])">
            <summary>
            Creates an instance of <code>TrustAnchor</code> where the most-trusted
            CA is specified as a distinguished name and public key. Name constraints
            are an optional parameter, and are intended to be used as additional
            constraints when validating an X.509 certification path.
            <br/>
            The name constraints are specified as a byte array. This byte array
            contains the DER encoded form of the name constraints, as they would
            appear in the NameConstraints structure defined in RFC 2459 and X.509.
            </summary>
            <param name="caName">the X.500 distinguished name of the most-trusted CA in RFC
            2253 string format</param>
            <param name="pubKey">the public key of the most-trusted CA</param>
            <param name="nameConstraints">a byte array containing the ASN.1 DER encoding of a
            NameConstraints extension to be used for checking name
            constraints. Only the value of the extension is included, not 
            the OID or criticality flag. Specify null to omit the 
            parameter.</param>
            throws NullPointerException, IllegalArgumentException
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.TrustAnchor.TrustedCert">
            <summary>
            Returns the most-trusted CA certificate.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.TrustAnchor.CA">
            <summary>
            Returns the name of the most-trusted CA as an X509Name.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.TrustAnchor.CAName">
            <summary>
            Returns the name of the most-trusted CA in RFC 2253 string format.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.TrustAnchor.CAPublicKey">
            <summary>
            Returns the public key of the most-trusted CA.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.TrustAnchor.setNameConstraints(System.Byte[])">
            <summary>
            Decode the name constraints and clone them if not null.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Pkix.TrustAnchor.ToString">
            <summary>
            Returns a formatted string describing the <code>TrustAnchor</code>.
            </summary>
            <returns>a formatted string describing the <code>TrustAnchor</code></returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsClient">
            <summary>Base class for a TLS client.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsClient.AllowUnexpectedServerExtension(System.Int32,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsClient.CheckForUnexpectedServerExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsClient.GetPskIdentity">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsClient.GetSrpIdentity">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsClient.GetMultiCertStatusRequest">
            <returns>an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequestItemV2"/> (or null).</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsClient.GetSupportedGroups(System.Collections.Generic.IList{System.Int32})">
            <summary>The default <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsClient.GetClientExtensions"/> implementation calls this to determine which named
            groups to include in the supported_groups extension for the ClientHello.</summary>
            <param name="namedGroupRoles">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.NamedGroupRole">named group roles</see> for which there should
            be at least one supported group. By default this is inferred from the offered cipher suites and signature
            algorithms.</param>
            <returns>an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:System.Int32"/>. See <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.NamedGroup"/> for group constants.
            </returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsClient.NotifyHandshakeBeginning">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsClient.GetClientExtensions">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsClient.NotifyServerVersion(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsClient.NotifySelectedPsk(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPsk)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsClient.ProcessServerExtensions(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsClient.ProcessServerSupplementalData(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SupplementalDataEntry})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsClient.GetClientSupplementalData">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsClient.NotifyNewSessionTicket(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.NewSessionTicket)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsContext.HandshakeBeginning(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsContext.HandshakeComplete(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSession)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsKeyExchange">
            <summary>Base class for supporting a TLS key exchange implementation.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsKeyExchangeFactory">
            <summary>Base class for supporting a TLS key exchange factory implementation.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsPeer">
            <summary>Base class for a TLS client or server.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsPeer.GetSupportedVersions">
            <summary>Get the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion"/> values that are supported by this peer.</summary>
            <remarks>
            WARNING: Mixing DTLS and TLS versions in the returned array is currently NOT supported. Use a separate
            (sub-)class for each case.
            </remarks>
            <returns>an array of supported <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion"/> values.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsPeer.Cancel">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsPeer.NotifyHandshakeBeginning">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsPeer.NotifySecureRenegotiation(System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsPeer.GetKeyExchangeFactory">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsPeer.NotifyHandshakeComplete">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsServer">
            <summary>Base class for a TLS server.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AbstractTlsServer.SelectCipherSuite(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription">
            <summary>RFC 5246 7.2.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.close_notify">
            <summary>This message notifies the recipient that the sender will not send any more messages on this
            connection.</summary>
            <remarks>
            Note that as of TLS 1.1, failure to properly close a connection no longer requires that a session not be
            resumed. This is a change from TLS 1.0 ("The session becomes unresumable if any connection is terminated
            without proper close_notify messages with level equal to warning.") to conform with widespread
            implementation practice.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.unexpected_message">
            <summary>An inappropriate message was received.</summary>
            <remarks>
            This alert is always fatal and should never be observed in communication between proper implementations.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.bad_record_mac">
            <summary>This alert is returned if a record is received with an incorrect MAC.</summary>
            <remarks>
            This alert also MUST be returned if an alert is sent because a TLSCiphertext decrypted in an invalid way:
            either it wasn't an even multiple of the block length, or its padding values, when checked, weren't
            correct. This message is always fatal and should never be observed in communication between proper
            implementations (except when messages were corrupted in the network).
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.decryption_failed">
            <remarks>
            This alert was used in some earlier versions of TLS, and may have permitted certain attacks against the CBC
            mode [CBCATT]. It MUST NOT be sent by compliant implementations.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.record_overflow">
            <summary>A TLSCiphertext record was received that had a length more than 2^14+2048 bytes, or a record
            decrypted to a TLSCompressed record with more than 2^14+1024 bytes.</summary>
            <remarks>
            This message is always fatal and should never be observed in communication between proper implementations
            (except when messages were corrupted in the network).
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.decompression_failure">
            <summary>The decompression function received improper input (e.g., data that would expand to excessive
            length).</summary>
            <remarks>
            This message is always fatal and should never be observed in communication between proper implementations.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.handshake_failure">
            <summary>Reception of a handshake_failure alert message indicates that the sender was unable to negotiate
            an acceptable set of security parameters given the options available.</summary>
            <remarks>
            This is a fatal error.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.no_certificate">
            <remarks>
            This alert was used in SSLv3 but not any version of TLS. It MUST NOT be sent by compliant implementations.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.bad_certificate">
            <summary>A certificate was corrupt, contained signatures that did not verify correctly, etc.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.unsupported_certificate">
            <summary>A certificate was of an unsupported type.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.certificate_revoked">
            <summary>A certificate was revoked by its signer.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.certificate_expired">
            <summary>A certificate has expired or is not currently valid.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.certificate_unknown">
            <summary>Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable.
            </summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.illegal_parameter">
            <summary>A field in the handshake was out of range or inconsistent with other fields.</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.unknown_ca">
            <summary>A valid certificate chain or partial chain was received, but the certificate was not accepted
            because the CA certificate could not be located or couldn't be matched with a known, trusted CA.</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.access_denied">
            <summary>A valid certificate was received, but when access control was applied, the sender decided not to
            proceed with negotiation.</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.decode_error">
            <summary>A message could not be decoded because some field was out of the specified range or the length of
            the message was incorrect.</summary>
            <remarks>
            This message is always fatal and should never be observed in communication between proper
            implementations (except when messages were corrupted in the network).
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.decrypt_error">
            <summary>A handshake cryptographic operation failed, including being unable to correctly verify a signature
            or validate a Finished message.</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.export_restriction">
            <remarks>
            This alert was used in some earlier versions of TLS. It MUST NOT be sent by compliant implementations.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.protocol_version">
            <summary>The protocol version the client has attempted to negotiate is recognized but not supported.
            </summary>
            <remarks>
            (For example, old protocol versions might be avoided for security reasons.) This message is always fatal.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.insufficient_security">
            <summary>Returned instead of handshake_failure when a negotiation has failed specifically because the
            server requires ciphers more secure than those supported by the client.</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.internal_error">
            <summary>An internal error unrelated to the peer or the correctness of the protocol (such as a memory
            allocation failure) makes it impossible to continue.</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.user_canceled">
            <summary>This handshake is being canceled for some reason unrelated to a protocol failure.</summary>
            <remarks>
            If the user cancels an operation after the handshake is complete, just closing the connection by sending a
            close_notify is more appropriate. This alert should be followed by a close_notify. This message is
            generally a warning.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.no_renegotiation">
            <summary>Sent by the client in response to a hello request or by the server in response to a client hello
            after initial handshaking.</summary>
            <remarks>
            Either of these would normally lead to renegotiation; when that is not appropriate, the recipient should
            respond with this alert. At that point, the original requester can decide whether to proceed with the
            connection. One case where this would be appropriate is where a server has spawned a process to satisfy a
            request; the process might receive security parameters (key length, authentication, etc.) at startup, and
            it might be difficult to communicate changes to these parameters after that point. This message is always a
            warning.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.unsupported_extension">
            <summary>Sent by clients that receive an extended server hello containing an extension that they did not
            put in the corresponding client hello.</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.certificate_unobtainable">
            <summary>This alert is sent by servers who are unable to retrieve a certificate chain from the URL supplied
            by the client(see Section 3.3).</summary>
            <remarks>
            This message MAY be fatal - for example if client authentication is required by the server for the
            handshake to continue and the server is unable to retrieve the certificate chain, it may send a fatal
            alert.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.unrecognized_name">
            <summary>This alert is sent by servers that receive a server_name extension request, but do not recognize
            the server name.</summary>
            <remarks>
            This message MAY be fatal.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.bad_certificate_status_response">
            <summary>This alert is sent by clients that receive an invalid certificate status response (see Section 3.6
            ).</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.bad_certificate_hash_value">
            <summary>This alert is sent by servers when a certificate hash does not match a client provided
            certificate_hash.</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.unknown_psk_identity">
            <summary>If the server does not recognize the PSK identity, it MAY respond with an "unknown_psk_identity"
            alert message.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.no_application_protocol">
            <summary>In the event that the server supports no protocols that the client advertises, then the server
            SHALL respond with a fatal "no_application_protocol" alert.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.inappropriate_fallback">
            <summary>If TLS_FALLBACK_SCSV appears in ClientHello.cipher_suites and the highest protocol version
            supported by the server is higher than the version indicated in ClientHello.client_version, the server MUST
            respond with a fatal inappropriate_fallback alert[..].</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.missing_extension">
            <summary>Sent by endpoints that receive a handshake message not containing an extension that is mandatory
            to send for the offered TLS version or other negotiated parameters.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.certificate_required">
            <summary>Sent by servers when a client certificate is desired but none was provided by the client.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertLevel">
            <summary>RFC 5246 7.2</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.BasicTlsPskIdentity">
            <summary>A basic PSK Identity holder.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.BasicTlsSrpIdentity">
            <summary>A basic SRP Identity holder.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ByteQueue">
            <summary>A queue for bytes. This file could be more optimized.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ByteQueue.GetAllocationSize(System.Int32)">
            <returns>The smallest number which can be written as 2^x which is bigger than i.</returns>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ByteQueue.m_databuf">
            <summary>The buffer where we store our data.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ByteQueue.m_skipped">
            <summary>How many bytes at the beginning of the buffer are skipped.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ByteQueue.m_available">
            <summary>How many bytes in the buffer are valid data.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ByteQueue.AddData(System.Byte[],System.Int32,System.Int32)">
            <summary>Add some data to our buffer.</summary>
            <param name="buf">A byte-array to read data from.</param>
            <param name="off">How many bytes to skip at the beginning of the array.</param>
            <param name="len">How many bytes to read from the array.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ByteQueue.Available">
            <returns>The number of bytes which are available in this buffer.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ByteQueue.CopyTo(System.IO.Stream,System.Int32)">
            <summary>Copy some bytes from the beginning of the data to the provided <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">The <see cref="T:System.IO.Stream"/> to copy the bytes to.</param>
            <param name="length">How many bytes to copy.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ByteQueue.Read(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>Read data from the buffer.</summary>
            <param name="buf">The buffer where the read data will be copied to.</param>
            <param name="offset">How many bytes to skip at the beginning of buf.</param>
            <param name="len">How many bytes to read at all.</param>
            <param name="skip">How many bytes from our data to skip.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ByteQueue.ReadHandshakeMessage(System.Int32)">
            <summary>Return a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HandshakeMessageInput"/> over some bytes at the beginning of the data.
            </summary>
            <param name="length">How many bytes will be readable.</param>
            <returns>A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HandshakeMessageInput"/> over the data.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ByteQueue.RemoveData(System.Int32)">
            <summary>Remove some bytes from our data from the beginning.</summary>
            <param name="i">How many bytes to remove.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ByteQueue.RemoveData(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>Remove data from the buffer.</summary>
            <param name="buf">The buffer where the removed data will be copied to.</param>
            <param name="off">How many bytes to skip at the beginning of buf.</param>
            <param name="len">How many bytes to read at all.</param>
            <param name="skip">How many bytes from our data to skip.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ByteQueueOutputStream">
            <summary>OutputStream based on a ByteQueue implementation.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertChainType">
            <summary>Implementation of the RFC 3546 3.3. CertChainType.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate">
            <summary>Parsing and encoding of a <i>Certificate</i> struct from RFC 4346.</summary>
            <remarks>
            <pre>
            opaque ASN.1Cert&lt;2^24-1&gt;;
            struct {
              ASN.1Cert certificate_list&lt;0..2^24-1&gt;;
            } Certificate;
            </pre>
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate.GetCertificateList">
            <returns>an array of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate"/> representing a certificate chain.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate.IsEmpty">
            <returns><c>true</c> if this certificate chain contains no certificates, or <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate.Encode(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,System.IO.Stream,System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate"/> to a <see cref="T:System.IO.Stream"/>, and optionally calculate the
            "end point hash" (per RFC 5929's tls-server-end-point binding).</summary>
            <param name="context">the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="messageOutput">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <param name="endPointHashOutput">the <see cref="T:System.IO.Stream"/> to write the "end point hash" to (or null).
            </param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate.Parse(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate.ParseOptions,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,System.IO.Stream,System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="options">the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate.ParseOptions"/> to apply during parsing.</param>
            <param name="context">the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="messageInput">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <param name="endPointHashOutput">the <see cref="T:System.IO.Stream"/> to write the "end point hash" to (or null).
            </param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateCompressionAlgorithm">
            RFC 8879
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest">
            <summary>Parsing and encoding of a <i>CertificateRequest</i> struct from RFC 4346.</summary>
            <remarks>
            <pre>
            struct {
              ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
              DistinguishedName certificate_authorities&lt;3..2^16-1&gt;;
            } CertificateRequest;
            </pre>
            Updated for RFC 5246:
            <pre>
            struct {
              ClientCertificateType certificate_types &lt;1..2 ^ 8 - 1&gt;;
              SignatureAndHashAlgorithm supported_signature_algorithms &lt;2 ^ 16 - 1&gt;;
              DistinguishedName certificate_authorities &lt;0..2 ^ 16 - 1&gt;;
            } CertificateRequest;
            </pre>
            Revised for RFC 8446:
            <pre>
            struct {
              opaque certificate_request_context &lt;0..2 ^ 8 - 1&gt;;
              Extension extensions &lt;2..2 ^ 16 - 1&gt;;
            } CertificateRequest;
            </pre>
            </remarks>
            <seealso cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ClientCertificateType"/>
            <seealso cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest.CheckSupportedSignatureAlgorithms(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm},System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest.#ctor(System.Int16[],System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm},System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name})">
            <param name="certificateTypes">see <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ClientCertificateType"/> for valid constants.</param>
            <param name="supportedSignatureAlgorithms"></param>
            <param name="certificateAuthorities">an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name"/>.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest.#ctor(System.Byte[],System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm},System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm},System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest.CertificateTypes">
            <returns>an array of certificate types</returns>
            <seealso cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ClientCertificateType"/>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest.SupportedSignatureAlgorithms">
            <returns>an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm"/> (or null before TLS 1.2).
            </returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest.SupportedSignatureAlgorithmsCert">
            <returns>an optional <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm"/>. May be non-null from
            TLS 1.3 onwards.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest.CertificateAuthorities">
            <returns>an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name"/>.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest.Encode(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="context">the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest.Parse(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest"/> from a <see cref="T:System.IO.Stream"/></summary>
            <param name="context">the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatus.OcspResponseList">
            <summary>an <see cref="T:System.Collections.Generic.IList`1"/> of (possibly null) <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.OcspResponse"/>.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatus.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatus"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatus.Parse(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatus"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="context">the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatus"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatus.ParseOcspResponse(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatus.RequireStatusRequestVersion(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequest">
            <summary>Implementation of the RFC 3546 3.6. CertificateStatusRequest.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequest.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequest"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequest.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequest"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequest"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequestItemV2">
            <summary>Implementation of the RFC 6961 2.2. CertificateStatusRequestItemV2.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequestItemV2.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequestItemV2"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequestItemV2.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequestItemV2"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequestItemV2"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateType">
            <summary>RFC 6091</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateUrl">
            <summary>RFC 3546 3.3</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateUrl.#ctor(System.Int16,System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.UrlAndHash})">
            <param name="type">see <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertChainType"/> for valid constants.</param>
            <param name="urlAndHashList">an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.UrlAndHash"/>.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateUrl.Type">
            <returns><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertChainType"/></returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateUrl.UrlAndHashList">
            <returns>an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.UrlAndHash"/>.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateUrl.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateUrl"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateUrl.Parse(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateUrl"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="context">the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateUrl"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateVerify.Algorithm">
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureScheme"/> value.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateVerify.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateVerify"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateVerify.Parse(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateVerify"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="context">the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateVerify"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ChannelBinding">
            <summary>RFC 5056</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to depend on the
            particular values (e.g.serialization).
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CipherSuite">
            <summary>RFC 2246 A.5</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CipherType">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to depend on the
            particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ClientHello.Encode(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ClientHello"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="context">the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ClientHello.Parse(System.IO.MemoryStream,System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ClientHello"/> from a <see cref="T:System.IO.MemoryStream"/>.</summary>
            <param name="messageInput">the <see cref="T:System.IO.MemoryStream"/> to parse from.</param>
            <param name="dtlsOutput">for DTLS this should be non-null; the input is copied to this
            <see cref="T:System.IO.Stream"/>, minus the cookie field.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ClientHello"/> object.</returns>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsFatalAlert"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ClientHello.ImplParse(System.IO.MemoryStream,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CombinedHash">
            <summary>A combined hash, which implements md5(m) || sha1(m).</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CompressionMethod">
            <summary>RFC 2246 6.1</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ConnectionEnd">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to depend on the
            particular values(e.g.serialization).
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ContentType">
            <summary>RFC 2246 6.2.1</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.DHGroup">
            <summary>Carrier class for Diffie-Hellman group parameters.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.DHGroup.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.Int32)">
            <summary>Base constructor with the prime factor of (p - 1).</summary>
            <param name="p">the prime modulus.</param>
            <param name="q">specifies the prime factor of (p - 1).</param>
            <param name="g">the base generator.</param>
            <param name="l"></param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.DHStandardGroups">
            <summary>Standard Diffie-Hellman groups from various IETF specifications.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.AbstractTlsCrypto">
            <summary>Base class for a TlsCrypto implementation that provides some needed methods from elsewhere in the impl
            package.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.AbstractTlsSecret">
            <summary>Base class for a TlsSecret implementation which captures common code and fields.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.AbstractTlsSecret.#ctor(System.Byte[])">
            <summary>Base constructor.</summary>
            <param name="data">the byte[] making up the secret value.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.AbstractTlsSecret.Encrypt(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsEncryptor)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcDefaultTlsCredentialedAgreement">
            <summay>Credentialed class generating agreed secrets from a peer's public key for our end of the TLS connection
            using the BC light-weight API.</summay>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcDefaultTlsCredentialedDecryptor">
            <summary>Credentialed class decrypting RSA encrypted secrets sent from a peer for our end of the TLS connection
            using the BC light-weight API.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcDefaultTlsCredentialedSigner">
            <summary>Credentialed class for generating signatures based on the use of primitives from the BC light-weight API.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcSsl3Hmac">
            <summary>HMAC implementation based on original internet draft for HMAC (RFC 2104).</summary>
            <remarks>
            The difference is that padding is concatenated versus XORed with the key, e.g:
            <code>H(K + opad, H(K + ipad, text))</code>
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcSsl3Hmac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IDigest)">
            <summary>Base constructor for one of the standard digest algorithms for which the byteLength is known.
            </summary>
            <remarks>
            Behaviour is undefined for digests other than MD5 or SHA1.
            </remarks>
            <param name="digest">the digest.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcSsl3Hmac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate">
            <summary>Implementation class for a single X.509 certificate based on the BC light-weight API.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.Convert(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCrypto,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.ParseCertificate(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCrypto,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.GetEncoded">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.GetExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCrypto">
            Class for providing cryptographic services for TLS based on implementations in the BC light-weight API.
            <p>
                This class provides default implementations for everything. If you need to customise it, extend the class
                and override the appropriate methods.
            </p>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDH">
            <summary>Support class for ephemeral Diffie-Hellman using the BC light-weight library.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDHDomain">
            <summary>BC light-weight support class for Diffie-Hellman key pair generation and key agreement over a
            specified Diffie-Hellman configuration.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDHDomain.DecodeParameter(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDHDomain.DecodePublicKey(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDsaSigner">
            <summary>Implementation class for generation of the raw DSA signature type using the BC light-weight API.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDsaVerifier">
            <summary>Implementation class for the verification of the raw DSA signature type using the BC light-weight API.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDssSigner">
            <summary>BC light-weight base class for the signers implementing the two DSA style algorithms from FIPS PUB
            186-4: DSA and ECDSA.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDssVerifier">
            <summary>BC light-weight base class for the verifiers supporting the two DSA style algorithms from FIPS PUB
            186-4: DSA and ECDSA.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDH">
            <summary>Support class for ephemeral Elliptic Curve Diffie-Hellman using the BC light-weight library.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDomain">
            EC domain class for generating key pairs and performing key agreement.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDomain.DecodePublicKey(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDsa13Signer">
            <summary>Implementation class for generation of ECDSA signatures in TLS 1.3+ using the BC light-weight API.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDsaSigner">
            <summary>Implementation class for generation of the raw ECDSA signature type using the BC light-weight API.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDsaVerifier">
            <summary>Implementation class for the verification of the raw ECDSA signature type using the BC light-weight
            API.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate">
            <summary>Implementation class for a single X.509 certificate based on the BC light-weight API.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCrypto,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.CreateEncryptor(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.CreateVerifier(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.CreateVerifier(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.GetEncoded">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.GetExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.GetLegacySignatureAlgorithm">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.GetPubKeyDH">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.GetPubKeyDss">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.GetPubKeyEC">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.GetPubKeyEd25519">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.GetPubKeyEd448">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.GetPubKeyRsa">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.SupportsSignatureAlgorithm(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.SupportsSignatureAlgorithmCA(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.CheckUsageInRole(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.GetPublicKey">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.SupportsSignatureAlgorithm(System.Int16,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.ValidateKeyUsage(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.ValidateRsa_Pkcs1">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.ValidateRsa_Pss_Pss(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate.ValidateRsa_Pss_Rsae">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRsaPssSigner">
            <summary>Operator supporting the generation of RSASSA-PSS signatures using the BC light-weight API.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRsaPssVerifier">
            <summary>Operator supporting the verification of RSASSA-PSS signatures using the BC light-weight API.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRsaSigner">
            <summary>Operator supporting the generation of RSASSA-PKCS1-v1_5 signatures using the BC light-weight API.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRsaVerifier">
            <summary>Operator supporting the verification of RSASSA-PKCS1-v1_5 signatures using the BC light-weight API.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsSecret">
            <summary>BC light-weight support class for handling TLS secrets and deriving key material and other secrets
            from them.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcX25519">
            <summary>Support class for X25519 using the BC light-weight library.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.BC.BcX448">
            <summary>Support class for X448 using the BC light-weight library.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipher">
            <summary>A generic TLS 1.2 AEAD cipher.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl">
            <summary>Base interface for services supporting AEAD encryption/decryption.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl.SetKey(System.Byte[],System.Int32,System.Int32)">
            <summary>Set the key to be used by the AEAD cipher implementation supporting this service.</summary>
            <param name="key">array holding the AEAD cipher key.</param>
            <param name="keyOff">offset into the array the key starts at.</param>
            <param name="keyLen">length of the key in the array.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl.Init(System.Byte[],System.Int32,System.Byte[])">
            <summary>Initialise the parameters for the AEAD operator.</summary>
            <param name="nonce">the nonce.</param>
            <param name="macSize">MAC size in bytes.</param>
            <param name="additionalData">any additional data to be included in the MAC calculation.</param>
            <exception cref="T:System.IO.IOException">if the parameters are inappropriate.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl.GetOutputSize(System.Int32)">
            <summary>Return the maximum size of the output for input of inputLength bytes.</summary>
            <param name="inputLength">the length (in bytes) of the proposed input.</param>
            <returns>the maximum size of the output.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl.DoFinal(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>Perform the cipher encryption/decryption returning the output in output.</summary>
            <remarks>
            Note: we have to use DoFinal() here as it is the only way to guarantee output from the underlying cipher.
            </remarks>
            <param name="input">array holding input data to the cipher.</param>
            <param name="inputOffset">offset into input array data starts at.</param>
            <param name="inputLength">length of the input data in the array.</param>
            <param name="output">array to hold the cipher output.</param>
            <param name="outputOffset">offset into output array to start saving output.</param>
            <returns>the amount of data written to output.</returns>
            <exception cref="T:System.IO.IOException">in case of failure.</exception>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipher">
            <summary>A generic TLS 1.0-1.2 block cipher. This can be used for AES or 3DES for example.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHmac,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHmac,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl">
            <summary>Interface for block cipher services.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl.SetKey(System.Byte[],System.Int32,System.Int32)">
            <summary>Set the key to be used by the block cipher implementation supporting this service.</summary>
            <param name="key">array holding the block cipher key.</param>
            <param name="keyOff">offset into the array the key starts at.</param>
            <param name="keyLen">length of the key in the array.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl.Init(System.Byte[],System.Int32,System.Int32)">
            <summary>Initialise the parameters for operator.</summary>
            <param name="iv">array holding the initialization vector (IV).</param>
            <param name="ivOff">offset into the array the IV starts at.</param>
            <param name="ivLen">length of the IV in the array.</param>
            <exception cref="T:System.IO.IOException">if the parameters are inappropriate.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl.DoFinal(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>Perform the cipher encryption/decryption returning the output in output.</summary>
            <remarks>
            Note: we have to use DoFinal() here as it is the only way to guarantee output from the underlying cipher.
            </remarks>
            <param name="input">array holding input data to the cipher.</param>
            <param name="inputOffset">offset into input array data starts at.</param>
            <param name="inputLength">length of the input data in the array.</param>
            <param name="output">array to hold the cipher output.</param>
            <param name="outputOffset">offset into output array to start saving output.</param>
            <returns>the amount of data written to output.</returns>
            <exception cref="T:System.IO.IOException">in case of failure.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl.GetBlockSize">
            <summary>Return the blocksize (in bytes) of the underlying block cipher.</summary>
            <returns>the cipher's blocksize.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsImplUtilities">
            <summary>Useful utility methods.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsNullCipher">
            <summary>The NULL cipher.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsNullCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHmac,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHmac)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsSuiteHmac">
            <summary>A generic TLS MAC implementation, acting as an HMAC based on some underlying Digest.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsSuiteHmac.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHmac)">
            <summary>Generate a new instance of a TlsMac.</summary>
            <param name="cryptoParams">the TLS client context specific crypto parameters.</param>
            <param name="mac">The MAC to use.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsSuiteMac">
            <summary>Base interface for a generic TLS MAC implementation for use with a bulk cipher.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsSuiteMac.Size">
            <summary>Return the output length (in bytes) of this MAC.</summary>
            <returns>The output length of this MAC.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsSuiteMac.CalculateMac(System.Int64,System.Int16,System.Byte[],System.Int32,System.Int32)">
            <summary>Calculate the MAC for some given data.</summary>
            <param name="seqNo">The sequence number of the record.</param>
            <param name="type">The content type of the message.</param>
            <param name="message">A byte array containing the message.</param>
            <param name="offset">The number of bytes to skip, before the message starts.</param>
            <param name="length">The length of the message.</param>
            <returns>A new byte array containing the MAC value.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsSuiteMac.CalculateMacConstantTime(System.Int64,System.Int16,System.Byte[],System.Int32,System.Int32,System.Int32,System.Byte[])">
            <summary>Constant time calculation of the MAC for some given data with a given expected length.</summary>
            <param name="seqNo">The sequence number of the record.</param>
            <param name="type">The content type of the message.</param>
            <param name="message">A byte array containing the message.</param>
            <param name="offset">The number of bytes to skip, before the message starts.</param>
            <param name="length">The length of the message.</param>
            <param name="expectedLength">The expected length of the full message.</param>
            <param name="randomData">Random data for padding out the MAC calculation if required.</param>
            <returns>A new byte array containing the MAC value.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Srp6Group">
            <summary>Carrier class for SRP-6 group parameters.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Srp6Group.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>Base constructor.</summary>
            <param name="n">the n value.</param>
            <param name="g">the g value.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Srp6StandardGroups">
            <summary>A selection of standard groups for SRP-6.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Tls13Verifier.Stream">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Tls13Verifier.VerifySignature(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsAgreement">
            <summary>Base interface for ephemeral key agreement calculator.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsAgreement.GenerateEphemeral">
            <summary>Generate an ephemeral key pair, returning the encoding of the public key.</summary>
            <returns>a byte encoding of the public key.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsAgreement.ReceivePeerValue(System.Byte[])">
            <summary>Pass in the public key for the peer to the agreement calculator.</summary>
            <param name="peerValue">a byte encoding of the peer public key.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsAgreement.CalculateSecret">
            <summary>Calculate the agreed secret based on the calculator's current state.</summary>
            <returns>the calculated secret.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate">
            <summary>Interface providing the functional representation of a single X.509 certificate.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate.CreateEncryptor(System.Int32)">
            <summary>Return an encryptor based on the public key in this certificate.</summary>
            <param name="tlsCertificateRole"><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificateRole"/></param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsEncryptor"/> based on this certificate's public key.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate.CreateVerifier(System.Int16)">
            <param name="signatureAlgorithm"><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAlgorithm"/></param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate.CreateVerifier(System.Int32)">
            <param name="signatureScheme"><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureScheme"/></param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate.GetEncoded">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate.GetExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate.SigAlgOid">
            <returns>the OID of this certificate's 'signatureAlgorithm', as a string.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate.GetSigAlgParams">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate.GetLegacySignatureAlgorithm">
            <returns><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAlgorithm"/></returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate.SupportsSignatureAlgorithm(System.Int16)">
            <param name="signatureAlgorithm"><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAlgorithm"/></param>
            <returns>true if (and only if) this certificate can be used to verify the given signature algorithm.
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate.SupportsSignatureAlgorithmCA(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate.CheckUsageInRole(System.Int32)">
            <param name="tlsCertificateRole"><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificateRole"/></param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCipher">
            <summary>Base interface for a TLS bulk cipher.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCipher.GetCiphertextDecodeLimit(System.Int32)">
            <summary>Return the maximum input size for a ciphertext given a maximum output size for the plaintext of
            plaintextLimit bytes.</summary>
            <param name="plaintextLimit">the maximum output size for the plaintext.</param>
            <returns>the maximum input size of the ciphertext for plaintextlimit bytes of output.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCipher.GetCiphertextEncodeLimit(System.Int32,System.Int32)">
            <summary>Return the maximum output size for a ciphertext given an actual input plaintext size of
            plaintextLength bytes and a maximum input plaintext size of plaintextLimit bytes.</summary>
            <param name="plaintextLength">the actual input size for the plaintext.</param>
            <param name="plaintextLimit">the maximum input size for the plaintext.</param>
            <returns>the maximum output size of the ciphertext for plaintextlimit bytes of input.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCipher.GetPlaintextLimit(System.Int32)">
            <summary>Return the maximum size for the plaintext given ciphertextlimit bytes of ciphertext.</summary>
            <param name="ciphertextLimit">the maximum number of bytes of ciphertext.</param>
            <returns>the maximum size of the plaintext for ciphertextlimit bytes of input.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCipher.EncodePlaintext(System.Int64,System.Int16,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Encode the passed in plaintext using the current bulk cipher.</summary>
            <param name="seqNo">sequence number of the message represented by plaintext.</param>
            <param name="contentType">content type of the message represented by plaintext.</param>
            <param name="recordVersion"><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion"/> used for the record.</param>
            <param name="headerAllocation">extra bytes to allocate at start of returned byte array.</param>
            <param name="plaintext">array holding input plaintext to the cipher.</param>
            <param name="offset">offset into input array the plaintext starts at.</param>
            <param name="len">length of the plaintext in the array.</param>
            <returns>A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsEncodeResult"/> containing the result of encoding (after 'headerAllocation' unused
            bytes).</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCipher.DecodeCiphertext(System.Int64,System.Int16,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion,System.Byte[],System.Int32,System.Int32)">
            <summary>Decode the passed in ciphertext using the current bulk cipher.</summary>
            <param name="seqNo">sequence number of the message represented by ciphertext.</param>
            <param name="recordType">content type used in the record for this message.</param>
            <param name="recordVersion"><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion"/> used for the record.</param>
            <param name="ciphertext">array holding input ciphertext to the cipher.</param>
            <param name="offset">offset into input array the ciphertext starts at.</param>
            <param name="len">length of the ciphertext in the array.</param>
            <returns>A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsDecodeResult"/> containing the result of decoding.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCipher.RekeyDecoder">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCipher.RekeyEncoder">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto">
            <summary>Service and object creation interface for the primitive types and services that are associated with
            cryptography in the API.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasAnyStreamVerifiers(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm})">
            <summary>Return true if this TlsCrypto would use a stream verifier for any of the passed in algorithms.
            </summary>
            <remarks>This method is only relevant to handshakes negotiating (D)TLS 1.2.</remarks>
            <param name="signatureAndHashAlgorithms">A <see cref="T:System.Collections.Generic.IList`1">list</see> of
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm"/> values.</param>
            <returns>true if this instance would use a stream verifier for any of the passed in algorithms, otherwise
            false.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasAnyStreamVerifiersLegacy(System.Int16[])">
            <summary>Return true if this TlsCrypto would use a stream verifier for any of the passed in algorithms.
            </summary>
            <remarks>This method is only relevant to handshakes negotiating (D)TLS versions older than 1.2.</remarks>
            <param name="clientCertificateTypes">An array of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ClientCertificateType"/> values.</param>
            <returns>true if this instance would use a stream verifier for any of the passed in algorithms, otherwise
            false.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasCryptoHashAlgorithm(System.Int32)">
            <summary>Return true if this TlsCrypto can support the passed in hash algorithm.</summary>
            <param name="cryptoHashAlgorithm">the algorithm of interest.</param>
            <returns>true if cryptoHashAlgorithm is supported, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasCryptoSignatureAlgorithm(System.Int32)">
            <summary>Return true if this TlsCrypto can support the passed in signature algorithm (not necessarily in
            combination with EVERY hash algorithm).</summary>
            <param name="cryptoSignatureAlgorithm">the algorithm of interest.</param>
            <returns>true if cryptoSignatureAlgorithm is supported, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasDHAgreement">
            <summary>Return true if this TlsCrypto can support DH key agreement.</summary>
            <returns>true if this instance can support DH key agreement, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasECDHAgreement">
            <summary>Return true if this TlsCrypto can support ECDH key agreement.</summary>
            <returns>true if this instance can support ECDH key agreement, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasEncryptionAlgorithm(System.Int32)">
            <summary>Return true if this TlsCrypto can support the passed in block/stream encryption algorithm.
            </summary>
            <param name="encryptionAlgorithm">the algorithm of interest.</param>
            <returns>true if encryptionAlgorithm is supported, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasHkdfAlgorithm(System.Int32)">
            <summary>Return true if this TlsCrypto can support HKDF with the passed in hash algorithm.</summary>
            <param name="cryptoHashAlgorithm">the algorithm of interest.</param>
            <returns>true if HKDF is supported with cryptoHashAlgorithm, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasMacAlgorithm(System.Int32)">
            <summary>Return true if this TlsCrypto can support the passed in MAC algorithm.</summary>
            <param name="macAlgorithm">the algorithm of interest.</param>
            <returns>true if macAlgorithm is supported, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasNamedGroup(System.Int32)">
            <summary>Return true if this TlsCrypto supports the passed in <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.NamedGroup">named group</see>
            value.</summary>
            <returns>true if this instance supports the passed in <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.NamedGroup">named group</see> value.
            </returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasRsaEncryption">
            <summary>Return true if this TlsCrypto can support RSA encryption/decryption.</summary>
            <returns>true if this instance can support RSA encryption/decryption, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasSignatureAlgorithm(System.Int16)">
            <summary>Return true if this TlsCrypto can support the passed in signature algorithm (not necessarily in
            combination with EVERY hash algorithm).</summary>
            <returns>true if signatureAlgorithm is supported, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasSignatureAndHashAlgorithm(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm)">
            <summary>Return true if this TlsCrypto can support the passed in signature algorithm.</summary>
            <param name="sigAndHashAlgorithm">the algorithm of interest.</param>
            <returns>true if sigAndHashAlgorithm is supported, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasSignatureScheme(System.Int32)">
            <summary>Return true if this TlsCrypto can support the passed in signature scheme.</summary>
            <param name="signatureScheme">the scheme of interest.</param>
            <returns>true if signatureScheme is supported, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasSrpAuthentication">
            <summary>Return true if this TlsCrypto can support SRP authentication.</summary>
            <returns>true if this instance can support SRP authentication, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateSecret(System.Byte[])">
            <summary>Create a TlsSecret object based on provided data.</summary>
            <param name="data">the data to base the TlsSecret on.</param>
            <returns>a TlsSecret based on the provided data.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.GenerateRsaPreMasterSecret(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion)">
            <summary>Create a TlsSecret object containing a randomly-generated RSA PreMasterSecret</summary>
            <param name="clientVersion">the client version to place in the first 2 bytes</param>
            <returns>a TlsSecret containing the PreMasterSecret.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.SecureRandom">
            <summary>Return the primary (safest) SecureRandom for this crypto.</summary>
            <returns>a SecureRandom suitable for key generation.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateCertificate(System.Byte[])">
            <summary>Create a TlsCertificate from an ASN.1 binary encoding of an X.509 certificate.</summary>
            <param name="encoding">DER/BER encoding of the certificate of interest.</param>
            <returns>a TlsCertificate.</returns>
            <exception cref="T:System.IO.IOException">if there is an issue on decoding or constructing the certificate.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateCertificate(System.Int16,System.Byte[])">
            <summary>Create a TlsCertificate from an ASN.1 binary encoding of a certificate.</summary>
            <param name="type">Certificate type as per IANA TLS Certificate Types registry.</param>
            <param name="encoding">DER/BER encoding of the certificate of interest.</param>
            <returns>a TlsCertificate.</returns>
            <exception cref="T:System.IO.IOException">if there is an issue on decoding or constructing the certificate.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateCipher(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters,System.Int32,System.Int32)">
            <summary>Create a cipher for the specified encryption and MAC algorithms.</summary>
            <remarks>
            See enumeration classes <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.EncryptionAlgorithm"/>, <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.MacAlgorithm"/> for appropriate
            argument values.
            </remarks>
            <param name="cryptoParams">context specific parameters.</param>
            <param name="encryptionAlgorithm">the encryption algorithm to be employed by the cipher.</param>
            <param name="macAlgorithm">the MAC algorithm to be employed by the cipher.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCipher"/> implementing the encryption and MAC algorithms.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateDHDomain(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsDHConfig)">
            <summary>Create a domain object supporting the domain parameters described in dhConfig.</summary>
            <param name="dhConfig">the config describing the DH parameters to use.</param>
            <returns>a TlsDHDomain supporting the parameters in dhConfig.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateECDomain(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsECConfig)">
            <summary>Create a domain object supporting the domain parameters described in ecConfig.</summary>
            <param name="ecConfig">the config describing the EC parameters to use.</param>
            <returns>a TlsECDomain supporting the parameters in ecConfig.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.AdoptSecret(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret)">
            <summary>Adopt the passed in secret, creating a new copy of it.</summary>
            <param name="secret">the secret to make a copy of.</param>
            <returns>a TlsSecret based on the original secret.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateHash(System.Int32)">
            <summary>Create a suitable hash for the hash algorithm identifier passed in.</summary>
            <remarks>
            See enumeration class <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.CryptoHashAlgorithm"/> for appropriate argument values.
            </remarks>
            <param name="cryptoHashAlgorithm">the hash algorithm the hash needs to implement.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHash"/>.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateHmac(System.Int32)">
            <summary>Create a suitable HMAC for the MAC algorithm identifier passed in.</summary>
            <remarks>
            See enumeration class <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.MacAlgorithm"/> for appropriate argument values.
            </remarks>
            <param name="macAlgorithm">the MAC algorithm the HMAC needs to match.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHmac"/>.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateHmacForHash(System.Int32)">
            <summary>Create a suitable HMAC using the hash algorithm identifier passed in.</summary>
            <remarks>
            See enumeration class <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.CryptoHashAlgorithm"/> for appropriate argument values.
            </remarks>
            <param name="cryptoHashAlgorithm">the hash algorithm the HMAC should use.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHmac"/>.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateNonceGenerator(System.Byte[])">
            <summary>Create a nonce generator.</summary>
            <remarks>
            Each call should construct a new generator, and the generator should be returned from this call only after
            automatically seeding from this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto"/>'s entropy source, and from the provided additional
            seed material. The output of each returned generator must be completely independent of the others.
            </remarks>
            <param name="additionalSeedMaterial">context-specific seed material</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsNonceGenerator"/>.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateSrp6Client(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSrpConfig)">
            <summary>Create an SRP-6 client.</summary>
            <param name="srpConfig">client config.</param>
            <returns>an initialised SRP6 client object.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateSrp6Server(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSrpConfig,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>Create an SRP-6 server.</summary>
            <param name="srpConfig">server config.</param>
            <param name="srpVerifier">the SRP6 verifier value.</param>
            <returns>an initialised SRP6 server object.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateSrp6VerifierGenerator(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSrpConfig)">
            <summary>Create an SRP-6 verifier generator.</summary>
            <param name="srpConfig">generator config.</param>
            <returns>an initialized SRP6 verifier generator.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto.HkdfInit(System.Int32)">
            <summary>Setup an initial "secret" for a chain of HKDF calls (RFC 5869), containing a string of HashLen
            zeroes.</summary>
            <param name="cryptoHashAlgorithm">the hash algorithm to instantiate HMAC with. See
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.CryptoHashAlgorithm"/> for values.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCryptoException">
            <summary>Basic exception class for crypto services to pass back a cause.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters">
            <summary>Carrier class for context-related parameters needed for creating secrets and ciphers.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext)">
            <summary>Base constructor.</summary>
            <param name="context">the context for this parameters object.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCryptoUtilities.HkdfExpandLabel(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret,System.Int32,System.String,System.Byte[],System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCryptoUtilities.HkdfExpandLabel(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret,System.Int32,System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsDHConfig">
            <summary>Basic config for Diffie-Hellman.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsDHDomain">
            <summary>Domain interface to service factory for creating Diffie-Hellman operators.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsDHDomain.CreateDH">
            <summary>Return an agreement operator suitable for ephemeral Diffie-Hellman.</summary>
            <returns>a key agreement operator.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsECConfig">
            <summary>Carrier class for Elliptic Curve parameter configuration.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsECConfig.NamedGroup">
            <summary>Return the group used.</summary>
            <returns>the <see cref="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsECConfig.NamedGroup">named group</see> used.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsECDomain">
            <summary>Domain interface to service factory for creating Elliptic-Curve (EC) based operators.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsECDomain.CreateECDH">
            <summary>Return an agreement operator suitable for ephemeral EC Diffie-Hellman.</summary>
            <returns>a key agreement operator.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsEncryptor">
            <summary>Base interface for an encryptor.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsEncryptor.Encrypt(System.Byte[],System.Int32,System.Int32)">
            <summary>Encrypt data from the passed in input array.</summary>
            <param name="input">byte array containing the input data.</param>
            <param name="inOff">offset into input where the data starts.</param>
            <param name="length">the length of the data to encrypt.</param>
            <returns>the encrypted data.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHash">
            <summary>Interface for message digest, or hash, services.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHash.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>Update the hash with the passed in input.</summary>
            <param name="input">input array containing the data.</param>
            <param name="inOff">offset into the input array the input starts at.</param>
            <param name="length">the length of the input data.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHash.CalculateHash">
            <summary>Return calculated hash for any input passed in.</summary>
            <returns>the hash value.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHash.CloneHash">
            <summary>Return a clone of this hash object representing its current state.</summary>
            <returns>a clone of the current hash.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHash.Reset">
            <summary>Reset the hash underlying this service.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHmac">
            <summary>Interface for MAC services based on HMAC.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHmac.InternalBlockSize">
            <summary>Return the internal block size for the message digest underlying this HMAC service.</summary>
            <returns>the internal block size for the digest (in bytes).</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsMac">
            <summary>Interface for MAC services.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsMac.SetKey(System.Byte[],System.Int32,System.Int32)">
            <summary>Set the key to be used by the MAC implementation supporting this service.</summary>
            <param name="key">array holding the MAC key.</param>
            <param name="keyOff">offset into the array the key starts at.</param>
            <param name="keyLen">length of the key in the array.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsMac.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>Update the MAC with the passed in input.</summary>
            <param name="input">input array containing the data.</param>
            <param name="inOff">offset into the input array the input starts at.</param>
            <param name="length">the length of the input data.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsMac.CalculateMac">
            <summary>Return calculated MAC for any input passed in.</summary>
            <returns>the MAC value.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsMac.CalculateMac(System.Byte[],System.Int32)">
            <summary>Write the calculated MAC to an output buffer.</summary>
            <param name="output">output array to write the MAC to.</param>
            <param name="outOff">offset into the output array to write the MAC to.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsMac.MacLength">
            <summary>Return the length of the MAC generated by this service.</summary>
            <returns>the MAC length.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsMac.Reset">
            <summary>Reset the MAC underlying this service.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsNonceGenerator.GenerateNonce(System.Int32)">
            <summary>Generate a nonce byte[] string.</summary>
            <param name="size">the length, in bytes, of the nonce to generate.</param>
            <returns>the nonce value.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsNullNullCipher">
            <summary>The cipher for TLS_NULL_WITH_NULL_NULL.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret">
            <summary>Interface supporting the generation of key material and other SSL/TLS secret values from PRFs.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret.CalculateHmac(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Calculate an HMAC with this secret's data as the key.</summary>
            <param name="cryptoHashAlgorithm">the hash algorithm to instantiate HMAC with. See
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.CryptoHashAlgorithm"/> for values.</param>
            <param name="buf">array containing the input data.</param>
            <param name="off">offset into the input array the input starts at.</param>
            <param name="len">the length of the input data.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret.DeriveUsingPrf(System.Int32,System.String,System.Byte[],System.Int32)">
            <summary>Return a new secret based on applying a PRF to this one.</summary>
            <param name="prfAlgorithm">PRF algorithm to use.</param>
            <param name="label">the label details.</param>
            <param name="seed">the seed details.</param>
            <param name="length">the size (in bytes) of the secret to generate.</param>
            <returns>the new secret.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret.Destroy">
            <summary>Destroy the internal state of the secret.</summary>
            <remarks>
            After this call, any attempt to use the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret"/> will result in an
            <see cref="T:System.InvalidOperationException"/> being thrown.
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret.Encrypt(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsEncryptor)">
            <summary>Return an encrypted copy of the data this secret is based on.</summary>
            <param name="encryptor">the encryptor to use for protecting the internal data.</param>
            <returns>an encrypted copy of this secret's internal data.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret.Extract">
            <summary>Return the internal data from this secret.</summary>
            <remarks>
            The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret"/> does not keep a copy of the data. After this call, any attempt to use the
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret"/> will result in an <see cref="T:System.InvalidOperationException"/> being thrown.
            </remarks>
            <returns>the secret's internal data.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret.HkdfExpand(System.Int32,System.Byte[],System.Int32)">
            <summary>RFC 5869 HKDF-Expand function, with this secret's data as the pseudo-random key ('prk').</summary>
            <param name="cryptoHashAlgorithm">the hash algorithm to instantiate HMAC with. See
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.CryptoHashAlgorithm"/> for values.</param>
            <param name="info">optional context and application specific information (can be zero-length).</param>
            <param name="length">length of output keying material in octets.</param>
            <returns> output keying material (of 'length' octets).</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret.HkdfExtract(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret)">
            <summary>RFC 5869 HKDF-Extract function, with this secret's data as the 'salt'.</summary>
            <remarks>
            The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret"/> does not keep a copy of the data. After this call, any attempt to use
            the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSecret"/> will result in an <see cref="T:System.InvalidOperationException"/> being thrown.
            </remarks>
            <param name="cryptoHashAlgorithm">the hash algorithm to instantiate HMAC with. See
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.CryptoHashAlgorithm"/> for values.</param>
            <param name="ikm">input keying material.</param>
            <returns>a pseudo-random key (of HashLen octets).</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSigner">
            <summary>Base interface for a TLS signer that works on raw message digests.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSigner.GenerateRawSignature(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm,System.Byte[])">
            <summary>Generate an encoded signature based on the passed in hash.</summary>
            <param name="algorithm">the signature algorithm to use.</param>
            <param name="hash">the hash calculated for the signature.</param>
            <returns>an encoded signature.</returns>
            <exception cref="T:System.IO.IOException">in case of an exception processing the hash.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSigner.GetStreamSigner(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSrp6Client">
            <summary>Basic interface for an SRP-6 client implementation.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSrp6Client.CalculateSecret(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>Generates the secret S given the server's credentials</summary>
            <param name="serverB">The server's credentials</param>
            <returns>Client's verification message for the server</returns>
            <exception cref="T:System.IO.IOException">If server's credentials are invalid</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSrp6Client.GenerateClientCredentials(System.Byte[],System.Byte[],System.Byte[])">
            <summary>Generates client's credentials given the client's salt, identity and password</summary>
            <param name="salt">The salt used in the client's verifier.</param>
            <param name="identity">The user's identity (eg. username)</param>
            <param name="password">The user's password</param>
            <returns>Client's public value to send to server</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSrp6Server">
            <summary>Basic interface for an SRP-6 server implementation.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSrp6Server.GenerateServerCredentials">
            <summary>Generates the server's credentials that are to be sent to the client.</summary>
            <returns>The server's public value to the client</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSrp6Server.CalculateSecret(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>Processes the client's credentials. If valid the shared secret is generated and returned.
            </summary>
            <param name="clientA">The client's credentials.</param>
            <returns>A shared secret <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger"/>.</returns>
            <exception cref="T:System.IO.IOException">If client's credentials are invalid.</exception>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSrp6VerifierGenerator">
            <summary>Base interface for a generator for SRP-6 verifiers.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSrp6VerifierGenerator.GenerateVerifier(System.Byte[],System.Byte[],System.Byte[])">
            <summary>Creates a new SRP-6 verifier value.</summary>
            <param name="salt">The salt to use, generally should be large and random</param>
            <param name="identity">The user's identifying information (eg. username)</param>
            <param name="password">The user's password</param>
            <returns>A new verifier for use in future SRP authentication</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSrpConfig">
            <summary>Basic config for SRP.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSrpConfig.GetExplicitNG">
            <summary>Return the (N, g) values used in SRP-6.</summary>
            <returns>(N, g) as a BigInteger array (N=[0], g=[1]).</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSrpConfig.SetExplicitNG(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger[])">
            <summary>Set the (N, g) values used for SRP-6.</summary>
            <param name="explicitNG">(N, g) as a BigInteger array (N=[0], g=[1]).</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsStreamSigner.Stream">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsStreamSigner.GetSignature">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsStreamVerifier.Stream">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsStreamVerifier.IsVerified">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsVerifier">
            <summary>Base interface for a TLS verifier that works with signatures and either raw message digests, or entire
            messages.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsVerifier.GetStreamVerifier(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DigitallySigned)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsVerifier.VerifyRawSignature(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DigitallySigned,System.Byte[])">
            <summary>Return true if the passed in signature and hash represent a real signature.</summary>
            <param name="digitallySigned">the signature object containing the signature to be verified.</param>
            <param name="hash">the hash calculated for the signature.</param>
            <returns>true if signature verifies, false otherwise.</returns>
            <exception cref="T:System.IO.IOException">in case of an exception verifying signature.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DatagramReceiver.GetReceiveLimit">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DatagramReceiver.Receive(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DatagramReceiver.Receive(System.Span{System.Byte},System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DatagramSender.GetSendLimit">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DatagramSender.Send(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DatagramSender.Send(System.ReadOnlySpan{System.Byte})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DatagramTransport">
            <summary>Base interface for an object sending and receiving DTLS data.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DefaultTlsCredentialedSigner">
            <summary>Container class for generating signatures that carries the signature type, parameters, public key
            certificate and public key's associated signer object.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DefaultTlsDHGroupVerifier.#ctor">
            <summary>Accept named groups and various standard DH groups with 'P' at least
            <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DefaultTlsDHGroupVerifier.DefaultMinimumPrimeBits"/> bits.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DefaultTlsDHGroupVerifier.#ctor(System.Int32)">
            <summary>Accept named groups and various standard DH groups with 'P' at least the specified number of bits.
            </summary>
            <param name="minimumPrimeBits">the minimum bitlength of 'P'.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DefaultTlsDHGroupVerifier.#ctor(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.DHGroup},System.Int32)">
            <summary>Accept named groups and a custom set of group parameters, subject to a minimum bitlength for 'P'.
            </summary>
            <param name="groups">a <see cref="T:System.Collections.Generic.IList`1">list</see> of acceptable <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.DHGroup"/>s.</param>
            <param name="minimumPrimeBits">the minimum bitlength of 'P'.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DefaultTlsServer.GetDsaSignerCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DefaultTlsServer.GetECDsaSignerCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DefaultTlsServer.GetRsaEncryptionCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DefaultTlsServer.GetRsaSignerCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DefaultTlsSrpConfigVerifier.#ctor">
            <summary>Accept only the group parameters specified in RFC 5054 Appendix A.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DefaultTlsSrpConfigVerifier.#ctor(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Srp6Group})">
            <summary>Specify a custom set of acceptable group parameters.</summary>
            <param name="groups">an <see cref="T:System.Collections.Generic.IList`1"/> of acceptable <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Srp6Group"/>.</param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DeferredHash">
            <summary>Buffers input until the hash algorithm is determined.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DeferredHash.CopyBufferTo(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DigestInputBuffer.CopyInputTo(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DigitallySigned.Algorithm">
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm"/> (or null before TLS 1.2).</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DigitallySigned.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DigitallySigned"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DigitallySigned.Parse(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DigitallySigned"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="context">the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DigitallySigned"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.Connect(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DatagramTransport)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshake(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.GenerateCertificateVerify(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DigitallySigned)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.GenerateClientHello(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.GenerateClientKeyExchange(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ProcessCertificateRequest(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ProcessCertificateStatus(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ProcessHelloVerifyRequest(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ProcessNewSessionTicket(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ProcessServerCertificate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ProcessServerHello(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ProcessServerKeyExchange(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ProcessServerSupplementalData(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ReportServerVersion(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsClientProtocol.PatchClientHelloWithCookie(System.Byte[],System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsEpoch.AllocateSequenceNumber">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsHandshakeRetransmit.ReceivedHandshakeRecord(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsProtocol.ProcessFinished(System.Byte[],System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsProtocol.ApplyMaxFragmentLengthExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsProtocol.EvaluateMaxFragmentLengthExtension(System.Boolean,System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsProtocol.GenerateCertificate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsProtocol.GenerateSupplementalData(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SupplementalDataEntry})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsProtocol.SendCertificateMessage(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsProtocol.ValidateSelectedCipherSuite(System.Int32,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.ReceiveClientHelloRecord(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.SendHelloVerifyRequestRecord(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DatagramSender,System.Int64,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.SendDatagram(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DatagramSender,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.GetReceiveLimit">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.GetSendLimit">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.Receive(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.Receive(System.Span{System.Byte},System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.Send(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.Send(System.ReadOnlySpan{System.Byte})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.Warn(System.Int16,System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.RaiseAlert(System.Int16,System.Int16,System.String,System.Exception)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.ReceiveDatagram(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.ProcessRecord(System.Int32,System.Byte[],System.Span{System.Byte})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.ReceiveRecord(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.SendHeartbeatMessage(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HeartbeatMessage)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer.SendRecord(System.Int16,System.ReadOnlySpan{System.Byte})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.ReadClientRequest(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.SendHelloVerifyRequest(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DatagramSender,System.Int64,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.SendMessage(System.Int16,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.ReceiveMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.ReceiveMessageBody(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.ReceiveMessageDelayedDigest(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.UpdateHandshakeMessagesDigest(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.Message)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.CheckInboundFlight">
            Check that there are no "extra" messages left in the current inbound flight
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.GetPendingMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.ImplReceiveMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.ProcessRecord(System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.ResendOutboundFlight">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.WriteMessage(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.Message)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.WriteHandshakeFragment(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReliableHandshake.Message,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReplayWindow">
            RFC 4347 4.1.2.5 Anti-replay
            <p>
            Support fast rejection of duplicate records by maintaining a sliding receive window
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReplayWindow.ShouldDiscard(System.Int64)">
            <summary>Check whether a received record with the given sequence number should be rejected as a duplicate.
            </summary>
            <param name="seq">the 48-bit DTLSPlainText.sequence_number field of a received record.</param>
            <returns>true if the record should be discarded without further processing.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsReplayWindow.ReportAuthenticated(System.Int64)">
            <summary>Report that a received record with the given sequence number passed authentication checks.
            </summary>
            <param name="seq">the 48-bit DTLSPlainText.sequence_number field of an authenticated record.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.Accept(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DatagramTransport)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.Accept(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DatagramTransport,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRequest)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshake(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRequest)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.GenerateCertificateRequest(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.GenerateCertificateStatus(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatus)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.GenerateNewSessionTicket(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.NewSessionTicket)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.GenerateServerHello(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsRecordLayer)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.NotifyClientCertificate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ProcessClientCertificate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ProcessCertificateVerify(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,System.Byte[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsHandshakeHash)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ProcessClientHello(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ProcessClientHello(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ClientHello)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ProcessClientKeyExchange(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ProcessClientSupplementalData(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsTransport.GetReceiveLimit">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsTransport.GetSendLimit">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsTransport.Receive(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsTransport.Receive(System.Span{System.Byte},System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsTransport.Send(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DtlsTransport.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ECCurveType">
            <summary>RFC 4492 5.4</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ECCurveType.explicit_prime">
            Indicates the elliptic curve domain parameters are conveyed verbosely, and the
            underlying finite field is a prime field.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ECCurveType.explicit_char2">
            Indicates the elliptic curve domain parameters are conveyed verbosely, and the
            underlying finite field is a characteristic-2 field.
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ECCurveType.named_curve">
            Indicates that a named curve is used. This option SHOULD be used when applicable.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ECPointFormat">
            <summary>RFC 4492 5.1.2</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.EncryptionAlgorithm">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to depend on the
            particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ExporterLabel">
            <summary>RFC 5705</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HandshakeMessageOutput.Send(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol,System.Int16,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HandshakeMessageOutput.#ctor(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HandshakeMessageOutput.#ctor(System.Int16,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HandshakeMessageOutput.Send(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HashAlgorithm">
            <summary>RFC 5246 7.4.1.4.1</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HeartbeatExtension.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HeartbeatExtension"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HeartbeatExtension.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HeartbeatExtension"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HeartbeatExtension"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HeartbeatMessage.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HeartbeatMessage"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HeartbeatMessage.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HeartbeatMessage"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HeartbeatMessage"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HeartbeatMessageType">
            <summary>RFC 6520 3.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.IdentifierType">
            <summary>RFC 6066</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.KeyExchangeAlgorithm">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to depend on the
            particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.KeyShareEntry.#ctor(System.Int32,System.Byte[])">
            <param name="namedGroup"><see cref="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.KeyShareEntry.NamedGroup"/></param>
            <param name="keyExchange"></param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.KeyShareEntry.NamedGroup">
            <returns><see cref="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.KeyShareEntry.NamedGroup"/></returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.KeyShareEntry.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.KeyShareEntry"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.KeyShareEntry.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.KeyShareEntry"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.KeyShareEntry"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.KeyUpdateRequest">
            <summary>RFC 8446 4.6.3</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.MacAlgorithm">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to depend on the
            particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.NamedGroup">
            <summary>RFC 7919</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.NamedGroupRole">
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to depend on the
            particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.NewSessionTicket.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.NewSessionTicket"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.NewSessionTicket.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.NewSessionTicket"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.NewSessionTicket"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OcspStatusRequest">
            <summary>RFC 3546 3.6</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OcspStatusRequest.#ctor(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.ResponderID},Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions)">
            <param name="responderIDList">an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.ResponderID"/>, specifying the list of
            trusted OCSP responders. An empty list has the special meaning that the responders are implicitly known to
            the server - e.g., by prior arrangement.</param>
            <param name="requestExtensions">OCSP request extensions. A null value means that there are no extensions.
            </param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OcspStatusRequest.ResponderIDList">
            <returns>an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Ocsp.ResponderID"/>.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OcspStatusRequest.RequestExtensions">
            <returns>OCSP request extensions.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OcspStatusRequest.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OcspStatusRequest"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OcspStatusRequest.Parse(System.IO.Stream)">
            <summary>Parse an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OcspStatusRequest"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OcspStatusRequest"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OfferedPsks.Encode(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OfferedPsks.EncodeBinders(System.IO.Stream,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsHandshakeHash,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OfferedPsks.BindersConfig)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OfferedPsks.GetBindersSize(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPsk[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OfferedPsks.Parse(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.PrfAlgorithm">
            <summary>RFC 5246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to depend on the
            particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolName">
            <summary>RFC 7301 Represents a protocol name for use with ALPN.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolName.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolName"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolName.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolName"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolName"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.PskTlsClient.GetAuthentication">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.PskTlsServer.GetRsaEncryptionCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream">
            <summary>An implementation of the TLS 1.0/1.1/1.2 record layer.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.NotifyChangeCipherSpecReceived">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.EnablePendingCipherRead(System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.EnablePendingCipherWrite">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.FinaliseHandshake">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.NotifyKeyUpdateReceived">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.NotifyKeyUpdateSent">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.PreviewRecordHeader(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.ReadFullRecord(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.ReadRecord">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.DecodeAndVerify(System.Int16,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.WriteRecord(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.WriteRecord(System.Int16,System.ReadOnlySpan{System.Byte})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.CheckChangeCipherSpec(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.CheckRecordType(System.Byte[],System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.CheckLength(System.Int32,System.Int32,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.Record.FillTo(System.IO.Stream,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.Record.ReadFragment(System.IO.Stream,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.Record.ReadHeader(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.RecordStream.SequenceNumber.NextValue(System.Int16)">
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsFatalAlert"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerHello.Encode(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerHello"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="context">the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerHello.Parse(System.IO.MemoryStream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerHello"/> from a <see cref="T:System.IO.MemoryStream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.MemoryStream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerHello"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerName">
            <summary>RFC 6066 3. Server Name Indication</summary>
            <remarks>
            Current implementation uses this guidance: "For backward compatibility, all future data structures associated
            with new NameTypes MUST begin with a 16-bit length field. TLS MAY treat provided server names as opaque data
            and pass the names and types to the application.". RFC 6066 specifies ASCII encoding for host_name (possibly
            using A-labels for IDNs), but note that the previous version (RFC 4366) specified UTF-8 encoding (see RFC 6066
            Appendix A). For maximum compatibility, it is recommended that client code tolerate receiving UTF-8 from the
            peer, but only generate ASCII itself.
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerName.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerName"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerName.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerName"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerName"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerNameList.#ctor(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerName})">
            <param name="serverNameList">an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerName"/>.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerNameList.ServerNames">
            <returns>an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerName"/>.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerNameList.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerNameList"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to .</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerNameList.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerNameList"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerNameList"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerSrpParams.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerSrpParams"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerSrpParams.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerSrpParams"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerSrpParams"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SessionParameters.Builder.SetServerExtensions(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SessionParameters.ReadServerExtensions">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAlgorithm">
            RFC 5246 7.4.1.4.1 (in RFC 2246, there were no specific values assigned)
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm">
            <summary>RFC 5246 7.4.1.4.1</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm.#ctor(System.Int16,System.Int16)">
            <param name="hash"><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HashAlgorithm"/></param>
            <param name="signature"><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAlgorithm"/></param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm.Hash">
            <returns><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HashAlgorithm"/></returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm.Signature">
            <returns><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAlgorithm"/></returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureScheme.GetNamedGroup(System.Int32)">
            For TLS 1.3+ usage, some signature schemes are constrained to use a particular
            ({@link NamedGroup}. Not relevant for TLS 1.2 and below.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SimulatedTlsSrpIdentityManager">
            <summary>An implementation of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpIdentityManager"/> that simulates the existence of "unknown"
            identities to obscure the fact that there is no verifier for them.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SimulatedTlsSrpIdentityManager.GetRfc5054Default(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Srp6Group,System.Byte[])">
            <summary>Create a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SimulatedTlsSrpIdentityManager"/> that implements the algorithm from RFC 5054
            2.5.1.3.</summary>
            <param name="crypto"><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCrypto"/></param>
            <param name="group">the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Srp6Group"/> defining the group that SRP is operating in.</param>
            <param name="seedKey">the secret "seed key" referred to in RFC 5054 2.5.1.3.</param>
            <returns>an instance of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SimulatedTlsSrpIdentityManager"/>.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SrpTlsClient.GetClientExtensions">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SrpTlsClient.ProcessServerExtensions(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SrpTlsClient.GetAuthentication">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SrpTlsServer.GetDsaSignerCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SrpTlsServer.GetRsaSignerCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Ssl3Utilities.ReadEncryptedPms(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Ssl3Utilities.WriteEncryptedPms(System.Byte[],System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SupplementalDataType">
            <summary>RFC 4680</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsAuthentication">
            <summary>Base interface to provide TLS authentication credentials.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsAuthentication.NotifyServerCertificate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerCertificate)">
            <summary>Called by the protocol handler to report the server certificate.</summary>
            <remarks>
            Note: this method is responsible for certificate verification and validation.
            </remarks>
            <param name="serverCertificate">the server certificate received.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsAuthentication.GetClientCredentials(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest)">
            <summary>Return client credentials in response to server's certificate request.</summary>
            <remarks>
            The returned value may be null, or else it MUST implement <em>exactly one</em> of
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentialedAgreement"/>, <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentialedDecryptor"/>, or
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentialedSigner"/>, depending on the key exchange that was negotiated and the details of
            the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest"/>.
            </remarks>
            <param name="certificateRequest">details of the certificate request.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentials"/> object or null for no client authentication.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.GetSessionToResume">
            <summary>Return the session this client wants to resume, if any.</summary>
            <remarks>
            Note that the peer's certificate chain for the session (if any) may need to be periodically revalidated.
            </remarks>
            <returns>A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSession"/> representing the resumable session to be used for this connection, or
            null to use a new session.</returns>
            <seealso cref="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SessionParameters.PeerCertificate"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.GetExternalPsks">
            <summary>Return the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPskExternal">external PSKs</see> to offer in the ClientHello.</summary>
            <remarks>This will only be called when TLS 1.3 or higher is amongst the offered protocol versions.</remarks>
            <returns>an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPskExternal"/> instances, or null if none should be
            offered.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.GetClientExtensions">
            <returns>(Int32 -> byte[])</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.GetEarlyKeyShareGroups">
            <summary>If this client is offering TLS 1.3 or higher, this method may be called to determine for which
            groups a key share should be included in the initial ClientHello.</summary>
            <remarks>
            Groups that were not included in the supported_groups extension (by <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.GetClientExtensions"/> will
            be ignored. The protocol will then add a suitable key_share extension to the ClientHello extensions.
            </remarks>
            <returns>an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.NamedGroup">named group</see> values, possibly empty or
            null.
            </returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.NotifyServerVersion(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.NotifySessionToResume(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSession)">
            <summary>Notifies the client of the session that will be offered in ClientHello for resumption, if any.
            </summary>
            <remarks>
            This will be either the session returned from {@link #getSessionToResume()} or null if that session was
            unusable. NOTE: the actual negotiated session_id is notified by <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.NotifySessionID(System.Byte[])"/>.
            </remarks>
            <param name="session">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSession"/> representing the resumable session to be offered for
            this connection, or null if there is none.</param>
            <seealso cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.NotifySessionID(System.Byte[])"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.NotifySessionID(System.Byte[])">
            <summary>Notifies the client of the session_id sent in the ServerHello.</summary>
            <param name="sessionID"/>
            <seealso cref="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext.Session"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.NotifySelectedPsk(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPsk)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.ProcessServerExtensions(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <summary>The protocol implementation validates that any server extensions received correspond to client
            extensions sent.</summary>
            <remarks>
            If further processing of the server extensions is needed, it can be done in this callback. NOTE: This is
            not called for session resumption handshakes.
            </remarks>
            <param name="serverExtensions">(Int32 -> byte[])</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.ProcessServerSupplementalData(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SupplementalDataEntry})">
            <param name="serverSupplementalData">(SupplementalDataEntry)</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.GetPskIdentity">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.GetSrpIdentity">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.GetDHGroupVerifier">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.GetSrpConfigVerifier">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.GetAuthentication">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.GetClientSupplementalData">
            <returns>(SupplementalDataEntry)</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient.NotifyNewSessionTicket(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.NewSessionTicket)">
            <summary>RFC 5077 3.3. NewSessionTicket Handshake Message</summary>
            <remarks>
            This method will be called (only) when a NewSessionTicket handshake message is received. The ticket is
            opaque to the client and clients MUST NOT examine the ticket under the assumption that it complies with e.g.
            RFC 5077 4. "Recommended Ticket Construction".
            </remarks>
            <param name="newSessionTicket">The ticket.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientContext">
            <summary>Marker interface to distinguish a TLS client context.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.#ctor">
            <summary>Constructor for non-blocking mode.</summary>
            <remarks>
            When data is received, use <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.OfferInput(System.Byte[])"/> to provide the received ciphertext,
            then use <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ReadInput(System.Byte[],System.Int32,System.Int32)"/> to read the corresponding cleartext.<br/><br/>
            Similarly, when data needs to be sent, use <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.WriteApplicationData(System.Byte[],System.Int32,System.Int32)"/>
            to provide the cleartext, then use <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ReadOutput(System.Byte[],System.Int32,System.Int32)"/> to get the
            corresponding ciphertext.
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.#ctor(System.IO.Stream)">
            <summary>Constructor for blocking mode.</summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> of data to/from the server.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.#ctor(System.IO.Stream,System.IO.Stream)">
            <summary>Constructor for blocking mode.</summary>
            <param name="input">The <see cref="T:System.IO.Stream"/> of data from the server.</param>
            <param name="output">The <see cref="T:System.IO.Stream"/> of data to the server.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.Connect(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient)">
            <summary>Initiates a TLS handshake in the role of client.</summary>
            <remarks>
            In blocking mode, this will not return until the handshake is complete. In non-blocking mode, use
            <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.NotifyHandshakeComplete"/> to receive a callback when the handshake is complete.
            </remarks>
            <param name="tlsClient">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient"/> to use for the handshake.</param>
            <exception cref="T:System.IO.IOException">If in blocking mode and handshake was not successful.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.Handle13HandshakeMessage(System.Int16,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HandshakeMessageInput)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.HandleServerCertificate">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.HandleSupplementalData(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SupplementalDataEntry})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.Process13HelloRetryRequest(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerHello)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.Process13ServerHello(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerHello,System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.Process13ServerHelloCoda(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerHello,System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.ProcessServerHello(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerHello)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.Receive13CertificateRequest(System.IO.MemoryStream,System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.Receive13EncryptedExtensions(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.Receive13NewSessionTicket(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.Receive13ServerCertificate(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.Receive13ServerCertificateVerify(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.Receive13ServerFinished(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.ReceiveCertificateRequest(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.ReceiveNewSessionTicket(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.ReceiveServerHelloMessage(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.Send13ClientHelloRetry">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.SendCertificateVerifyMessage(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DigitallySigned)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.SendClientHello">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.SendClientHelloMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.SendClientKeyExchange">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.Skip13CertificateRequest">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientProtocol.Skip13ServerCertificate">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCloseable.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext">
            <summary>Base interface for a TLS context implementation.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext.IsServer">
            <summary>Return true if this context is for a server, false otherwise.</summary>
            <returns>true for a server based context, false for a client based one.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext.ResumableSession">
            <summary>Used to get the resumable session, if any, used by this connection.</summary>
            <remarks>
            Only available after the handshake has successfully completed.
            </remarks>
            <returns>A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSession"/> representing the resumable session used by this connection, or null if
            no resumable session available.</returns>
            <seealso cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.NotifyHandshakeComplete"/>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext.Session">
            <summary>Used to get the session information for this connection.</summary>
            <remarks>
            Only available after the handshake has successfully completed. Use <see cref="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSession.IsResumable"/>
            to find out if the session is resumable.
            </remarks>
            <returns>A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSession"/> representing the session used by this connection.</returns>
            <seealso cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.NotifyHandshakeComplete"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext.ExportChannelBinding(System.Int32)">
            <summary>Export the value of the specified channel binding.</summary>
            <remarks>
            Only available after the handshake has successfully completed.
            </remarks>
            <param name="channelBinding">A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ChannelBinding"/> constant specifying the channel binding to
            export.</param>
            <returns>A copy of the channel binding data as a <c>byte[]</c>, or null if the binding could not be
            determined.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext.ExportEarlyKeyingMaterial(System.String,System.Byte[],System.Int32)">
            <summary>Export (early data) keying material according to RFC 5705: "Keying Material Exporters for TLS", as
            updated for TLS 1.3 (RFC 8446).</summary>
            <remarks>
            NOTE: for use in settings where an exporter is needed for 0-RTT data.
            </remarks>
            <param name="asciiLabel">indicates which application will use the exported keys.</param>
            <param name="context_value">allows the application using the exporter to mix its own data with the TLS PRF
            for the exporter output.</param>
            <param name="length">the number of bytes to generate.</param>
            <returns>a pseudorandom bit string of 'length' bytes generated from the (exporter_)master_secret.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext.ExportKeyingMaterial(System.String,System.Byte[],System.Int32)">
            <summary>Export keying material according to RFC 5705: "Keying Material Exporters for TLS", as updated for
            TLS 1.3 (RFC 8446) when negotiated.</summary>
            <param name="asciiLabel">indicates which application will use the exported keys.</param>
            <param name="context_value">allows the application using the exporter to mix its own data with the TLS PRF
            for the exporter output.</param>
            <param name="length">the number of bytes to generate.</param>
            <returns>a pseudorandom bit string of 'length' bytes generated from the (exporter_)master_secret.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentialedAgreement">
            <summary>Support interface for generating a secret based on the credentials sent by a TLS peer.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentialedAgreement.GenerateAgreement(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate)">
            <summary>Calculate an agreed secret based on our credentials and the public key credentials of our peer.
            </summary>
            <param name="peerCertificate">public key certificate of our TLS peer.</param>
            <returns>the agreed secret.</returns>
            <exception cref="T:System.IO.IOException">in case of an exception on generation of the secret.</exception>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentialedDecryptor">
            <summary>Base interface for a class that decrypts TLS secrets.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentialedDecryptor.Decrypt(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters,System.Byte[])">
            <summary>Decrypt the passed in cipher text using the parameters available.</summary>
            <param name="cryptoParams">the parameters to use for the decryption.</param>
            <param name="ciphertext">the cipher text containing the secret.</param>
            <returns>a TLS secret.</returns>
            <exception cref="T:System.IO.IOException">on a parsing or decryption error.</exception>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentialedSigner">
            <summary>Support interface for generating a signature based on our private credentials.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentialedSigner.GenerateRawSignature(System.Byte[])">
            <summary>Generate a signature against the passed in hash.</summary>
            <param name="hash">a message digest calculated across the message the signature is to apply to.</param>
            <returns>an encoded signature.</returns>
            <exception cref="T:System.IO.IOException">if the hash cannot be processed, or there is an issue with the private
            credentials.</exception>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentialedSigner.SignatureAndHashAlgorithm">
            <summary>Return the algorithm IDs for the signature algorithm and the associated hash it uses.</summary>
            <returns>the full algorithm details for the signature.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentialedSigner.GetStreamSigner">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentials">
            <summary>Base interface for interfaces/classes carrying TLS credentials.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentials.Certificate">
            <summary>Return the certificate structure representing our identity.</summary>
            <returns>our certificate structure.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsDHanonKeyExchange">
            <summary>(D)TLS DH_anon key exchange.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsDHGroupVerifier">
            <summary>Interface for verifying explicit Diffie-Hellman group parameters.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsDHGroupVerifier.Accept(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.DHGroup)">
            <summary>Check whether the given DH group is acceptable for use.</summary>
            <param name="dhGroup">the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.DHGroup"/> to check.</param>
            <returns>true if (and only if) the specified group is acceptable.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsDHKeyExchange">
            <summary>(D)TLS DH key exchange.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsDHUtilities.ReceiveDHConfig(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsDHGroupVerifier,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsDHUtilities.ReadDHParameter(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsDHUtilities.WriteDHConfig(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsDHConfig,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsDHUtilities.WriteDHParameter(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsEccUtilities.CreateNamedECConfig(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsEccUtilities.CheckPointEncoding(System.Int32,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsEccUtilities.ReceiveECDHConfig(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsEccUtilities.WriteECConfig(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsECConfig,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsEccUtilities.WriteNamedECParameters(System.Int32,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsECDHanonKeyExchange">
            <summary>(D)TLS ECDH_anon key exchange (see RFC 4492).</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsECDheKeyExchange">
            <summary>(D)TLS ECDHE key exchange (see RFC 4492).</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsECDHKeyExchange">
            <summary>(D)TLS ECDH key exchange (see RFC 4492).</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddAlpnExtensionClient(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolName})">
            <param name="extensions">(Int32 -> byte[])</param>
            <param name="protocolNameList">an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolName"/>.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddAlpnExtensionServer(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolName)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddCertificateAuthoritiesExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddClientCertificateTypeExtensionClient(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int16[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddClientCertificateTypeExtensionServer(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddCompressCertificateExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddCookieExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddEarlyDataMaxSize(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int64)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddHeartbeatExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HeartbeatExtension)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddKeyShareClientHello(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.KeyShareEntry})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddKeyShareHelloRetryRequest(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddKeyShareServerHello(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.KeyShareEntry)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddMaxFragmentLengthExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddOidFiltersExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Collections.Generic.IDictionary{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddPaddingExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddPreSharedKeyClientHello(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OfferedPsks)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddPreSharedKeyServerHello(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddPskKeyExchangeModesExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int16[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddRecordSizeLimitExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddServerCertificateTypeExtensionClient(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int16[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddServerCertificateTypeExtensionServer(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddServerNameExtensionClient(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerName})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddServerNameExtensionServer(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddSignatureAlgorithmsExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddSignatureAlgorithmsCertExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddStatusRequestExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequest)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddStatusRequestV2Extension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequestItemV2})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddSupportedGroupsExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Collections.Generic.IList{System.Int32})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddSupportedPointFormatsExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int16[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddSupportedVersionsExtensionClient(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddSupportedVersionsExtensionServer(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddTrustedCAKeysExtensionClient(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TrustedAuthority})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetAlpnExtensionClient(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <returns>an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolName"/>.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetAlpnExtensionServer(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetCertificateAuthoritiesExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetClientCertificateTypeExtensionClient(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetClientCertificateTypeExtensionServer(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetCompressCertificateExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetCookieExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetEarlyDataMaxSize(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetHeartbeatExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetKeyShareClientHello(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetKeyShareHelloRetryRequest(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetKeyShareServerHello(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetMaxFragmentLengthExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetOidFiltersExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetPaddingExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetPreSharedKeyClientHello(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetPreSharedKeyServerHello(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetPskKeyExchangeModesExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetRecordSizeLimitExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetServerCertificateTypeExtensionClient(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetServerCertificateTypeExtensionServer(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetServerNameExtensionClient(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetSignatureAlgorithmsExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetSignatureAlgorithmsCertExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetStatusRequestExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetStatusRequestV2Extension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetSupportedGroupsExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetSupportedPointFormatsExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetSupportedVersionsExtensionClient(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetSupportedVersionsExtensionServer(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetTrustedCAKeysExtensionClient(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.HasClientCertificateUrlExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.HasEarlyDataIndication(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.HasEncryptThenMacExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.HasExtendedMasterSecretExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.HasServerNameExtensionServer(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.HasPostHandshakeAuthExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.HasTruncatedHmacExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.HasTrustedCAKeysExtensionServer(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateAlpnExtensionClient(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolName})">
            <param name="protocolNameList">an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolName"/>.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateAlpnExtensionServer(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolName)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateCertificateAuthoritiesExtension(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateCertificateTypeExtensionClient(System.Int16[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateCertificateTypeExtensionServer(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateCompressCertificateExtension(System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateCookieExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateEarlyDataMaxSize(System.Int64)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateHeartbeatExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HeartbeatExtension)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateKeyShareClientHello(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.KeyShareEntry})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateKeyShareHelloRetryRequest(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateKeyShareServerHello(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.KeyShareEntry)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateMaxFragmentLengthExtension(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateOidFiltersExtension(System.Collections.Generic.IDictionary{Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreatePaddingExtension(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreatePreSharedKeyClientHello(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OfferedPsks)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreatePreSharedKeyServerHello(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreatePskKeyExchangeModesExtension(System.Int16[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateRecordSizeLimitExtension(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateServerNameExtensionClient(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerName})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateSignatureAlgorithmsExtension(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateSignatureAlgorithmsCertExtension(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateStatusRequestExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequest)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateStatusRequestV2Extension(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatusRequestItemV2})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateSupportedGroupsExtension(System.Collections.Generic.IList{System.Int32})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateSupportedPointFormatsExtension(System.Int16[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateSupportedVersionsExtensionClient(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateSupportedVersionsExtensionServer(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateTrustedCAKeysExtensionClient(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TrustedAuthority})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadEmptyExtensionData(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadAlpnExtensionClient(System.Byte[])">
            <returns>an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolName"/>.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadAlpnExtensionServer(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadCertificateAuthoritiesExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadCertificateTypeExtensionClient(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadCertificateTypeExtensionServer(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadClientCertificateUrlExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadCompressCertificateExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadCookieExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadEarlyDataIndication(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadEarlyDataMaxSize(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadEncryptThenMacExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadExtendedMasterSecretExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadHeartbeatExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadKeyShareClientHello(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadKeyShareHelloRetryRequest(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadKeyShareServerHello(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadMaxFragmentLengthExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadOidFiltersExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadPaddingExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadPostHandshakeAuthExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadPreSharedKeyClientHello(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadPreSharedKeyServerHello(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadPskKeyExchangeModesExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadRecordSizeLimitExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadServerNameExtensionClient(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadServerNameExtensionServer(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadSignatureAlgorithmsExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadSignatureAlgorithmsCertExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadStatusRequestExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadStatusRequestV2Extension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadSupportedGroupsExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadSupportedPointFormatsExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadSupportedVersionsExtensionClient(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadSupportedVersionsExtensionServer(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadTruncatedHmacExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadTrustedCAKeysExtensionClient(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadTrustedCAKeysExtensionServer(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsExtensionsUtilities.PatchOpaque16(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsHandshakeHash">
            <summary>Base interface for an object that can calculate a handshake hash.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsHandshakeHash.CopyBufferTo(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchange">
            <summary>A generic interface for key exchange implementations in (D)TLS.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchange.SkipServerCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchange.ProcessServerCredentials(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentials)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchange.ProcessServerCertificate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchange.GenerateServerKeyExchange">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchange.SkipServerKeyExchange">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchange.ProcessServerKeyExchange(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchange.SkipClientCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchange.ProcessClientCredentials(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentials)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchange.ProcessClientCertificate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchange.GenerateClientKeyExchange(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchange.ProcessClientKeyExchange(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchange.GeneratePreMasterSecret">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchangeFactory">
            <summary>Interface for a key exchange factory offering a variety of specific algorithms.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateDHKeyExchange(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateDHanonKeyExchangeClient(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsDHGroupVerifier)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateDHanonKeyExchangeServer(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsDHConfig)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateDheKeyExchangeClient(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsDHGroupVerifier)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateDheKeyExchangeServer(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsDHConfig)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateECDHKeyExchange(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateECDHanonKeyExchangeClient(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateECDHanonKeyExchangeServer(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsECConfig)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateECDheKeyExchangeClient(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateECDheKeyExchangeServer(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsECConfig)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreatePskKeyExchangeClient(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPskIdentity,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsDHGroupVerifier)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreatePskKeyExchangeServer(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPskIdentityManager,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsDHConfig,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsECConfig)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateRsaKeyExchange(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateSrpKeyExchangeClient(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpIdentity,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpConfigVerifier)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateSrpKeyExchangeServer(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpLoginParameters)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsNoCloseNotifyException">
            <summary>This exception will be thrown (only) when the connection is closed by the peer without sending a
            <see cref="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription.close_notify">close_notify</see> warning alert.</summary>
            <remarks>
            If this happens, the TLS protocol cannot rule out truncation of the connection data (potentially
            malicious). It may be possible to check for truncation via some property of a higher level protocol
            built upon TLS, e.g.the Content-Length header for HTTPS.
            </remarks>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsObjectIdentifiers">
            <summary>Object Identifiers associated with TLS extensions.</summary>
        </member>
        <member name="F:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsObjectIdentifiers.id_pe_tlsfeature">
            <summary>RFC 7633</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer">
            <summary>Base interface for a (D)TLS endpoint.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.Cancel">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.NotifyHandshakeBeginning">
            <summary>Notifies the peer that a new handshake is about to begin.</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.GetHandshakeTimeoutMillis">
            <summary>Specify the timeout, in milliseconds, to use for the complete handshake process.</summary>
            <remarks>
            NOTE: Currently only respected by DTLS protocols. Negative values are not allowed. A timeout of zero means
            an infinite timeout (i.e.the handshake will never time out).
            </remarks>
            <returns>the handshake timeout, in milliseconds.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.RequiresCloseNotify">
            <remarks>
            This option is provided as a last resort for interoperability with TLS peers that fail to correctly send a
            close_notify alert at end of stream. Implementations SHOULD return true; caution is advised if returning
            false without a full understanding of the implications.
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.RequiresExtendedMasterSecret">
            <remarks>This implementation supports RFC 7627 and will always negotiate the extended_master_secret
            extension where possible. When connecting to a peer that does not offer/accept this extension, it is
            recommended to abort the handshake.This option is provided for interoperability with legacy peers, although
            some TLS features will be disabled in that case (see RFC 7627 5.4).
            </remarks>
            <returns><c>true</c> if the handshake should be aborted when the peer does not negotiate the
            extended_master_secret extension, or <c>false</c> to support legacy interoperability.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.ShouldUseExtendedPadding">
            <summary>See RFC 5246 6.2.3.2. Controls whether block cipher encryption may randomly add extra padding
            beyond the minimum.</summary>
            <remarks>
            Note that in configurations where this is known to be potential security risk this setting will be ignored
            (and extended padding disabled). Extra padding is always supported when decrypting received records.
            </remarks>
            <returns><c>true</c> if random extra padding should be added during block cipher encryption, or
            <c>false</c> to always use the minimum amount of required padding.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.ShouldUseGmtUnixTime">
            <summary> draft-mathewson-no-gmtunixtime-00 2. "If existing users of a TLS implementation may rely on
            gmt_unix_time containing the current time, we recommend that implementors MAY provide the ability to set
            gmt_unix_time as an option only, off by default.".</summary>
            <remarks>
            NOTE: For a server that has negotiated TLS 1.3 (or later), or a client that has offered TLS 1.3 (or later),
            this is not called and gmt_unix_time is not used.
            </remarks>
            <returns><c>true</c> if the current time should be used in the gmt_unix_time field of Random, or
            <c>false</c> if gmt_unix_time should contain a cryptographically random value.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.NotifySecureRenegotiation(System.Boolean)">
            <summary>RFC 5746 3.4/3.6. In case this is false, peers may want to terminate the handshake instead of
            continuing; see Section 4.1/4.3 for discussion.</summary>
            <remarks>
            NOTE: TLS 1.3 forbids renegotiation, so this is never called when TLS 1.3 (or later) was negotiated.
            </remarks>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.GetKeyExchangeFactory">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.NotifyAlertRaised(System.Int16,System.Int16,System.String,System.Exception)">
            <summary>This method will be called when an alert is raised by the protocol.</summary>
            <param name="alertLevel"><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertLevel"/></param>
            <param name="alertDescription"><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription"/></param>
            <param name="message">A human-readable message explaining what caused this alert. May be null.</param>
            <param name="cause">The <see cref="T:System.Exception"/> that caused this alert to be raised. May be null.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.NotifyAlertReceived(System.Int16,System.Int16)">
            <summary>This method will be called when an alert is received from the remote peer.</summary>
            <param name="alertLevel"><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertLevel"/></param>
            <param name="alertDescription"><see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.AlertDescription"/></param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.NotifyHandshakeComplete">
            <summary>Notifies the peer that the handshake has been successfully completed.</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.GetHeartbeat">
            <summary>Return a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsHeartbeat"/> instance that will control the generation of heartbeats
            locally (if permitted by the remote peer), or null to not generate heartbeats. Heartbeats are described in
            RFC 6520.</summary>
            <returns>an instance of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsHeartbeat"/>.</returns>
            <seealso cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DefaultTlsHeartbeat"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.GetHeartbeatPolicy">
            <summary>Return the heartbeat mode applicable to the remote peer. Heartbeats are described in RFC 6520.
            </summary>
            <remarks>
            See enumeration class <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HeartbeatMode"/> for appropriate return values.
            </remarks>
            <returns>the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HeartbeatMode"/> value.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.IgnoreCorruptDtlsRecords">
            <summary>Indicates whether a DTLS connection should ignore corrupt records (bad_record_mac) instead of
            failing the connection.</summary>
            <remarks>Called only once at the start of a connection and applies throughout.</remarks>
            <returns>The value <c>true</c> to ignore corrupt DTLS records, or <c>false</c> to fail the connection.
            </returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ResumeHandshake">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.CloseConnection">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.HandleAlertMessage(System.Int16,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.HandleAlertWarningMessage(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.HandleChangeCipherSpecMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.HandleClose(System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.HandleException(System.Int16,System.String,System.Exception)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.HandleFailure">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.HandleHandshakeMessage(System.Int16,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HandshakeMessageInput)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ApplyMaxFragmentLengthExtension(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.CheckReceivedChangeCipherSpec(System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.BlockForHandshake">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.BeginHandshake(System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.CompleteHandshake">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ProcessRecord(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ProcessHandshakeQueue(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ByteQueue)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ProcessAlertQueue">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ProcessChangeCipherSpec(System.Byte[],System.Int32,System.Int32)">
            <summary>This method is called, when a change cipher spec message is received.</summary>
            <exception cref="T:System.IO.IOException">If the message has an invalid content or the handshake is not in the correct
            state.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ReadApplicationData(System.Byte[],System.Int32,System.Int32)">
            <summary>Read data from the network.</summary>
            <remarks>
            The method will return immediately, if there is still some data left in the buffer, or block until some
            application data has been read from the network.
            </remarks>
            <param name="buffer">The buffer where the data will be copied to.</param>
            <param name="offset">The position where the data will be placed in the buffer.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:System.IO.IOException">If something goes wrong during reading data.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.SafePreviewRecordHeader(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.SafeReadRecord">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.SafeReadFullRecord(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.SafeWriteRecord(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.SafeWriteRecord(System.Int16,System.ReadOnlySpan{System.Byte})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.WriteApplicationData(System.Byte[],System.Int32,System.Int32)">
            <summary>Write some application data.</summary>
            <remarks>
            Fragmentation is handled internally. Usable in both blocking/non-blocking modes.<br/><br/>
            In blocking mode, the output will be automatically sent via the underlying transport. In non-blocking mode,
            call <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ReadOutput(System.Byte[],System.Int32,System.Int32)"/> to get the output bytes to send to the peer.<br/><br/>
            This method must not be called until after the initial handshake is complete. Attempting to call it earlier
            will result in an <see cref="T:System.InvalidOperationException"/>.
            </remarks>
            <param name="buffer">The buffer containing application data to send.</param>
            <param name="offset">The offset at which the application data begins</param>
            <param name="count">The number of bytes of application data.</param>
            <exception cref="T:System.InvalidOperationException">If called before the initial handshake has completed.
            </exception>
            <exception cref="T:System.IO.IOException">If connection is already closed, or for encryption or transport errors.
            </exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.WriteHandshakeMessage(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.Stream">
            <summary>The secure bidirectional stream for this connection</summary>
            <remarks>Only allowed in blocking mode.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.CloseInput">
            <summary>Should be called in non-blocking mode when the input data reaches EOF.</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.PreviewInputRecord(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.PreviewOutputRecord(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.OfferInput(System.Byte[])">
            <summary>Equivalent to <code>OfferInput(input, 0, input.Length)</code>.</summary>
            <param name="input">The input buffer to offer.</param>
            <exception cref="T:System.IO.IOException"/>
            <seealso cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.OfferInput(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.OfferInput(System.Byte[],System.Int32,System.Int32)">
            <summary>Offer input from an arbitrary source.</summary>
            <remarks>Only allowed in non-blocking mode.<br/><br/>
            This method will decrypt and process all records that are fully available. If only part of a record is
            available, the buffer will be retained until the remainder of the record is offered.<br/><br/>
            If any records containing application data were processed, the decrypted data can be obtained using
            <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ReadInput(System.Byte[],System.Int32,System.Int32)"/>. If any records containing protocol data were processed, a
            response may have been generated. You should always check to see if there is any available output after
            calling this method by calling <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.GetAvailableOutputBytes"/>.
            </remarks>
            <param name="input">The input buffer to offer.</param>
            <param name="inputOff">The offset within the input buffer that input begins.</param>
            <param name="inputLen">The number of bytes of input being offered.</param>
            <exception cref="T:System.IO.IOException">If an error occurs while decrypting or processing a record.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.GetAvailableInputBytes">
            <summary>Gets the amount of received application data.</summary>
            <remarks>A call to <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ReadInput(System.Byte[],System.Int32,System.Int32)"/> is guaranteed to be able to return at least
            this much data.<br/><br/>
            Only allowed in non-blocking mode.
            </remarks>
            <returns>The number of bytes of available application data.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ReadInput(System.Byte[],System.Int32,System.Int32)">
            <summary>Retrieves received application data.</summary>
            <remarks>
            Use <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.GetAvailableInputBytes"/> to check how much application data is currently available. This
            method functions similarly to <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/>, except that it never blocks. If
            no data is available, nothing will be copied and zero will be returned.<br/><br/>
            Only allowed in non-blocking mode.
            </remarks>
            <param name="buf">The buffer to hold the application data.</param>
            <param name="off">The start offset in the buffer at which the data is written.</param>
            <param name="len">The maximum number of bytes to read.</param>
            <returns>The total number of bytes copied to the buffer. May be less than the length specified if the
            length was greater than the amount of available data.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.GetAvailableOutputBytes">
            <summary>Gets the amount of encrypted data available to be sent.</summary>
            <remarks>
            A call to <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ReadOutput(System.Byte[],System.Int32,System.Int32)"/> is guaranteed to be able to return at least this much
            data. Only allowed in non-blocking mode.
            </remarks>
            <returns>The number of bytes of available encrypted data.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ReadOutput(System.Byte[],System.Int32,System.Int32)">
            <summary>Retrieves encrypted data to be sent.</summary>
            <remarks>
            Use <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.GetAvailableOutputBytes"/> to check how much encrypted data is currently available. This
            method functions similarly to <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/>, except that it never blocks. If
            no data is available, nothing will be copied and zero will be returned. Only allowed in non-blocking mode.
            </remarks>
            <param name="buffer">The buffer to hold the encrypted data.</param>
            <param name="offset">The start offset in the buffer at which the data is written.</param>
            <param name="length">The maximum number of bytes to read.</param>
            <returns>The total number of bytes copied to the buffer. May be less than the length specified if the
            length was greater than the amount of available data.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ProcessFinishedMessage(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.Process13FinishedMessage(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.RaiseAlertFatal(System.Int16,System.String,System.Exception)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.RaiseAlertWarning(System.Int16,System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.Receive13KeyUpdate(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.SendCertificateMessage(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.Send13CertificateMessage(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.Send13CertificateVerifyMessage(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DigitallySigned)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.SendChangeCipherSpec">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.SendChangeCipherSpecMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.SendFinishedMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.Send13FinishedMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.Send13KeyUpdate(System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.SendSupplementalDataMessage(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SupplementalDataEntry})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ProcessMaxFragmentLengthExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.RefuseRenegotiation">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.AssertEmpty(System.IO.MemoryStream)">
            <summary>Make sure the <see cref="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.Stream"/> 'buf' is now empty. Fail otherwise.</summary>
            <param name="buf">The <see cref="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.Stream"/> to check.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.CreateRenegotiationInfo(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.EstablishMasterSecret(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsKeyExchange)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ReadExtensions(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ReadExtensionsData(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ReadExtensionsData13(System.Int32,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ReadExtensionsDataClientHello(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ReadSupplementalDataMessage(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.WriteExtensions(System.IO.Stream,System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.WriteExtensions(System.IO.Stream,System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.WriteExtensionsData(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.WriteExtensionsData(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.WriteExtensionsData(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.WriteExtensionsData(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.IO.MemoryStream,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.WritePreSharedKeyExtension(System.IO.MemoryStream,System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.WriteSelectedExtensions(System.IO.Stream,System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.WriteSupplementalData(System.IO.Stream,System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SupplementalDataEntry})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPskIdentity">
            <summary>Processor interface for a PSK identity.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPskIdentityManager">
            <summary>Base interface for an object that can process a PSK identity.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPskKeyExchange">
            <summary>(D)TLS PSK key exchange (RFC 4279).</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsRsaKeyExchange">
            <summary>(D)TLS RSA key exchange.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer">
            <summary>Interface describing a TLS server endpoint.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetSessionToResume(System.Byte[])">
            <summary>Return the specified session, if available.</summary>
            <remarks>
            Note that the peer's certificate chain for the session (if any) may need to be periodically revalidated.
            </remarks>
            <param name="sessionID">the ID of the session to resume.</param>
            <returns>A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSession"/> with the specified session ID, or null.</returns>
            <seealso cref="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SessionParameters.PeerCertificate"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetExternalPsk(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.PskIdentity})">
            <summary>Return the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPskExternal">external PSK</see> to select from the ClientHello.</summary>
            <remarks>
            WARNING: EXPERIMENTAL FEATURE, UNSTABLE API
            Note that this will only be called when TLS 1.3 or higher is amongst the offered protocol versions, and one
            or more PSKs are actually offered.
            </remarks>
            <param name="identities">an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.PskIdentity"/> instances.</param>
            <returns>The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPskExternal"/> corresponding to the selected identity, or null to not select
            any.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.NotifyClientVersion(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.NotifyFallback(System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.NotifyOfferedCipherSuites(System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.ProcessClientExtensions(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <param name="clientExtensions">(Int32 -> byte[])</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetServerVersion">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetSupportedGroups">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetSelectedCipherSuite">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetServerExtensions">
            <returns>(Int32 -> byte[])</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetServerExtensionsForConnection(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <param name="serverExtensions">(Int32 -> byte[])</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetServerSupplementalData">
            <returns>(SupplementalDataEntry)</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetCredentials">
            <summary>Return server credentials to use.</summary>
            <remarks>
            The returned value may be null, or else it MUST implement <em>exactly one</em> of
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentialedAgreement"/>, <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentialedDecryptor"/>, or
            <see cref = "T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentialedSigner"/>, depending on the key exchange that was negotiated.
            </remarks>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentials"/> object or null for anonymous key exchanges.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetCertificateStatus">
            <remarks>
            This method will be called (only) if the server included an extension of type "status_request" with empty
            "extension_data" in the extended server hello. See <i>RFC 3546 3.6. Certificate Status Request</i>. If a
            non-null <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatus"/> is returned, it is sent to the client as a handshake message of
            type "certificate_status".
            </remarks>
            <returns>A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatus"/> to be sent to the client (or null for none).</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetCertificateRequest">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetPskIdentityManager">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetSrpLoginParameters">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetDHConfig">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetECDHConfig">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.ProcessClientSupplementalData(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SupplementalDataEntry})">
            <param name="clientSupplementalData">(SupplementalDataEntry)</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.NotifyClientCertificate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate)">
            <summary>Called by the protocol handler to report the client certificate, only if
            <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetCertificateRequest"/> returned non-null.</summary>
            <remarks>
            Note: this method is responsible for certificate verification and validation.
            </remarks>
            <param name="clientCertificate">the effective client certificate (may be an empty chain).</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer.GetNewSessionTicket">
            <summary>RFC 5077 3.3. NewSessionTicket Handshake Message.</summary>
            <remarks>
            This method will be called (only) if a NewSessionTicket extension was sent by the server. See <i>RFC 5077
            4. Recommended Ticket Construction</i> for recommended format and protection.
            </remarks>
            <returns>The ticket.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerCertificate">
            <summary>Server certificate carrier interface.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerContext">
            <summary>Marker interface to distinguish a TLS server context.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.#ctor">
            <summary>Constructor for non-blocking mode.</summary>
            <remarks>
            When data is received, use <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.OfferInput(System.Byte[])"/> to provide the received ciphertext,
            then use <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ReadInput(System.Byte[],System.Int32,System.Int32)"/> to read the corresponding cleartext.<br/><br/>
            Similarly, when data needs to be sent, use <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.WriteApplicationData(System.Byte[],System.Int32,System.Int32)"/>
            to provide the cleartext, then use <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsProtocol.ReadOutput(System.Byte[],System.Int32,System.Int32)"/> to get the
            corresponding ciphertext.
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.#ctor(System.IO.Stream)">
            <summary>Constructor for blocking mode.</summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> of data to/from the server.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.#ctor(System.IO.Stream,System.IO.Stream)">
            <summary>Constructor for blocking mode.</summary>
            <param name="input">The <see cref="T:System.IO.Stream"/> of data from the server.</param>
            <param name="output">The <see cref="T:System.IO.Stream"/> of data to the server.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.Accept(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer)">
            <summary>Receives a TLS handshake in the role of server.</summary>
            <remarks>
            In blocking mode, this will not return until the handshake is complete. In non-blocking mode, use
            <see cref="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPeer.NotifyHandshakeComplete"/> to receive a callback when the handshake is complete.
            </remarks>
            <param name="tlsServer">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer"/> to use for the handshake.</param>
            <exception cref="T:System.IO.IOException">If in blocking mode and handshake was not successful.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.Generate13HelloRetryRequest(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ClientHello)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.Generate13ServerHello(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ClientHello,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HandshakeMessageInput,System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.GenerateServerHello(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ClientHello,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HandshakeMessageInput)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.Handle13HandshakeMessage(System.Int16,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.HandshakeMessageInput)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.NotifyClientCertificate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.Receive13ClientCertificate(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.Receive13ClientCertificateVerify(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.Receive13ClientFinished(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.ReceiveCertificateMessage(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.ReceiveCertificateVerifyMessage(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.ReceiveClientHelloMessage(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.ReceiveClientKeyExchangeMessage(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.Send13EncryptedExtensionsMessage(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.Send13ServerHelloCoda(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerHello,System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.SendCertificateRequestMessage(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.SendCertificateStatusMessage(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateStatus)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.SendHelloRequestMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.SendNewSessionTicketMessage(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.NewSessionTicket)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.SendServerHelloDoneMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.SendServerHelloMessage(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ServerHello)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.SendServerKeyExchangeMessage(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.Skip13ClientCertificate">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerProtocol.Skip13ClientCertificateVerify">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSession">
            <summary>Base interface for a carrier object for a TLS session.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpConfigVerifier">
            <summary>Interface for verifying SRP config needs to conform to.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpConfigVerifier.Accept(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSrpConfig)">
            <summary>Check whether the given SRP configuration is acceptable for use.</summary>
            <param name="srpConfig">the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsSrpConfig"/> to check.</param>
            <returns>true if (and only if) the specified configuration is acceptable.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpIdentity">
            <summary>Processor interface for an SRP identity.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpIdentityManager">
            <summary>Base interface for an object that can return login parameters from an SRP identity.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpIdentityManager.GetLoginParameters(System.Byte[])">
            <summary>Lookup the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpLoginParameters"/> corresponding to the specified identity.</summary>
            <remarks>
            NOTE: To avoid "identity probing", unknown identities SHOULD be handled as recommended in RFC 5054 2.5.1.3.
            <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SimulatedTlsSrpIdentityManager"/> is provided for this purpose.
            </remarks>
            <param name="identity">the SRP identity sent by the connecting client.</param>
            <returns>the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpLoginParameters"/> for the specified identity, or else 'simulated' parameters
            if the identity is not recognized. A null value is also allowed, but not recommended.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpKeyExchange">
            <summary>(D)TLS SRP key exchange (RFC 5054).</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpUtilities.AddSrpExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpUtilities.GetSrpExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpUtilities.CreateSrpExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpUtilities.ReadSrpExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpUtilities.ReadSrpParameter(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrpUtilities.WriteSrpParameter(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrtpUtilities">
            <summary>RFC 5764 DTLS Extension to Establish Keys for SRTP.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrtpUtilities.AddUseSrtpExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.UseSrtpData)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrtpUtilities.GetUseSrtpExtension(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrtpUtilities.CreateUseSrtpExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.UseSrtpData)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsSrtpUtilities.ReadUseSrtpExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.RequireDerEncoding(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.EncodeSupportedSignatureAlgorithms(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm},System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.ParseSupportedSignatureAlgorithms(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.VerifySupportedSignatureAlgorithm(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm},Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.VerifySupportedSignatureAlgorithm(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm},Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.ContainsSignatureAlgorithm(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm},Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.CalculateEndPointHash(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.CalculateEndPointHash(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.Verify13CertificateVerifyClient(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerContext,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsHandshakeHash,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateVerify)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.Verify13CertificateVerifyServer(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientContext,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsHandshakeHash,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateVerify)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.Verify13CertificateVerify(System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm},System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsHandshakeHash,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateVerify)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.GenerateServerKeyExchangeSignature(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentialedSigner,System.Byte[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DigestInputBuffer)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.VerifyServerKeyExchangeSignature(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,System.IO.Stream,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate,System.Byte[],Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.DigestInputBuffer)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.IsAeadCipherSuite(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.IsBlockCipherSuite(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.IsStreamCipherSuite(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.IsValidCipherSuiteForSignatureAlgorithms(System.Int32,System.Collections.Generic.IList{System.Int16})">
            <returns>Whether a server can select the specified cipher suite given the available signature algorithms
            for ServerKeyExchange.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.ChooseSignatureAndHashAlgorithm(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm},System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.ChooseSignatureAndHashAlgorithm(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolVersion,System.Collections.Generic.IList{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SignatureAndHashAlgorithm},System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.CreateKeyExchangeClient(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.CreateKeyExchangeServer(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.InitKeyExchangeClient(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientContext,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.InitKeyExchangeServer(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServerContext,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsServer)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.CheckPeerSigAlgs(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCertificate[])">
            <summary>Check the signature algorithm for certificates in the peer's CertPath as specified in RFC 5246
            7.4.2, 7.4.4, 7.4.6 and similar rules for earlier TLS versions.</summary>
            <remarks>
            The supplied CertPath should include the trust anchor (its signature algorithm isn't checked, but in the
            general case checking a certificate requires the issuer certificate).
            </remarks>
            <exception cref="T:System.IO.IOException">if any certificate in the CertPath (excepting the trust anchor) has a
            signature algorithm that is not one of the locally supported signature algorithms.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.RequireAgreementCredentials(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentials)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.RequireDecryptorCredentials(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentials)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.RequireSignerCredentials(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsCredentials)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.CheckClientCertificateType(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.CertificateRequest,System.Int16,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.CheckExtensionData13(System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int32,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.GenerateEncryptedPreMasterSecret(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsEncryptor,System.IO.Stream)">
            <summary>Generate a pre_master_secret and send it encrypted to the server.</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.AddPreSharedKeyToClientExtensions(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsPsk[],System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.AddPreSharedKeyToClientHello(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientContext,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient,System.Collections.Generic.IDictionary{System.Int32,System.Byte[]},System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.AddPreSharedKeyToClientHelloRetry(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClientContext,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.OfferedPsks.BindersConfig,System.Collections.Generic.IDictionary{System.Int32,System.Byte[]})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsUtilities.GetPskExternalsClient(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsClient,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TrustedAuthority.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TrustedAuthority"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TrustedAuthority.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TrustedAuthority"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TrustedAuthority"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.UrlAndHash">
            <summary>RFC 6066 5.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.UrlAndHash.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.UrlAndHash"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.UrlAndHash.Parse(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Parse a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.UrlAndHash"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="context">the <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.UrlAndHash"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.UserMappingType">
            <summary>RFC 4681</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.UseSrtpData">
            <summary>RFC 5764 4.1.1</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.UseSrtpData.#ctor(System.Int32[],System.Byte[])">
            <param name="protectionProfiles">see <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SrtpProtectionProfile"/> for valid constants.</param>
            <param name="mki">valid lengths from 0 to 255.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.UseSrtpData.ProtectionProfiles">
            <returns>see <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.SrtpProtectionProfile"/> for valid constants.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.UseSrtpData.Mki">
            <returns>valid lengths from 0 to 255.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampRequest">
            Base class for an RFC 3161 Time Stamp Request.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampRequest.#ctor(System.Byte[])">
             Create a TimeStampRequest from the past in byte array.
            
             @param req byte array containing the request.
             @throws IOException if the request is malformed.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampRequest.#ctor(System.IO.Stream)">
             Create a TimeStampRequest from the past in input stream.
            
             @param in input stream containing the request.
             @throws IOException if the request is malformed.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampRequest.Validate(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String})">
             Validate the timestamp request, checking the digest to see if it is of an
             accepted type and whether it is of the correct length for the algorithm specified.
            
             @param algorithms a set of string OIDS giving accepted algorithms.
             @param policies if non-null a set of policies we are willing to sign under.
             @param extensions if non-null a set of extensions we are willing to accept.
             @throws TspException if the request is invalid, or processing fails.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampRequest.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampRequestGenerator">
            Generator for RFC 3161 Time Stamp Request objects.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampRequestGenerator.AddExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            add a given extension field for the standard extensions tag (tag 3)
            @throws IOException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampRequestGenerator.AddExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,System.Byte[])">
            add a given extension field for the standard extensions tag
            The value parameter becomes the contents of the octet string associated
            with the extension.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampResponse">
            Base class for an RFC 3161 Time Stamp Response object.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampResponse.#ctor(System.Byte[])">
             Create a TimeStampResponse from a byte array containing an ASN.1 encoding.
            
             @param resp the byte array containing the encoded response.
             @throws TspException if the response is malformed.
             @throws IOException if the byte array doesn't represent an ASN.1 encoding.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampResponse.#ctor(System.IO.Stream)">
             Create a TimeStampResponse from an input stream containing an ASN.1 encoding.
            
             @param input the input stream containing the encoded response.
             @throws TspException if the response is malformed.
             @throws IOException if the stream doesn't represent an ASN.1 encoding.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampResponse.Validate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampRequest)">
             Check this response against to see if it a well formed response for
             the passed in request. Validation will include checking the time stamp
             token if the response status is GRANTED or GRANTED_WITH_MODS.
            
             @param request the request to be checked against
             @throws TspException if the request can not match this response.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampResponse.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampResponseGenerator">
            Generator for RFC 3161 Time Stamp Responses.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampResponseGenerator.Generate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampRequest,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.Nullable{System.DateTime})">
             Return an appropriate TimeStampResponse.
             <p>
             If genTime is null a timeNotAvailable error response will be returned.
            
             @param request the request this response is for.
             @param serialNumber serial number for the response token.
             @param genTime generation time for the response token.
             @param provider provider to use for signature calculation.
             @return
             @throws NoSuchAlgorithmException
             @throws NoSuchProviderException
             @throws TSPException
             </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampResponseGenerator.GenerateFailResponse(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cmp.PkiStatus,System.Int32,System.String)">
             Generate a TimeStampResponse with chosen status and FailInfoField.
            
             @param status the PKIStatus to set.
             @param failInfoField the FailInfoField to set.
             @param statusString an optional string describing the failure.
             @return a TimeStampResponse with a failInfoField and optional statusString
             @throws TSPException in case the response could not be created
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampToken.Validate(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate)">
            Validate the time stamp token.
            <p>
            To be valid the token must be signed by the passed in certificate and
            the certificate must be the one referred to by the SigningCertificate
            attribute included in the hashed attributes of the token. The
            certificate must also have the ExtendedKeyUsageExtension with only
            KeyPurposeID.IdKPTimeStamping and have been valid at the time the
            timestamp was created.
            </p>
            <p>
            A successful call to validate means all the above are true.
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampToken.ToCmsSignedData">
             Return the underlying CmsSignedData object.
            
             @return the underlying CMS structure.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampToken.GetEncoded">
             Return a ASN.1 encoded byte stream representing the encoded object.
            
             @throws IOException if encoding fails.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampToken.GetEncoded(System.String)">
             return the ASN.1 encoded representation of this object using the specified encoding.
            
             @param encoding the ASN.1 encoding format to use ("BER" or "DER").
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampTokenGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.String,System.String)">
            basic creation - only the default attributes will be included here.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampTokenGenerator.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,System.String,System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Cms.AttributeTable)">
            create with a signer with extra signed/unsigned attributes.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TimeStampTokenInfo.Nonce">
            @return the nonce value, null if there isn't one.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TspAlgorithms">
            Recognised hash algorithms for the time stamp protocol.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TspUtil.GetSignatureTimestamps(Best.HTTP.SecureProtocol.Org.BouncyCastle.Cms.SignerInformation)">
             Fetches the signature time-stamp attributes from a SignerInformation object.
             Checks that the MessageImprint for each time-stamp matches the signature field.
             (see RFC 3161 Appendix A).
            
             @param signerInfo a SignerInformation to search for time-stamps
             @return a collection of TimeStampToken objects
             @throws TSPValidationException
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TspUtil.ValidateCertificate(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate)">
             Validate the passed in certificate as being of the correct type to be used
             for time stamping. To be valid it must have an ExtendedKeyUsage extension
             which has a key purpose identifier of id-kp-timeStamping.
            
             @param cert the certificate of interest.
             @throws TspValidationException if the certicate fails on one of the check points.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TspUtil.GetDigestAlgName(System.String)">
            <summary>
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TspValidationException">
            Exception thrown if a TSP request or response fails to validate.
            <p>
            If a failure code is associated with the exception it can be retrieved using
            the getFailureCode() method.</p>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.Tsp.TspValidationException.FailureCode">
            <returns>The failure code associated with this exception, if one is set.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Arrays">
            <summary> General array utilities.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Arrays.AreEqual(System.Byte[],System.Byte[])">
            <summary>
            Are two arrays equal.
            </summary>
            <param name="a">Left side.</param>
            <param name="b">Right side.</param>
            <returns>True if equal.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Arrays.ConstantTimeAreEqual(System.Byte[],System.Byte[])">
            <summary>
            A constant time equals comparison - does not terminate early if
            test will fail.
            </summary>
            <param name="a">first array</param>
            <param name="b">second array</param>
            <returns>true if arrays equal, false otherwise.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Arrays.CopyOfRange(System.Byte[],System.Int32,System.Int32)">
             Make a copy of a range of bytes from the passed in data array. The range can
             extend beyond the end of the input array, in which case the return array will
             be padded with zeroes.
            
             @param data the array from which the data is to be copied.
             @param from the start index at which the copying should take place.
             @param to the final index of the range (exclusive).
            
             @return a new byte array containing the range given.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.BigIntegers">
            BigInteger utilities.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
             Return the passed in value as an unsigned byte array.
            
             @param value the value to be converted.
             @return a byte array without a leading zero byte if present in the signed encoding.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            Return the passed in value as an unsigned byte array of the specified length, padded with
            leading zeros as necessary.
            @param length the fixed length of the result.
            @param n the value to be converted.
            @return a byte array padded to a fixed length with leading zeros.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.Byte[],System.Int32,System.Int32)">
             Write the passed in value as unsigned bytes to the specified buffer range, padded with
             leading zeros as necessary.
            
             @param n
                        the value to be converted.
             @param buf
                        the buffer to which the value is written.
             @param off
                        the start offset in array <code>buf</code> at which the data is written.
             @param len
                        the fixed length of data written (possibly padded with leading zeros).
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.BigIntegers.CreateRandomBigInteger(System.Int32,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Creates a Random BigInteger from the secure random of a given bit length.
            </summary>
            <param name="bitLength"></param>
            <param name="secureRandom"></param>
            <returns></returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.BigIntegers.CreateRandomInRange(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.SecureRandom)">
            Return a random BigInteger not less than 'min' and not greater than 'max'
            
            @param min the least value that may be generated
            @param max the greatest value that may be generated
            @param random the source of randomness
            @return a random BigInteger value in the range [min,max]
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Bzip2.BZip2Constants">
             Base class for both the compress and decompress classes.
             Holds common arrays, and static data.
            
             @author <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Bzip2.CBZip2InputStream">
             An input stream that decompresses from the BZip2 format (with the file
             header chars) to be read as any other stream.
            
             @author <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
            
             <b>NB:</b> note this class has been modified to read the leading BZ from the
             start of the BZIP2 stream to make it compatible with other PGP programs.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Bzip2.CBZip2OutputStream">
             An output stream that compresses into the BZip2 format (with the file
             header chars) into another stream.
            
             @author <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
            
             TODO:    Update to BZip2 1.0.1
             <b>NB:</b> note this class has been modified to add a leading BZ to the
             start of the BZIP2 stream to make it compatible with other PGP programs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Bzip2.CBZip2OutputStream.WriteByte(System.Byte)">
            
             modified by Oliver Merkel, 010128
            
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Bzip2.CRC">
             A simple class the hold and calculate the CRC for sanity checking
             of the data.
            
             @author <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Collections.ISelector`1">
            <summary>Interface for matching objects in an <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Collections.IStore`1"/>.</summary>
            <typeparam name="T">The contravariant type of selectable objects.</typeparam>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Collections.ISelector`1.Match(`0)">
            <summary>Match the passed in object, returning true if it would be selected by this selector, false
            otherwise.</summary>
            <param name="candidate">The object to be matched.</param>
            <returns><code>true</code> if the objects is matched by this selector, false otherwise.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Collections.IStore`1">
            <summary>A generic interface describing a simple store of objects.</summary>
            <typeparam name="T">The covariant type of stored objects.</typeparam>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Collections.IStore`1.EnumerateMatches(Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Collections.ISelector{`0})">
            <summary>Enumerate the (possibly empty) collection of objects matched by the given selector.</summary>
            <param name="selector">The <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Collections.ISelector`1"/> used to select matching objects.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of the matching objects.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Date.DateTimeUtilities.DateTimeToUnixMs(System.DateTime)">
            <summary>
            Return the number of milliseconds since the Unix epoch (1 Jan., 1970 UTC) for a given DateTime value.
            </summary>
            <remarks>The DateTime value will be converted to UTC (using <see cref="M:System.DateTime.ToUniversalTime"/> before
            conversion.</remarks>
            <param name="dateTime">A DateTime value not before the epoch.</param>
            <returns>Number of whole milliseconds after epoch.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">'dateTime' is before the epoch.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Date.DateTimeUtilities.UnixMsToDateTime(System.Int64)">
            <summary>
            Create a UTC DateTime value from the number of milliseconds since the Unix epoch (1 Jan., 1970 UTC).
            </summary>
            <param name="unixMs">Number of milliseconds since the epoch.</param>
            <returns>A UTC DateTime value</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">'unixMs' is before 'MinUnixMs' or after 'MaxUnixMs'.
            </exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Date.DateTimeUtilities.CurrentUnixMs">
            <summary>
            Return the current number of milliseconds since the Unix epoch (1 Jan., 1970 UTC).
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[])">
             encode the input data producing a base 64 encoded byte array.
            
             @return a byte array containing the base 64 encoded data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.Int32,System.Int32)">
             encode the input data producing a base 64 encoded byte array.
            
             @return a byte array containing the base 64 encoded data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.IO.Stream)">
             Encode the byte data to base 64 writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             Encode the byte data to base 64 writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.Byte[])">
             decode the base 64 encoded input data. It is assumed the input data is valid.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.String)">
             decode the base 64 encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.String,System.IO.Stream)">
             decode the base 64 encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Base64Encoder.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             encode the input data producing a base 64 output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Base64Encoder.Decode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             decode the base 64 encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Base64Encoder.DecodeString(System.String,System.IO.Stream)">
             decode the base 64 encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.BufferedDecoder">
            <summary>
             A buffering class to allow translation from one format to another to
                be done in discrete chunks.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.BufferedDecoder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.ITranslator,System.Int32)">
            <summary>
            Create a buffered Decoder.
            </summary>
            <param name="translator">The translater to use.</param>
            <param name="bufferSize">The size of the buffer.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.BufferedDecoder.ProcessByte(System.Byte,System.Byte[],System.Int32)">
            <summary>
            Process one byte of data.
            </summary>
            <param name="input">Data in.</param>
            <param name="output">Byte array for the output.</param>
            <param name="outOff">The offset in the output byte array to start writing from.</param>
            <returns>The amount of output bytes.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.BufferedDecoder.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Process data from a byte array.
            </summary>
            <param name="input">The input data.</param>
            <param name="inOff">Start position within input data array.</param>
            <param name="len">Amount of data to process from input data array.</param>
            <param name="outBytes">Array to store output.</param>
            <param name="outOff">Position in output array to start writing from.</param>
            <returns>The amount of output bytes.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.BufferedEncoder">
            <summary>
            A class that allows encoding of data using a specific encoder to be processed in chunks.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.BufferedEncoder.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.ITranslator,System.Int32)">
            <summary>
            Create.
            </summary>
            <param name="translator">The translator to use.</param>
            <param name="bufferSize">Size of the chunks.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.BufferedEncoder.ProcessByte(System.Byte,System.Byte[],System.Int32)">
            <summary>
            Process one byte of data.
            </summary>
            <param name="input">The byte.</param>
            <param name="outBytes">An array to store output in.</param>
            <param name="outOff">Offset within output array to start writing from.</param>
            <returns></returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.BufferedEncoder.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Process data from a byte array.
            </summary>
            <param name="input">Input data Byte array containing data to be processed.</param>
            <param name="inOff">Start position within input data array.</param>
            <param name="len">Amount of input data to be processed.</param>
            <param name="outBytes">Output data array.</param>
            <param name="outOff">Offset within output data array to start writing to.</param>
            <returns>The amount of data written.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Hex">
            <summary>
            Class to decode and encode Hex.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[])">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32)">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.Byte[])">
             decode the Hex encoded input data. It is assumed the input data is valid.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String)">
             decode the Hex encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Hex.DecodeStrict(System.String)">
             Decode the hexadecimal-encoded string strictly i.e. any non-hexadecimal characters will be
             considered an error.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.Hex.DecodeStrict(System.String,System.Int32,System.Int32)">
             Decode the hexadecimal-encoded string strictly i.e. any non-hexadecimal characters will be
             considered an error.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.HexEncoder.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             encode the input data producing a Hex output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.HexEncoder.Decode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             decode the Hex encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.HexEncoder.DecodeString(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.HexTranslator">
            <summary>
            A hex translator.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.HexTranslator.GetEncodedBlockSize">
            <summary>
            Return encoded block size.
            </summary>
            <returns>2</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.HexTranslator.Encode(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encode some data.
            </summary>
            <param name="input">Input data array.</param>
            <param name="inOff">Start position within input data array.</param>
            <param name="length">The amount of data to process.</param>
            <param name="outBytes">The output data array.</param>
            <param name="outOff">The offset within the output data array to start writing from.</param>
            <returns>Amount of data encoded.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.HexTranslator.GetDecodedBlockSize">
            <summary>
            Returns the decoded block size.
            </summary>
            <returns>1</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.HexTranslator.Decode(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decode data from a byte array.
            </summary>
            <param name="input">The input data array.</param>
            <param name="inOff">Start position within input data array.</param>
            <param name="length">The amounty of data to process.</param>
            <param name="outBytes">The output data array.</param>
            <param name="outOff">The position within the output data array to start writing from.</param>
            <returns>The amount of data written.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.IEncoder">
            Encode and decode byte arrays (typically from binary to 7-bit ASCII
            encodings).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.ITranslator">
            <summary>
            Translator interface.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.UrlBase64">
            Convert binary data to and from UrlBase64 encoding.  This is identical to
            Base64 encoding, except that the padding character is "." and the other 
            non-alphanumeric characters are "-" and "_" instead of "+" and "/".
            <p>
            The purpose of UrlBase64 encoding is to provide a compact encoding of binary
            data that is safe for use as an URL parameter. Base64 encoding does not
            produce encoded values that are safe for use in URLs, since "/" can be 
            interpreted as a path delimiter; "+" is the encoded form of a space; and
            "=" is used to separate a name from the corresponding value in an URL 
            parameter.
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.UrlBase64.Encode(System.Byte[])">
             Encode the input data producing a URL safe base 64 encoded byte array.
            
             @return a byte array containing the URL safe base 64 encoded data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.UrlBase64.Encode(System.Byte[],System.IO.Stream)">
             Encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.UrlBase64.Decode(System.Byte[])">
             Decode the URL safe base 64 encoded input data - white space will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.UrlBase64.Decode(System.Byte[],System.IO.Stream)">
             decode the URL safe base 64 encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.UrlBase64.Decode(System.String)">
             decode the URL safe base 64 encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.UrlBase64.Decode(System.String,System.IO.Stream)">
             Decode the URL safe base 64 encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Encoders.UrlBase64Encoder">
            Convert binary data to and from UrlBase64 encoding.  This is identical to
            Base64 encoding, except that the padding character is "." and the other 
            non-alphanumeric characters are "-" and "_" instead of "+" and "/".
            <p>
            The purpose of UrlBase64 encoding is to provide a compact encoding of binary
            data that is safe for use as an URL parameter. Base64 encoding does not
            produce encoded values that are safe for use in URLs, since "/" can be 
            interpreted as a path delimiter; "+" is the encoded form of a space; and
            "=" is used to separate a name from the corresponding value in an URL 
            parameter.
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IEncodable.GetEncoded">
            <summary>Return a byte array representing the implementing object.</summary>
            <returns>An encoding of this object as a byte array.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IMemoable.Copy">
            <summary>
            Produce a copy of this object with its configuration and in its current state.
            </summary>
            <remarks>
            The returned object may be used simply to store the state, or may be used as a similar object
            starting from the copied state.
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IMemoable.Reset(Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IMemoable)">
            <summary>
            Restore a copied object state into this object.
            </summary>
            <remarks>
            Implementations of this method <em>should</em> try to avoid or minimise memory allocation to perform the reset.
            </remarks>
            <param name="other">an object originally {@link #copy() copied} from an object of the same type as this instance.</param>
            <exception cref="T:System.InvalidCastException">if the provided object is not of the correct type.</exception>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.MemoableResetException">if the <b>other</b> parameter is in some other way invalid.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemObjectGenerator.Generate">
            <returns>
            A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemObject"/>
            </returns>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemGenerationException"></exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemObjectParser.ParseObject(Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
            <param name="obj">
            A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemObject"/>
            </param>
            <returns>
            An <see cref="T:System.Object"/>
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemReader.ReadPemObject">
            <returns>
            A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemObject"/>
            </returns>
            <exception cref="T:System.IO.IOException"></exception>	
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemReader.seekColon(System.Int32)">
            <summary>
            Seek ':" up to the limit.
            </summary>
            <param name="upTo"></param>
            <returns></returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemReader.consumeDash">
            <summary>
            Consume the dashes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemReader.skipWhiteSpace">
            <summary>
            Skip white space leave char in stream.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemReader.expect(System.String)">
            <summary>
            Read forward consuming the expected string.
            </summary>
            <param name="value">expected string</param>
            <returns>false if not consumed</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemReader.bufferUntilStopChar(System.Char,System.Boolean)">
            <summary>
            Consume until dash.
            </summary>
            <returns>true if stream end not met</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemWriter">
            A generic PEM writer, based on RFC 1421
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemWriter.#ctor(System.IO.TextWriter)">
             Base constructor.
            
             @param out output stream to use.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemWriter.GetOutputSize(Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Return the number of bytes or characters required to contain the
             passed in object if it is PEM encoded.
            
             @param obj pem object to be output
             @return an estimate of the number of bytes
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Streams.PipeAll(System.IO.Stream,System.IO.Stream)">
            <summary>Write the full contents of inStr to the destination stream outStr.</summary>
            <param name="inStr">Source stream.</param>
            <param name="outStr">Destination stream.</param>
            <exception cref="T:System.IO.IOException">In case of IO failure.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Streams.PipeAll(System.IO.Stream,System.IO.Stream,System.Int32)">
            <summary>Write the full contents of inStr to the destination stream outStr.</summary>
            <param name="inStr">Source stream.</param>
            <param name="outStr">Destination stream.</param>
            <param name="bufferSize">The size of temporary buffer to use.</param>
            <exception cref="T:System.IO.IOException">In case of IO failure.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Streams.PipeAllLimited(System.IO.Stream,System.Int64,System.IO.Stream)">
            <summary>
            Pipe all bytes from <c>inStr</c> to <c>outStr</c>, throwing <c>StreamFlowException</c> if greater
            than <c>limit</c> bytes in <c>inStr</c>.
            </summary>
            <param name="inStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <param name="limit">
            A <see cref="T:System.Int64"/>
            </param>
            <param name="outStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <returns>The number of bytes actually transferred, if not greater than <c>limit</c></returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.IO.Streams.WriteBufTo(System.IO.MemoryStream,System.Byte[],System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.MemoableResetException">
            Exception to be thrown on a failure to reset an object implementing Memoable.
            <p>
            The exception extends InvalidCastException to enable users to have a single handling case,
            only introducing specific handling of this one if required.
            </p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Net.IPAddress.IsValid(System.String)">
             Validate the given IPv4 or IPv6 address.
            
             @param address the IP address as a string.
            
             @return true if a valid address, false otherwise
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Net.IPAddress.IsValidWithNetMask(System.String)">
             Validate the given IPv4 or IPv6 address and netmask.
            
             @param address the IP address as a string.
            
             @return true if a valid address with netmask, false otherwise
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Net.IPAddress.IsValidIPv4(System.String)">
             Validate the given IPv4 address.
             
             @param address the IP address as a string.
            
             @return true if a valid IPv4 address, false otherwise
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Net.IPAddress.IsValidIPv6(System.String)">
             Validate the given IPv6 address.
            
             @param address the IP address as a string.
            
             @return true if a valid IPv4 address, false otherwise
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Utilities.Strings">
            <summary> General string utilities.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.AttributeCertificateHolder">
            <remarks>
            The Holder object.
            <pre>
            Holder ::= SEQUENCE {
            	baseCertificateID   [0] IssuerSerial OPTIONAL,
            		-- the issuer and serial number of
            		-- the holder's Public Key Certificate
            	entityName          [1] GeneralNames OPTIONAL,
            		-- the name of the claimant or role
            	objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
            		-- used to directly authenticate the holder,
            		-- for example, an executable
            }
            </pre>
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.AttributeCertificateHolder.#ctor(System.Int32,System.String,System.String,System.Byte[])">
             Constructs a holder for v2 attribute certificates with a hash value for
             some type of object.
             <p>
             <code>digestedObjectType</code> can be one of the following:
             <ul>
             <li>0 - publicKey - A hash of the public key of the holder must be
             passed.</li>
             <li>1 - publicKeyCert - A hash of the public key certificate of the
             holder must be passed.</li>
             <li>2 - otherObjectDigest - A hash of some other object type must be
             passed. <code>otherObjectTypeID</code> must not be empty.</li>
             </ul>
             </p>
             <p>This cannot be used if a v1 attribute certificate is used.</p>
            
             @param digestedObjectType The digest object type.
             @param digestAlgorithm The algorithm identifier for the hash.
             @param otherObjectTypeID The object type ID if
                        <code>digestedObjectType</code> is
                        <code>otherObjectDigest</code>.
             @param objectDigest The hash value.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.AttributeCertificateHolder.DigestedObjectType">
             Returns the digest object type if an object digest info is used.
             <p>
             <ul>
             <li>0 - publicKey - A hash of the public key of the holder must be
             passed.</li>
             <li>1 - publicKeyCert - A hash of the public key certificate of the
             holder must be passed.</li>
             <li>2 - otherObjectDigest - A hash of some other object type must be
             passed. <code>otherObjectTypeID</code> must not be empty.</li>
             </ul>
             </p>
            
             @return The digest object type or -1 if no object digest info is set.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.AttributeCertificateHolder.DigestAlgorithm">
             Returns the other object type ID if an object digest info is used.
            
             @return The other object type ID or <code>null</code> if no object
                     digest info is set.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.AttributeCertificateHolder.GetObjectDigest">
             Returns the hash if an object digest info is used.
            
             @return The hash or <code>null</code> if no object digest info is set.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.AttributeCertificateHolder.OtherObjectTypeID">
             Returns the digest algorithm ID if an object digest info is used.
            
             @return The digest algorithm ID or <code>null</code> if no object
                     digest info is set.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.AttributeCertificateHolder.GetEntityNames">
             Return any principal objects inside the attribute certificate holder entity names field.
            
             @return an array of IPrincipal objects (usually X509Name), null if no entity names field is set.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.AttributeCertificateHolder.GetIssuer">
             Return the principals associated with the issuer attached to this holder
            
             @return an array of principals, null if no BaseCertificateID is set.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.AttributeCertificateHolder.SerialNumber">
             Return the serial number associated with the issuer attached to this holder.
            
             @return the certificate serial number, null if no BaseCertificateID is set.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.AttributeCertificateIssuer">
            Carrying class for an attribute certificate issuer.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.AttributeCertificateIssuer.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.AttCertIssuer)">
             Set the issuer directly with the ASN.1 structure.
            
             @param issuer The issuer
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.AttributeCertificateIssuer.GetPrincipals">
            <summary>Return any principal objects inside the attribute certificate issuer object.</summary>
            <returns>An array of IPrincipal objects (usually X509Principal).</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Extension.AuthorityKeyIdentifierStructure">
            <remarks>A high level authority key identifier.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Extension.AuthorityKeyIdentifierStructure.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1OctetString)">
             Constructor which will take the byte[] returned from getExtensionValue()
            
             @param encodedValue a DER octet encoded string with the extension structure in it.
             @throws IOException on parsing errors.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Extension.AuthorityKeyIdentifierStructure.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate)">
             Create an AuthorityKeyIdentifier using the passed in certificate's public
             key, issuer and serial number.
            
             @param certificate the certificate providing the information.
             @throws CertificateParsingException if there is a problem processing the certificate
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Extension.AuthorityKeyIdentifierStructure.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
             Create an AuthorityKeyIdentifier using just the hash of the
             public key.
            
             @param pubKey the key to generate the hash from.
             @throws InvalidKeyException if there is a problem using the key.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Extension.SubjectKeyIdentifierStructure">
            A high level subject key identifier.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Extension.SubjectKeyIdentifierStructure.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1OctetString)">
             Constructor which will take the byte[] returned from getExtensionValue()
            
             @param encodedValue a DER octet encoded string with the extension structure in it.
             @throws IOException on parsing errors.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Extension.X509ExtensionUtilities.FromExtensionValue(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.IX509Extension,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>
            Extract the value of the given extension, if it exists.
            </summary>
            <param name="extensions">The extensions object.</param>
            <param name="oid">The object identifier to obtain.</param>
            <returns>Asn1Object</returns>
            <exception cref="T:System.Exception">if the extension cannot be read.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.IX509Extension.GetCriticalExtensionOids">
            <summary>
            Get all critical extension values, by oid
            </summary>
            <returns>IDictionary with string (OID) keys and Asn1OctetString values</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.IX509Extension.GetNonCriticalExtensionOids">
            <summary>
            Get all non-critical extension values, by oid
            </summary>
            <returns>IDictionary with string (OID) keys and Asn1OctetString values</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.PrincipalUtilities">
            <remarks>
            A utility class that will extract X509Principal objects from X.509 certificates.
            <p>
            Use this in preference to trying to recreate a principal from a string, not all
            DNs are what they should be, so it's best to leave them encoded where they
            can be.</p>
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.PrincipalUtilities.GetIssuerX509Principal(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate)">
            <summary>Return the issuer of the given cert as an X509Principal.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.PrincipalUtilities.GetSubjectX509Principal(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate)">
            <summary>Return the subject of the given cert as an X509Principal.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.PrincipalUtilities.GetIssuerX509Principal(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl)">
            <summary>Return the issuer of the given CRL as an X509Principal.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector">
             This class is an <code>Selector</code> like implementation to select
             attribute certificates from a given set of criteria.
            
             @see org.bouncycastle.x509.X509AttributeCertificate
             @see org.bouncycastle.x509.X509Store
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.Match(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificate)">
            <summary>
            Decides if the given attribute certificate should be selected.
            </summary>
            <param name="attrCert">The attribute certificate to be checked.</param>
            <returns><code>true</code> if the object matches this selector.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AttributeCert">
            <summary>The attribute certificate which must be matched.</summary>
            <remarks>If <c>null</c> is given, any will do.</remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AttributeCertificateValid">
            <summary>The criteria for validity</summary>
            <remarks>If <c>null</c> is given any will do.</remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.Holder">
            <summary>The holder.</summary>
            <remarks>If <c>null</c> is given any will do.</remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.Issuer">
            <summary>The issuer.</summary>
            <remarks>If <c>null</c> is given any will do.</remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.SerialNumber">
            <summary>The serial number.</summary>
            <remarks>If <c>null</c> is given any will do.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AddTargetName(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName)">
             Adds a target name criterion for the attribute certificate to the target
             information extension criteria. The <code>X509AttributeCertificate</code>
             must contain at least one of the specified target names.
             <p>
             Each attribute certificate may contain a target information extension
             limiting the servers where this attribute certificate can be used. If
             this extension is not present, the attribute certificate is not targeted
             and may be accepted by any server.
             </p>
            
             @param name The name as a GeneralName (not <code>null</code>)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AddTargetName(System.Byte[])">
             Adds a target name criterion for the attribute certificate to the target
             information extension criteria. The <code>X509AttributeCertificate</code>
             must contain at least one of the specified target names.
             <p>
             Each attribute certificate may contain a target information extension
             limiting the servers where this attribute certificate can be used. If
             this extension is not present, the attribute certificate is not targeted
             and may be accepted by any server.
             </p>
            
             @param name a byte array containing the name in ASN.1 DER encoded form of a GeneralName
             @throws IOException if a parsing error occurs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.SetTargetNames(System.Collections.Generic.IEnumerable{System.Object})">
            Adds a collection with target names criteria. If <code>null</code> is
            given any will do.
            <p>
            The collection consists of either GeneralName objects or byte[] arrays representing
            DER encoded GeneralName structures.
            </p>
            
            @param names A collection of target names.
            @throws IOException if a parsing error occurs.
            @see #AddTargetName(byte[])
            @see #AddTargetName(GeneralName)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.GetTargetNames">
            Gets the target names. The collection consists of <code>List</code>s
            made up of an <code>Integer</code> in the first entry and a DER encoded
            byte array or a <code>String</code> in the second entry.
            <p>The returned collection is immutable.</p>
            
            @return The collection of target names
            @see #setTargetNames(Collection)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AddTargetGroup(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.GeneralName)">
             Adds a target group criterion for the attribute certificate to the target
             information extension criteria. The <code>X509AttributeCertificate</code>
             must contain at least one of the specified target groups.
             <p>
             Each attribute certificate may contain a target information extension
             limiting the servers where this attribute certificate can be used. If
             this extension is not present, the attribute certificate is not targeted
             and may be accepted by any server.
             </p>
            
             @param group The group as GeneralName form (not <code>null</code>)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AddTargetGroup(System.Byte[])">
             Adds a target group criterion for the attribute certificate to the target
             information extension criteria. The <code>X509AttributeCertificate</code>
             must contain at least one of the specified target groups.
             <p>
             Each attribute certificate may contain a target information extension
             limiting the servers where this attribute certificate can be used. If
             this extension is not present, the attribute certificate is not targeted
             and may be accepted by any server.
             </p>
            
             @param name a byte array containing the group in ASN.1 DER encoded form of a GeneralName
             @throws IOException if a parsing error occurs.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.SetTargetGroups(System.Collections.Generic.IEnumerable{System.Object})">
             Adds a collection with target groups criteria. If <code>null</code> is
             given any will do.
             <p>
             The collection consists of <code>GeneralName</code> objects or <code>byte[]</code>
             representing DER encoded GeneralNames.
             </p>
            
             @param names A collection of target groups.
             @throws IOException if a parsing error occurs.
             @see #AddTargetGroup(byte[])
             @see #AddTargetGroup(GeneralName)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.GetTargetGroups">
             Gets the target groups. The collection consists of <code>List</code>s
             made up of an <code>Integer</code> in the first entry and a DER encoded
             byte array or a <code>String</code> in the second entry.
             <p>The returned collection is immutable.</p>
            
             @return The collection of target groups.
             @see #setTargetGroups(Collection)
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509CertPairStoreSelector">
            <remarks>
            This class is an <code>IX509Selector</code> implementation to select
            certificate pairs, which are e.g. used for cross certificates. The set of
            criteria is given from two <code>X509CertStoreSelector</code> objects,
            each of which, if present, must match the respective component of a pair.
            </remarks>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509CertPairStoreSelector.CertPair">
            <summary>The certificate pair which is used for testing on equality.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509CertPairStoreSelector.ForwardSelector">
            <summary>The certificate selector for the forward part.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509CertPairStoreSelector.ReverseSelector">
            <summary>The certificate selector for the reverse part.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509CertPairStoreSelector.Match(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CertificatePair)">
            <summary>
            Decides if the given certificate pair should be selected. If
            <c>obj</c> is not a <code>X509CertificatePair</code>, this method
            returns <code>false</code>.
            </summary>
            <param name="pair">The <code>X509CertificatePair</code> to be tested.</param>
            <returns><code>true</code> if the object matches this selector.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509CertStoreSelector.Policy">
            <summary>
            An <code>ISet</code> of <code>DerObjectIdentifier</code> objects.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509CrlStoreSelector.Issuers">
            <summary>
            An <code>ICollection</code> of <code>X509Name</code> objects
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509CrlStoreSelector.AttrCertChecking">
             The attribute certificate being checked. This is not a criterion.
             Rather, it is optional information that may help a {@link X509Store} find
             CRLs that would be relevant when checking revocation for the specified
             attribute certificate. If <code>null</code> is specified, then no such
             optional information is provided.
            
             @param attrCert the <code>IX509AttributeCertificate</code> being checked (or
                         <code>null</code>)
             @see #getAttrCertificateChecking()
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509CrlStoreSelector.CompleteCrlEnabled">
             If <code>true</code> only complete CRLs are returned. Defaults to
             <code>false</code>.
            
             @return <code>true</code> if only complete CRLs are returned.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509CrlStoreSelector.DeltaCrlIndicatorEnabled">
             Returns if this selector must match CRLs with the delta CRL indicator
             extension set. Defaults to <code>false</code>.
            
             @return Returns <code>true</code> if only CRLs with the delta CRL
                     indicator extension are selected.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509CrlStoreSelector.IssuingDistributionPoint">
             The issuing distribution point.
             <p>
             The issuing distribution point extension is a CRL extension which
             identifies the scope and the distribution point of a CRL. The scope
             contains among others information about revocation reasons contained in
             the CRL. Delta CRLs and complete CRLs must have matching issuing
             distribution points.</p>
             <p>
             The byte array is cloned to protect against subsequent modifications.</p>
             <p>
             You must also enable or disable this criteria with
             {@link #setIssuingDistributionPointEnabled(bool)}.</p>
            
             @param issuingDistributionPoint The issuing distribution point to set.
                                             This is the DER encoded OCTET STRING extension value.
             @see #getIssuingDistributionPoint()
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509CrlStoreSelector.IssuingDistributionPointEnabled">
             Whether the issuing distribution point criteria should be applied.
             Defaults to <code>false</code>.
             <p>
             You may also set the issuing distribution point criteria if not a missing
             issuing distribution point should be assumed.</p>
            
             @return Returns if the issuing distribution point check is enabled.
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.Store.X509CrlStoreSelector.MaxBaseCrlNumber">
             The maximum base CRL number. Defaults to <code>null</code>.
            
             @return Returns the maximum base CRL number.
             @see #setMaxBaseCRLNumber(BigInteger)
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.SubjectPublicKeyInfoFactory">
            <summary>
            A factory to produce Public Key Info Objects.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.SubjectPublicKeyInfoFactory.CreateSubjectPublicKeyInfo(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Create a Subject Public Key Info object for a given public key.
            </summary>
            <param name="publicKey">One of ElGammalPublicKeyParameters, DSAPublicKeyParameter, DHPublicKeyParameters, RsaKeyParameters or ECPublicKeyParameters</param>
            <returns>A subject public key info object.</returns>
            <exception cref="T:System.Exception">Throw exception if object provided is not one of the above.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509AttrCertParser.ReadAttrCert(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509AttrCertParser.ReadAttrCerts(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509AttrCertParser.ReadAttrCert(System.IO.Stream)">
            Generates a certificate object and initializes it with the data
            read from the input stream inStream.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509AttrCertParser.ReadAttrCerts(System.IO.Stream)">
            Returns a (possibly empty) collection view of the certificates
            read from the given input stream inStream.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Attribute">
            Class for carrying the values in an X.509 Attribute.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Attribute.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param at an object representing an attribute.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Attribute.#ctor(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
             Create an X.509 Attribute with the type given by the passed in oid and
             the value represented by an ASN.1 Set containing value.
            
             @param oid type of the attribute
             @param value value object to go into the atribute's value set.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Attribute.#ctor(System.String,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1EncodableVector)">
             Create an X.59 Attribute with the type given by the passed in oid and the
             value represented by an ASN.1 Set containing the objects in value.
            
             @param oid type of the attribute
             @param value vector of values to go in the attribute's value set.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate">
            <summary>
            An Object representing an X509 Certificate.
            Has static methods for loading Certificates encoded in many forms that return X509Certificate Objects.
            </summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.IsValidNow">
            <summary>
            Return true if the current time is within the start and end times nominated on the certificate.
            </summary>
            <returns>true id certificate is valid for the current time.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.IsValid(System.DateTime)">
            <summary>
            Return true if the nominated time is within the start and end times nominated on the certificate.
            </summary>
            <param name="time">The time to test validity against.</param>
            <returns>True if certificate is valid for nominated time.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.CheckValidity">
            <summary>
            Checks if the current date is within certificate's validity period.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.CheckValidity(System.DateTime)">
            <summary>
            Checks if the given date is within certificate's validity period.
            </summary>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.Certificates.CertificateExpiredException">if the certificate is expired by given date</exception>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.Certificates.CertificateNotYetValidException">if the certificate is not yet valid on given date</exception>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.Version">
            <summary>
            Return the certificate's version.
            </summary>
            <returns>An integer whose value Equals the version of the cerficate.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.SerialNumber">
            <summary>
            Return a <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger">BigInteger</see> containing the serial number.
            </summary>
            <returns>The Serial number.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.IssuerDN">
            <summary>
            Get the Issuer Distinguished Name. (Who signed the certificate.)
            </summary>
            <returns>And X509Object containing name and value pairs.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.SubjectDN">
            <summary>
            Get the subject of this certificate.
            </summary>
            <returns>An X509Name object containing name and value pairs.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.NotBefore">
            <summary>
            The time that this certificate is valid from.
            </summary>
            <returns>A DateTime object representing that time in the local time zone.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.NotAfter">
            <summary>
            The time that this certificate is valid up to.
            </summary>
            <returns>A DateTime object representing that time in the local time zone.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.GetTbsCertificate">
            <summary>
            Return the Der encoded TbsCertificate data.
            This is the certificate component less the signature.
            To Get the whole certificate call the GetEncoded() member.
            </summary>
            <returns>A byte array containing the Der encoded Certificate component.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.GetSignature">
            <summary>
            The signature.
            </summary>
            <returns>A byte array containg the signature of the certificate.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.SigAlgName">
            <summary>
            A meaningful version of the Signature Algorithm. (EG SHA1WITHRSA)
            </summary>
            <returns>A sting representing the signature algorithm.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.SigAlgOid">
            <summary>
            Get the Signature Algorithms Object ID.
            </summary>
            <returns>A string containg a '.' separated object id.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.GetSigAlgParams">
            <summary>
            Get the signature algorithms parameters. (EG DSA Parameters)
            </summary>
            <returns>A byte array containing the Der encoded version of the parameters or null if there are none.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.IssuerUniqueID">
            <summary>
            Get the issuers UID.
            </summary>
            <returns>A DerBitString.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.SubjectUniqueID">
            <summary>
            Get the subjects UID.
            </summary>
            <returns>A DerBitString.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.GetKeyUsage">
            <summary>
            Get a key usage guidlines.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.GetPublicKey">
            <summary>
            Get the public key of the subject of the certificate.
            </summary>
            <returns>The public key parameters.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.GetEncoded">
            <summary>
            Return the DER encoding of this certificate.
            </summary>
            <returns>A byte array containing the DER encoding of this certificate.</returns>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.Certificates.CertificateEncodingException">If there is an error encoding the certificate.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.Verify(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Verify the certificate's signature using the nominated public key.
            </summary>
            <param name="key">An appropriate public key parameter object, RsaPublicKeyParameters, DsaPublicKeyParameters or ECDsaPublicKeyParameters</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If key submitted is not of the above nominated types.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate.Verify(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IVerifierFactoryProvider)">
            <summary>
            Verify the certificate's signature using a verifier created using the passed in verifier provider.
            </summary>
            <param name="verifierProvider">An appropriate provider for verifying the certificate's signature.</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If verifier provider is not appropriate or the certificate algorithm is invalid.</exception>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CertificatePair">
            <remarks>
            This class contains a cross certificate pair. Cross certificates pairs may
            contain two cross signed certificates from two CAs. A certificate from the
            other CA to this CA is contained in the forward certificate, the certificate
            from this CA to the other CA is contained in the reverse certificate.
            </remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CertificatePair.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate)">
            <summary>Constructor</summary>
            <param name="forward">Certificate from the other CA to this CA.</param>
            <param name="reverse">Certificate from this CA to the other CA.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CertificatePair.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.CertificatePair)">
            <summary>Constructor from a ASN.1 CertificatePair structure.</summary>
            <param name="pair">The <c>CertificatePair</c> ASN.1 object.</param>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CertificatePair.Forward">
            <summary>Returns the certificate from the other CA to this CA.</summary>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CertificatePair.Reverse">
            <summary>Returns the certificate from this CA to the other CA.</summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CertificateParser">
            class for dealing with X509 certificates.
            <p>
            At the moment this will deal with "-----BEGIN CERTIFICATE-----" to "-----END CERTIFICATE-----"
            base 64 encoded certs, as well as the BER binaries of certificates and some classes of PKCS#7
            objects.</p>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CertificateParser.ReadCertificate(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CertificateParser.ReadCertificates(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CertificateParser.ReadCertificate(System.IO.Stream)">
            Generates a certificate object and initializes it with the data
            read from the input stream inStream.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CertificateParser.ReadCertificates(System.IO.Stream)">
            Returns a (possibly empty) collection view of the certificates
            read from the given input stream inStream.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CertPairParser.ReadCertPair(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CertPairParser.ReadCertPairs(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl">
             The following extensions are listed in RFC 2459 as relevant to CRLs
            
             Authority Key Identifier
             Issuer Alternative Name
             CRL Number
             Delta CRL Indicator (critical)
             Issuing Distribution Point (critical)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl.Verify(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IVerifierFactoryProvider)">
            <summary>
            Verify the CRL's signature using a verifier created using the passed in verifier provider.
            </summary>
            <param name="verifierProvider">An appropriate provider for verifying the CRL's signature.</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If verifier provider is not appropriate or the CRL algorithm is invalid.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl.GetEncoded">
            <summary>
            Return the DER encoding of this CRL.
            </summary>
            <returns>A byte array containing the DER encoding of this CRL.</returns>
            <exception cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Security.Certificates.CrlException">If there is an error encoding the CRL.</exception>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl.ToString">
             Returns a string representation of this CRL.
            
             @return a string representation of this CRL.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl.IsRevoked(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate)">
             Checks whether the given certificate is on this CRL.
            
             @param cert the certificate to check for.
             @return true if the given certificate is on this CRL,
             false otherwise.
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CrlEntry">
             The following extensions are listed in RFC 2459 as relevant to CRL Entries
            
             ReasonCode Hode Instruction Code Invalidity Date Certificate Issuer
             (critical)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CrlEntry.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.CrlEntry,System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name)">
             Constructor for CRLEntries of indirect CRLs. If <code>isIndirect</code>
             is <code>false</code> {@link #getCertificateIssuer()} will always
             return <code>null</code>, <code>previousCertificateIssuer</code> is
             ignored. If this <code>isIndirect</code> is specified and this CrlEntry
             has no certificate issuer CRL entry extension
             <code>previousCertificateIssuer</code> is returned by
             {@link #getCertificateIssuer()}.
            
             @param c
                        TbsCertificateList.CrlEntry object.
             @param isIndirect
                        <code>true</code> if the corresponding CRL is a indirect
                        CRL.
             @param previousCertificateIssuer
                        Certificate issuer of the previous CrlEntry.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CrlParser.ReadCrl(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CrlParser.ReadCrls(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CrlParser.ReadCrl(System.IO.Stream)">
            Generates a certificate revocation list (CRL) object and initializes
            it with the data read from the input stream inStream.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509CrlParser.ReadCrls(System.IO.Stream)">
             Returns a (possibly empty) collection view of the CRLs read from
             the given input stream inStream.
            
             The inStream may contain a sequence of DER-encoded CRLs, or
             a PKCS#7 CRL set.  This is a PKCS#7 SignedData object, with the
             only significant field being crls.  In particular the signature
             and the contents are ignored.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509ExtensionBase.GetNonCriticalExtensionOids">
            <summary>
            Get non critical extensions.
            </summary>
            <returns>A set of non critical extension oids.</returns>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509ExtensionBase.GetCriticalExtensionOids">
            <summary>
            Get any critical extensions.
            </summary>
            <returns>A sorted list of critical entension.</returns>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509KeyUsage">
             A holding class for constructing an X509 Key Usage extension.
            
             <pre>
                id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
            
                KeyUsage ::= BIT STRING {
                     digitalSignature        (0),
                     nonRepudiation          (1),
                     keyEncipherment         (2),
                     dataEncipherment        (3),
                     keyAgreement            (4),
                     keyCertSign             (5),
                     cRLSign                 (6),
                     encipherOnly            (7),
                     decipherOnly            (8) }
             </pre>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509KeyUsage.#ctor(System.Int32)">
             Basic constructor.
            
             @param usage - the bitwise OR of the Key Usage flags giving the
             allowed uses for the key.
             e.g. (X509KeyUsage.keyEncipherment | X509KeyUsage.dataEncipherment)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509SignatureUtilities.GetDigestAlgName(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V1CertificateGenerator">
            <summary>
            Class to Generate X509V1 Certificates.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V1CertificateGenerator.#ctor">
            <summary>
            Default Constructor.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V1CertificateGenerator.Reset">
            <summary>
            Reset the generator.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V1CertificateGenerator.SetSerialNumber(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Set the certificate's serial number.
            </summary>
            <remarks>Make serial numbers long, if you have no serial number policy make sure the number is at least 16 bytes of secure random data.
            You will be surprised how ugly a serial number collision can get.</remarks>
            <param name="serialNumber">The serial number.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V1CertificateGenerator.SetIssuerDN(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name)">
            <summary>
            Set the issuer distinguished name.
            The issuer is the entity whose private key is used to sign the certificate.
            </summary>
            <param name="issuer">The issuers DN.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V1CertificateGenerator.SetNotBefore(System.DateTime)">
            <summary>
            Set the date that this certificate is to be valid from.
            </summary>
            <param name="date"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V1CertificateGenerator.SetNotAfter(System.DateTime)">
            <summary>
            Set the date after which this certificate will no longer be valid.
            </summary>
            <param name="date"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V1CertificateGenerator.SetSubjectDN(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name)">
            <summary>
            Set the subject distinguished name.
            The subject describes the entity associated with the public key.
            </summary>
            <param name="subject"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V1CertificateGenerator.SetPublicKey(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Set the public key that this certificate identifies.
            </summary>
            <param name="publicKey"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V1CertificateGenerator.Generate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory)">
            <summary>
            Generate a new <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate"/> using the provided <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory"/>.
            </summary>
            <param name="signatureFactory">A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory">signature factory</see> with the necessary
            algorithm details.</param>
            <returns>An <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate"/>.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V1CertificateGenerator.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the generator.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificate">
            <summary>An implementation of a version 2 X.509 Attribute Certificate.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificate.Verify(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IVerifierFactoryProvider)">
            <summary>
            Verify the certificate's signature using a verifier created using the passed in verifier provider.
            </summary>
            <param name="verifierProvider">An appropriate provider for verifying the certificate's signature.</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If verifier provider is not appropriate or the certificate algorithm is invalid.</exception>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator">
            <remarks>Class to produce an X.509 Version 2 AttributeCertificate.</remarks>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.Reset">
            <summary>Reset the generator</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.SetHolder(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.AttributeCertificateHolder)">
            <summary>Set the Holder of this Attribute Certificate.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.SetIssuer(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.AttributeCertificateIssuer)">
            <summary>Set the issuer.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.SetSerialNumber(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>Set the serial number for the certificate.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.AddAttribute(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Attribute)">
            <summary>Add an attribute.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.AddExtension(System.String,System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>Add a given extension field for the standard extensions tag.</summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.AddExtension(System.String,System.Boolean,System.Byte[])">
            <summary>
            Add a given extension field for the standard extensions tag.
            The value parameter becomes the contents of the octet string associated
            with the extension.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.Generate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory)">
            <summary>
            Generate a new <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificate"/> using the provided <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory"/>.
            </summary>
            <param name="signatureFactory">A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory">signature factory</see> with the necessary
            algorithm details.</param>
            <returns>An <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificate"/>.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the generator.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2CrlGenerator">
            class to produce an X.509 Version 2 CRL.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2CrlGenerator.Reset">
            reset the generator
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2CrlGenerator.SetIssuerDN(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name)">
            Set the issuer distinguished name - the issuer is the entity whose private key is used to sign the
            certificate.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2CrlGenerator.AddCrlEntry(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.DateTime,System.Int32)">
             Reason being as indicated by CrlReason, i.e. CrlReason.KeyCompromise
             or 0 if CrlReason is not to be used
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2CrlGenerator.AddCrlEntry(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.DateTime,System.Int32,System.DateTime)">
             Add a CRL entry with an Invalidity Date extension as well as a CrlReason extension.
             Reason being as indicated by CrlReason, i.e. CrlReason.KeyCompromise
             or 0 if CrlReason is not to be used
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2CrlGenerator.AddCrlEntry(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger,System.DateTime,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a CRL entry with extensions.
            
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2CrlGenerator.AddCrl(Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl)">
             Add the CRLEntry objects contained in a previous CRL.
            
             @param other the X509Crl to source the other entries from.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2CrlGenerator.AddExtension(System.String,System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            add a given extension field for the standard extensions tag (tag 0)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2CrlGenerator.AddExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            add a given extension field for the standard extensions tag (tag 0)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2CrlGenerator.AddExtension(System.String,System.Boolean,System.Byte[])">
            add a given extension field for the standard extensions tag (tag 0)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2CrlGenerator.AddExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,System.Byte[])">
            add a given extension field for the standard extensions tag (tag 0)
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2CrlGenerator.Generate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory)">
            <summary>
            Generate a new <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl"/> using the provided <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory"/>.
            </summary>
            <param name="signatureFactory">A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory">signature factory</see> with the necessary
            algorithm details.</param>
            <returns>An <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Crl"/>.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V2CrlGenerator.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the generator.
            </summary>
        </member>
        <member name="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator">
            <summary>
            A class to Generate Version 3 X509Certificates.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.Reset">
            <summary>
            Reset the Generator.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.SetSerialNumber(Best.HTTP.SecureProtocol.Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Set the certificate's serial number.
            </summary>
            <remarks>Make serial numbers long, if you have no serial number policy make sure the number is at least 16 bytes of secure random data.
            You will be surprised how ugly a serial number collision can Get.</remarks>
            <param name="serialNumber">The serial number.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.SetIssuerDN(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name)">
            <summary>
            Set the distinguished name of the issuer.
            The issuer is the entity which is signing the certificate.
            </summary>
            <param name="issuer">The issuer's DN.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.SetNotBefore(System.DateTime)">
            <summary>
            Set the date that this certificate is to be valid from.
            </summary>
            <param name="date"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.SetNotAfter(System.DateTime)">
            <summary>
            Set the date after which this certificate will no longer be valid.
            </summary>
            <param name="date"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.SetSubjectDN(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509.X509Name)">
            <summary>
            Set the DN of the entity that this certificate is about.
            </summary>
            <param name="subject"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.SetPublicKey(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Set the public key that this certificate identifies.
            </summary>
            <param name="publicKey"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.SetSubjectUniqueID(System.Boolean[])">
            <summary>
            Set the subject unique ID - note: it is very rare that it is correct to do this.
            </summary>
            <param name="uniqueID"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.SetIssuerUniqueID(System.Boolean[])">
            <summary>
            Set the issuer unique ID - note: it is very rare that it is correct to do this.
            </summary>
            <param name="uniqueID"/>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.AddExtension(System.String,System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>
            Add a given extension field for the standard extensions tag (tag 3).
            </summary>
            <param name="oid">string containing a dotted decimal Object Identifier.</param>
            <param name="critical">Is it critical.</param>
            <param name="extensionValue">The value.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.AddExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>
            Add an extension to this certificate.
            </summary>
            <param name="oid">Its Object Identifier.</param>
            <param name="critical">Is it critical.</param>
            <param name="extensionValue">The value.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.AddExtension(System.String,System.Boolean,System.Byte[])">
            <summary>
            Add an extension using a string with a dotted decimal OID.
            </summary>
            <param name="oid">string containing a dotted decimal Object Identifier.</param>
            <param name="critical">Is it critical.</param>
            <param name="extensionValue">byte[] containing the value of this extension.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.AddExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,System.Byte[])">
            <summary>
            Add an extension to this certificate.
            </summary>
            <param name="oid">Its Object Identifier.</param>
            <param name="critical">Is it critical.</param>
            <param name="extensionValue">byte[] containing the value of this extension.</param>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.CopyAndAddExtension(System.String,System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate)">
            <summary>
            Add a given extension field for the standard extensions tag (tag 3),
            copying the extension value from another certificate.
            </summary>
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.CopyAndAddExtension(Best.HTTP.SecureProtocol.Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate)">
            add a given extension field for the standard extensions tag (tag 3)
            copying the extension value from another certificate.
            @throws CertificateParsingException if the extension cannot be extracted.
        </member>
        <member name="M:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.Generate(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory)">
            <summary>
            Generate a new <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate"/> using the provided <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory"/>.
            </summary>
            <param name="signatureFactory">A <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ISignatureFactory">signature factory</see> with the necessary
            algorithm details.</param>
            <returns>An <see cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509Certificate"/>.</returns>
        </member>
        <member name="P:Best.HTTP.SecureProtocol.Org.BouncyCastle.X509.X509V3CertificateGenerator.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the generator.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.Compression.Crc.CRC32">
            <summary>
              Computes a CRC-32. The CRC-32 algorithm is parameterized - you
              can set the polynomial and enable or disable bit
              reversal. This can be used for GZIP, BZip2, or ZIP.
            </summary>
            <remarks>
              This type is used internally by DotNetZip; it is generally not used
              directly by applications wishing to create, read, or manipulate zip
              archive files.
            </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Crc.CRC32.TotalBytesRead">
            <summary>
              Indicates the total number of bytes applied to the CRC.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Crc.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Crc.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Crc.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the
            output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Crc.CRC32.ComputeCrc32(System.Int32,System.Byte)">
            <summary>
              Get the CRC32 for the given (word,byte) combo.  This is a
              computation defined by PKzip for PKZIP 2.0 (weak) encryption.
            </summary>
            <param name="W">The word to start with.</param>
            <param name="B">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Crc.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Crc.CRC32.UpdateCRC(System.Byte)">
            <summary>
              Process one byte in the CRC.
            </summary>
            <param name = "b">the byte to include into the CRC .  </param>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Crc.CRC32.UpdateCRC(System.Byte,System.Int32)">
            <summary>
              Process a run of N identical bytes into the CRC.
            </summary>
            <remarks>
              <para>
                This method serves as an optimization for updating the CRC when a
                run of identical bytes is found. Rather than passing in a buffer of
                length n, containing all identical bytes b, this method accepts the
                byte value and the length of the (virtual) buffer - the length of
                the run.
              </para>
            </remarks>
            <param name = "b">the byte to include into the CRC.  </param>
            <param name = "n">the number of times that byte should be repeated. </param>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Crc.CRC32.Combine(System.Int32,System.Int32)">
            <summary>
              Combines the given CRC32 value with the current running total.
            </summary>
            <remarks>
              This is useful when using a divide-and-conquer approach to
              calculating a CRC.  Multiple threads can each calculate a
              CRC32 on a segment of the data, and then combine the
              individual CRC32 values at the end.
            </remarks>
            <param name="crc">the crc value to be combined with this one</param>
            <param name="length">the length of data the CRC value was calculated on</param>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Crc.CRC32.#ctor">
            <summary>
              Create an instance of the CRC32 class using the default settings: no
              bit reversal, and a polynomial of 0xEDB88320.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Crc.CRC32.#ctor(System.Boolean)">
            <summary>
              Create an instance of the CRC32 class, specifying whether to reverse
              data bits or not.
            </summary>
            <param name='reverseBits'>
              specify true if the instance should reverse data bits.
            </param>
            <remarks>
              <para>
                In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                want a CRC32 with compatibility with BZip2, you should pass true
                here. In the CRC-32 used by GZIP and PKZIP, the bits are not
                reversed; Therefore if you want a CRC32 with compatibility with
                those, you should pass false.
              </para>
            </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Crc.CRC32.#ctor(System.Int32,System.Boolean)">
             <summary>
               Create an instance of the CRC32 class, specifying the polynomial and
               whether to reverse data bits or not.
             </summary>
             <param name='polynomial'>
               The polynomial to use for the CRC, expressed in the reversed (LSB)
               format: the highest ordered bit in the polynomial value is the
               coefficient of the 0th power; the second-highest order bit is the
               coefficient of the 1 power, and so on. Expressed this way, the
               polynomial for the CRC-32C used in IEEE 802.3, is 0xEDB88320.
             </param>
             <param name='reverseBits'>
               specify true if the instance should reverse data bits.
             </param>
            
             <remarks>
               <para>
                 In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                 want a CRC32 with compatibility with BZip2, you should pass true
                 here for the <c>reverseBits</c> parameter. In the CRC-32 used by
                 GZIP and PKZIP, the bits are not reversed; Therefore if you want a
                 CRC32 with compatibility with those, you should pass false for the
                 <c>reverseBits</c> parameter.
               </para>
             </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Crc.CRC32.Reset">
            <summary>
              Reset the CRC-32 class - clear the CRC "remainder register."
            </summary>
            <remarks>
              <para>
                Use this when employing a single instance of this class to compute
                multiple, distinct CRCs on multiple, distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="T:Best.HTTP.Shared.Compression.Zlib.DeflateStream">
             <summary>
             A class for compressing and decompressing streams using the Deflate algorithm.
             </summary>
            
             <remarks>
            
             <para>
               The DeflateStream is a <see
               href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see
               cref="T:System.IO.Stream"/>.  It adds DEFLATE compression or decompression to any
               stream.
             </para>
            
             <para>
               Using this stream, applications can compress or decompress data via stream
               <c>Read</c> and <c>Write</c> operations.  Either compresssion or decompression
               can occur through either reading or writing. The compression format used is
               DEFLATE, which is documented in <see
               href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
               Compressed Data Format Specification version 1.3.".
             </para>
            
             </remarks>
            
             <seealso cref="T:Best.HTTP.Shared.Compression.Zlib.GZipStream" />
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.DeflateStream.#ctor(System.IO.Stream,Best.HTTP.Shared.Compression.Zlib.CompressionMode)">
             <summary>
               Create a DeflateStream using the specified CompressionMode.
             </summary>
            
             <remarks>
               When mode is <c>CompressionMode.Compress</c>, the DeflateStream will use
               the default compression level. The "captive" stream will be closed when
               the DeflateStream is closed.
             </remarks>
            
             <example>
             This example uses a DeflateStream to compress data from a file, and writes
             the compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.DeflateStream.#ctor(System.IO.Stream,Best.HTTP.Shared.Compression.Zlib.CompressionMode,Best.HTTP.Shared.Compression.Zlib.CompressionLevel)">
             <summary>
             Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is
               ignored.  The "captive" stream will be closed when the DeflateStream is
               closed.
             </para>
            
             </remarks>
            
             <example>
            
               This example uses a DeflateStream to compress data from a file, and writes
               the compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw,
                                                                  CompressionMode.Compress,
                                                                  CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>DeflateStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.DeflateStream.#ctor(System.IO.Stream,Best.HTTP.Shared.Compression.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified
               <c>CompressionMode</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compression.  Specify true for
               the <paramref name="leaveOpen"/> parameter to leave the stream open.
             </para>
            
             <para>
               The <c>DeflateStream</c> will use the default compression level.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the
               "captive" stream in other places in this documentation.
             </param>
            
             <param name="mode">
               Indicates whether the <c>DeflateStream</c> will compress or decompress.
             </param>
            
             <param name="leaveOpen">true if the application would like the stream to
             remain open after inflation/deflation.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.DeflateStream.#ctor(System.IO.Stream,Best.HTTP.Shared.Compression.Zlib.CompressionMode,Best.HTTP.Shared.Compression.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify whether
               the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter
               to leave the stream open.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to use a <c>DeflateStream</c> to compress data from
               a file, and store the compressed data into another file.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".deflated"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
            
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".deflated")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.DeflateStream.#ctor(System.IO.Stream,Best.HTTP.Shared.Compression.Zlib.CompressionMode,Best.HTTP.Shared.Compression.Zlib.CompressionLevel,System.Boolean,System.Int32)">
             <summary>
               Create a <c>DeflateStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify whether
               the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter
               to leave the stream open.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to use a <c>DeflateStream</c> to compress data from
               a file, and store the compressed data into another file.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".deflated"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
            
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".deflated")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
             <param name="windowBits">Desired window bits.</param>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.DeflateStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
            <remarks> See the ZLIB documentation for the meaning of the flush behavior.
            </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.DeflateStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.DeflateStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
             <remarks>
               By tweaking this parameter, you may be able to optimize the compression for
               data with particular characteristics.
             </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.DeflateStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.DeflateStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.DeflateStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                Application code won't call this code directly.  This method may be
                invoked in two distinct scenarios.  If disposing == true, the method
                has been called directly or indirectly by a user's code, for example
                via the public Dispose() method. In this case, both managed and
                unmanaged resources can be referenced and disposed.  If disposing ==
                false, the method has been called by the runtime from inside the
                object finalizer and this method should not reference other objects;
                in that case only unmanaged resources must be referenced or
                disposed.
              </para>
            </remarks>
            <param name="disposing">
              true if the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.DeflateStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.DeflateStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.DeflateStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.DeflateStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.DeflateStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.DeflateStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, providing an uncompressed data stream.
               Then call Read() on that <c>DeflateStream</c>, and the data read will be
               compressed as you read.  If you wish to use the <c>DeflateStream</c> to
               decompress data while reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, providing a readable compressed data
               stream.  Then call Read() on that <c>DeflateStream</c>, and the data read
               will be decompressed as you read.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
            
             </remarks>
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.DeflateStream.SetLength(System.Int64)">
            <summary>
            Will call the base stream's SetLength method.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, and a writable output stream.  Then call
               <c>Write()</c> on that <c>DeflateStream</c>, providing uncompressed data
               as input.  The data sent to the output stream will be the compressed form
               of the data written.  If you wish to use the <c>DeflateStream</c> to
               decompress data while writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, and a writable output stream.  Then
               call <c>Write()</c> on that stream, providing previously compressed
               data. The data sent to the output stream will be the decompressed form of
               the data written.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>,
               but not both.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="T:Best.HTTP.Shared.Compression.Zlib.GZipStream">
             <summary>
               A class for compressing and decompressing GZIP streams.
             </summary>
             <remarks>
            
             <para>
               The <c>GZipStream</c> is a <see
               href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a
               <see cref="T:System.IO.Stream"/>. It adds GZIP compression or decompression to any
               stream.
             </para>
            
             <para>
               Like the <c>System.IO.Compression.GZipStream</c> in the .NET Base Class Library, the
               <c>Ionic.Zlib.GZipStream</c> can compress while writing, or decompress while
               reading, but not vice versa.  The compression method used is GZIP, which is
               documented in <see href="http://www.ietf.org/rfc/rfc1952.txt">IETF RFC
               1952</see>, "GZIP file format specification version 4.3".</para>
            
             <para>
               A <c>GZipStream</c> can be used to decompress data (through <c>Read()</c>) or
               to compress data (through <c>Write()</c>), but not both.
             </para>
            
             <para>
               If you wish to use the <c>GZipStream</c> to compress data, you must wrap it
               around a write-able stream. As you call <c>Write()</c> on the <c>GZipStream</c>, the
               data will be compressed into the GZIP format.  If you want to decompress data,
               you must wrap the <c>GZipStream</c> around a readable stream that contains an
               IETF RFC 1952-compliant stream.  The data will be decompressed as you call
               <c>Read()</c> on the <c>GZipStream</c>.
             </para>
            
             <para>
               Though the GZIP format allows data from multiple files to be concatenated
               together, this stream handles only a single segment of GZIP format, typically
               representing a single file.
             </para>
            
             </remarks>
            
             <seealso cref="T:Best.HTTP.Shared.Compression.Zlib.DeflateStream" />
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.GZipStream.Comment">
             <summary>
               The comment on the GZIP stream.
             </summary>
            
             <remarks>
             <para>
               The GZIP format allows for each file to optionally have an associated
               comment stored with the file.  The comment is encoded with the ISO-8859-1
               code page.  To include a comment in a GZIP stream you create, set this
               property before calling <c>Write()</c> for the first time on the
               <c>GZipStream</c>.
             </para>
            
             <para>
               When using <c>GZipStream</c> to decompress, you can retrieve this property
               after the first call to <c>Read()</c>.  If no comment has been set in the
               GZIP bytestream, the Comment property will return <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
             </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.GZipStream.FileName">
             <summary>
               The FileName for the GZIP stream.
             </summary>
            
             <remarks>
            
             <para>
               The GZIP format optionally allows each file to have an associated
               filename.  When compressing data (through <c>Write()</c>), set this
               FileName before calling <c>Write()</c> the first time on the <c>GZipStream</c>.
               The actual filename is encoded into the GZIP bytestream with the
               ISO-8859-1 code page, according to RFC 1952. It is the application's
               responsibility to insure that the FileName can be encoded and decoded
               correctly with this code page.
             </para>
            
             <para>
               When decompressing (through <c>Read()</c>), you can retrieve this value
               any time after the first <c>Read()</c>.  In the case where there was no filename
               encoded into the GZIP bytestream, the property will return <c>null</c> (<c>Nothing</c>
               in VB).
             </para>
             </remarks>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.GZipStream.LastModified">
             <summary>
               The last modified time for the GZIP stream.
             </summary>
            
             <remarks>
               GZIP allows the storage of a last modified time with each GZIP entity.
               When compressing data, you can set this before the first call to
               <c>Write()</c>.  When decompressing, you can retrieve this value any time
               after the first call to <c>Read()</c>.
             </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.GZipStream.Crc32">
            <summary>
            The CRC on the GZIP stream.
            </summary>
            <remarks>
            This is used for internal error checking. You probably don't need to look at this property.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.GZipStream.#ctor(System.IO.Stream,Best.HTTP.Shared.Compression.Zlib.CompressionMode)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>GZipStream</c> will use the
               default compression level.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with
               <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a GZipStream to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <example>
             This example shows how to use a GZipStream to uncompress a file.
             <code>
             private void GunZipFile(string filename)
             {
                 if (!filename.EndsWith(".gz))
                     throw new ArgumentException("filename");
                 var DecompressedFile = filename.Substring(0,filename.Length-3);
                 byte[] working = new byte[WORKING_BUFFER_SIZE];
                 int n= 1;
                 using (System.IO.Stream input = System.IO.File.OpenRead(filename))
                 {
                     using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                     {
                         using (var output = System.IO.File.Create(DecompressedFile))
                         {
                             while (n !=0)
                             {
                                 n= decompressor.Read(working, 0, working.Length);
                                 if (n > 0)
                                 {
                                     output.Write(working, 0, n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub GunZipFile(ByVal filename as String)
                 If Not (filename.EndsWith(".gz)) Then
                     Throw New ArgumentException("filename")
                 End If
                 Dim DecompressedFile as String = filename.Substring(0,filename.Length-3)
                 Dim working(WORKING_BUFFER_SIZE) as Byte
                 Dim n As Integer = 1
                 Using input As Stream = File.OpenRead(filename)
                     Using decompressor As Stream = new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, True)
                         Using output As Stream = File.Create(UncompressedFile)
                             Do
                                 n= decompressor.Read(working, 0, working.Length)
                                 If n > 0 Then
                                     output.Write(working, 0, n)
                                 End IF
                             Loop While (n  > 0)
                         End Using
                     End Using
                 End Using
             End Sub
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.GZipStream.#ctor(System.IO.Stream,Best.HTTP.Shared.Compression.Zlib.CompressionMode,Best.HTTP.Shared.Compression.Zlib.CompressionLevel)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
             <remarks>
            
             <para>
               The <c>CompressionMode</c> (Compress or Decompress) also establishes the
               "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A
               <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a <c>GZipStream</c> to compress a file into a .gz file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".gz"))
                 {
                     using (Stream compressor = new GZipStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".gz")
                     Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>GZipStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.GZipStream.#ctor(System.IO.Stream,Best.HTTP.Shared.Compression.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the stream should be left open after Deflation
               or Inflation.
             </summary>
            
             <remarks>
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to leave
               the stream open.
             </para>
            
             <para>
               The <see cref="T:Best.HTTP.Shared.Compression.Zlib.CompressionMode"/> (Compress or Decompress) also
               establishes the "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A <c>GZipStream</c>
               with <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             <para>
               The <c>GZipStream</c> will use the default compression level. If you want
               to specify the compression level, see <see cref="M:Best.HTTP.Shared.Compression.Zlib.GZipStream.#ctor(System.IO.Stream,Best.HTTP.Shared.Compression.Zlib.CompressionMode,Best.HTTP.Shared.Compression.Zlib.CompressionLevel,System.Boolean)"/>.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the "captive"
               stream in other places in this documentation.
             </param>
            
             <param name="mode">Indicates whether the GZipStream will compress or decompress.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the base stream to remain open after
               inflation/deflation.
             </param>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.GZipStream.#ctor(System.IO.Stream,Best.HTTP.Shared.Compression.Zlib.CompressionMode,Best.HTTP.Shared.Compression.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and the
               specified <c>CompressionLevel</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to
               leave the stream open.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a <c>GZipStream</c> to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.GZipStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.GZipStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.GZipStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.GZipStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.GZipStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.GZipStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.GZipStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.GZipStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.GZipStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.GZipStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.GZipStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.GZipStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read and decompress data from the source stream.
             </summary>
            
             <remarks>
               With a <c>GZipStream</c>, decompression is done through reading.
             </remarks>
            
             <example>
             <code>
             byte[] working = new byte[WORKING_BUFFER_SIZE];
             using (System.IO.Stream input = System.IO.File.OpenRead(_CompressedFile))
             {
                 using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                 {
                     using (var output = System.IO.File.Create(_DecompressedFile))
                     {
                         int n;
                         while ((n= decompressor.Read(working, 0, working.Length)) !=0)
                         {
                             output.Write(working, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
             <param name="buffer">The buffer into which the decompressed data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">irrelevant; it will always throw!</param>
            <param name="origin">irrelevant; it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.GZipStream.SetLength(System.Int64)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">irrelevant; this method will always throw!</param>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.GZipStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
             <para>
               If you wish to use the <c>GZipStream</c> to compress data while writing,
               you can create a <c>GZipStream</c> with <c>CompressionMode.Compress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that <c>GZipStream</c>,
               providing uncompressed data as input.  The data sent to the output stream
               will be the compressed form of the data written.
             </para>
            
             <para>
               A <c>GZipStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not
               both. Writing implies compression.  Reading implies decompression.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="T:Best.HTTP.Shared.Compression.Zlib.FlushType">
            <summary>
            Describes how to flush the current deflate operation.
            </summary>
            <remarks>
            The different FlushType values are useful when using a Deflate in a streaming application.
            </remarks>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.FlushType.None">
            <summary>No flush at all.</summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.FlushType.Partial">
            <summary>Closes the current block, but doesn't flush it to
            the output. Used internally only in hypothetical
            scenarios.  This was supposed to be removed by Zlib, but it is
            still in use in some edge cases.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.FlushType.Sync">
            <summary>
            Use this during compression to specify that all pending output should be
            flushed to the output buffer and the output should be aligned on a byte
            boundary.  You might use this in a streaming communication scenario, so that
            the decompressor can get all input data available so far.  When using this
            with a ZlibCodec, <c>AvailableBytesIn</c> will be zero after the call if
            enough output space has been provided before the call.  Flushing will
            degrade compression and so it should be used only when necessary.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.FlushType.Full">
            <summary>
            Use this during compression to specify that all output should be flushed, as
            with <c>FlushType.Sync</c>, but also, the compression state should be reset
            so that decompression can restart from this point if previous compressed
            data has been damaged or if random access is desired.  Using
            <c>FlushType.Full</c> too often can significantly degrade the compression.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.FlushType.Finish">
            <summary>Signals the end of the compression/decompression stream.</summary>
        </member>
        <member name="T:Best.HTTP.Shared.Compression.Zlib.CompressionLevel">
            <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionLevel.None">
            <summary>
            None means that the data will be simply stored, with no change at all.
            If you are producing ZIPs for use on Mac OSX, be aware that archives produced with CompressionLevel.None
            cannot be opened with the default zip reader. Use a different CompressionLevel.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionLevel.Level0">
            <summary>
            Same as None.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionLevel.BestSpeed">
            <summary>
            The fastest but least effective compression.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionLevel.Level1">
            <summary>
            A synonym for BestSpeed.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionLevel.Level2">
            <summary>
            A little slower, but better, than level 1.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionLevel.Level3">
            <summary>
            A little slower, but better, than level 2.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionLevel.Level4">
            <summary>
            A little slower, but better, than level 3.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionLevel.Level5">
            <summary>
            A little slower than level 4, but with better compression.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionLevel.Default">
            <summary>
            The default compression level, with a good balance of speed and compression efficiency.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionLevel.Level6">
            <summary>
            A synonym for Default.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionLevel.Level7">
            <summary>
            Pretty good compression!
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionLevel.Level8">
            <summary>
             Better compression than Level7!
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionLevel.BestCompression">
            <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream.
            This is also the slowest compression.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionLevel.Level9">
            <summary>
            A synonym for BestCompression.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.Compression.Zlib.CompressionStrategy">
            <summary>
            Describes options for how the compression algorithm is executed.  Different strategies
            work better on different sorts of data.  The strategy parameter can affect the compression
            ratio and the speed of compression but not the correctness of the compresssion.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionStrategy.Default">
            <summary>
            The default strategy is probably the best for normal data.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionStrategy.Filtered">
            <summary>
            The <c>Filtered</c> strategy is intended to be used most effectively with data produced by a
            filter or predictor.  By this definition, filtered data consists mostly of small
            values with a somewhat random distribution.  In this case, the compression algorithm
            is tuned to compress them better.  The effect of <c>Filtered</c> is to force more Huffman
            coding and less string matching; it is a half-step between <c>Default</c> and <c>HuffmanOnly</c>.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionStrategy.HuffmanOnly">
            <summary>
            Using <c>HuffmanOnly</c> will force the compressor to do Huffman encoding only, with no
            string matching.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.Compression.Zlib.CompressionMode">
            <summary>
            An enum to specify the direction of transcoding - whether to compress or decompress.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionMode.Compress">
            <summary>
            Used to specify that the stream should compress the data.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.CompressionMode.Decompress">
            <summary>
            Used to specify that the stream should decompress the data.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.Compression.Zlib.ZlibException">
            <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibException.#ctor">
            <summary>
            The ZlibException class captures exception information generated
            by the Zlib library.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibException.#ctor(System.String)">
            <summary>
            This ctor collects a message attached to the exception.
            </summary>
            <param name="s">the message for the exception.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.SharedUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
             <summary>
               Reads a number of characters from the current source TextReader and writes
               the data to the target array at the specified index.
             </summary>
            
             <param name="sourceTextReader">The source TextReader to read from</param>
             <param name="target">Contains the array of characteres read from the source TextReader.</param>
             <param name="start">The starting index of the target array.</param>
             <param name="count">The maximum number of characters to read from the source TextReader.</param>
            
             <returns>
               The number of characters read. The number will be less than or equal to
               count depending on the data available in the source TextReader. Returns -1
               if the end of the stream is reached.
             </returns>
        </member>
        <member name="T:Best.HTTP.Shared.Compression.Zlib.Adler">
             <summary>
             Computes an Adler-32 checksum.
             </summary>
             <remarks>
             The Adler checksum is similar to a CRC checksum, but faster to compute, though less
             reliable.  It is used in producing RFC1950 compressed streams.  The Adler checksum
             is a required part of the "ZLIB" standard.  Applications will almost never need to
             use this class directly.
             </remarks>
            
             <exclude/>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.Adler.Adler32(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calculates the Adler32 checksum.
            </summary>
            <remarks>
              <para>
                This is used within ZLIB.  You probably don't need to use this directly.
              </para>
            </remarks>
            <example>
               To compute an Adler32 checksum on a byte array:
             <code>
               var adler = Adler.Adler32(0, null, 0, 0);
               adler = Adler.Adler32(adler, buffer, index, length);
             </code>
            </example>
        </member>
        <member name="T:Best.HTTP.Shared.Compression.Zlib.ZlibCodec">
             <summary>
             Encoder and Decoder for ZLIB and DEFLATE (IETF RFC1950 and RFC1951).
             </summary>
            
             <remarks>
             This class compresses and decompresses data according to the Deflate algorithm
             and optionally, the ZLIB format, as documented in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see> and <see
             href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951 - DEFLATE</see>.
             </remarks>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.InputBuffer">
            <summary>
            The buffer from which data is taken.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.NextIn">
            <summary>
            An index into the InputBuffer array, indicating where to start reading. 
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.AvailableBytesIn">
            <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
            <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.TotalBytesIn">
            <summary>
            Total number of bytes read so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.OutputBuffer">
            <summary>
            Buffer to store output data.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.NextOut">
            <summary>
            An index into the OutputBuffer array, indicating where to start writing. 
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.AvailableBytesOut">
            <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
            <remarks>
            Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.TotalBytesOut">
            <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.Message">
            <summary>
            used for diagnostics, when something goes wrong!
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.CompressLevel">
            <summary>
            The compression level to use in this codec.  Useful only in compression mode.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.WindowBits">
            <summary>
            The number of Window Bits to use.  
            </summary>
            <remarks>
            This gauges the size of the sliding window, and hence the 
            compression effectiveness as well as memory consumption. It's best to just leave this 
            setting alone if you don't know what it is.  The maximum value is 15 bits, which implies
            a 32k window.  
            </remarks>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.Strategy">
            <summary>
            The compression strategy to use.
            </summary>
            <remarks>
            This is only effective in compression.  The theory offered by ZLIB is that different
            strategies could potentially produce significant differences in compression behavior
            for different data sets.  Unfortunately I don't have any good recommendations for how
            to set it differently.  When I tested changing the strategy I got minimally different
            compression performance. It's best to leave this property alone if you don't have a
            good feel for it.  Or, you may want to produce a test harness that runs through the
            different strategy options and evaluates them on different file types. If you do that,
            let me know your results.
            </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.Adler32">
            <summary>
            The Adler32 checksum on the data transferred through the codec so far. You probably don't need to look at this.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.#ctor">
            <summary>
            Create a ZlibCodec.
            </summary>
            <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.#ctor(Best.HTTP.Shared.Compression.Zlib.CompressionMode)">
            <summary>
            Create a ZlibCodec that either compresses or decompresses.
            </summary>
            <param name="mode">
            Indicates whether the codec should compress (deflate) or decompress (inflate).
            </param>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.InitializeInflate">
            <summary>
            Initialize the inflation state. 
            </summary>
            <remarks>
            It is not necessary to call this before using the ZlibCodec to inflate data; 
            It is implicitly called when you call the constructor.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.InitializeInflate(System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to
             govern the handling of RFC1950 header bytes.
             </summary>
            
             <remarks>
             By default, the ZLIB header defined in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</see> is expected.  If
             you want to read a zlib stream you should specify true for
             expectRfc1950Header.  If you have a deflate stream, you will want to specify
             false. It is only necessary to invoke this initializer explicitly if you
             want to specify false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte
             pair when reading the stream of data to be inflated.</param>
            
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.InitializeInflate(System.Int32)">
            <summary>
            Initialize the ZlibCodec for inflation, with the specified number of window bits. 
            </summary>
            <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to govern the handling of
             RFC1950 header bytes. 
             </summary>
            
             <remarks>
             If you want to read a zlib stream you should specify true for
             expectRfc1950Header. In this case, the library will expect to find a ZLIB
             header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
             1950</see>, in the compressed stream.  If you will be reading a DEFLATE or
             GZIP stream, which does not have such a header, you will want to specify
             false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
             the stream of data to be inflated.</param>
             <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
             then you shouldn't be calling this initializer.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.Inflate(Best.HTTP.Shared.Compression.Zlib.FlushType)">
             <summary>
             Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
             </summary>
             <remarks>
             You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
             AvailableBytesOut  before calling this method.
             </remarks>
             <example>
             <code>
             private void InflateBuffer()
             {
                 int bufferSize = 1024;
                 byte[] buffer = new byte[bufferSize];
                 ZlibCodec decompressor = new ZlibCodec();
             
                 Console.WriteLine("\n============================================");
                 Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
                 MemoryStream ms = new MemoryStream(DecompressedBytes);
             
                 int rc = decompressor.InitializeInflate();
             
                 decompressor.InputBuffer = CompressedBytes;
                 decompressor.NextIn = 0;
                 decompressor.AvailableBytesIn = CompressedBytes.Length;
             
                 decompressor.OutputBuffer = buffer;
             
                 // pass 1: inflate 
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.None);
             
                     if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 // pass 2: finish and flush
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.Finish);
             
                     if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
                         ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 decompressor.EndInflate();
             }
            
             </code>
             </example>
             <param name="flush">The flush to use when inflating.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.EndInflate">
            <summary>
            Ends an inflation session. 
            </summary>
            <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.SyncInflate">
            <summary>
            I don't know what this does!
            </summary>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.InitializeDeflate">
            <summary>
            Initialize the ZlibCodec for deflation operation.
            </summary>
            <remarks>
            The codec will use the MAX window bits and the default level of compression.
            </remarks>
            <example>
            <code>
             int bufferSize = 40000;
             byte[] CompressedBytes = new byte[bufferSize];
             byte[] DecompressedBytes = new byte[bufferSize];
             
             ZlibCodec compressor = new ZlibCodec();
             
             compressor.InitializeDeflate(CompressionLevel.Default);
             
             compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
             compressor.NextIn = 0;
             compressor.AvailableBytesIn = compressor.InputBuffer.Length;
             
             compressor.OutputBuffer = CompressedBytes;
             compressor.NextOut = 0;
             compressor.AvailableBytesOut = CompressedBytes.Length;
             
             while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
             {
               compressor.Deflate(FlushType.None);
             }
             
             while (true)
             {
               int rc= compressor.Deflate(FlushType.Finish);
               if (rc == ZlibConstants.Z_STREAM_END) break;
             }
             
             compressor.EndDeflate();
              
            </code>
            </example>
            <returns>Z_OK if all goes well. You generally don't need to check the return code.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.InitializeDeflate(Best.HTTP.Shared.Compression.Zlib.CompressionLevel)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified
            CompressionLevel.  It will emit a ZLIB stream as it compresses.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.InitializeDeflate(Best.HTTP.Shared.Compression.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified CompressionLevel.
            If you want to generate a zlib stream, you should specify true for
            wantRfc1950Header. In this case, the library will emit a ZLIB
            header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
            1950</see>, in the compressed stream.  
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.InitializeDeflate(Best.HTTP.Shared.Compression.Zlib.CompressionLevel,System.Int32)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the specified number of window bits. 
            </summary>
            <remarks>
            The codec will use the specified number of window bits and the specified CompressionLevel.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.InitializeDeflate(Best.HTTP.Shared.Compression.Zlib.CompressionLevel,System.Int32,System.Boolean)">
             <summary>
             Initialize the ZlibCodec for deflation operation, using the specified
             CompressionLevel, the specified number of window bits, and the explicit flag
             governing whether to emit an RFC1950 header byte pair.
             </summary>
            
             <param name="level">The compression level for the codec.</param>
             <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
             <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
             <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.Deflate(Best.HTTP.Shared.Compression.Zlib.FlushType)">
            <summary>
            Deflate one batch of data.
            </summary>
            <remarks>
            You must have set InputBuffer and OutputBuffer before calling this method.
            </remarks>
            <example>
            <code>
            private void DeflateBuffer(CompressionLevel level)
            {
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                ZlibCodec compressor = new ZlibCodec();
            
                Console.WriteLine("\n============================================");
                Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
                MemoryStream ms = new MemoryStream();
            
                int rc = compressor.InitializeDeflate(level);
            
                compressor.InputBuffer = UncompressedBytes;
                compressor.NextIn = 0;
                compressor.AvailableBytesIn = UncompressedBytes.Length;
            
                compressor.OutputBuffer = buffer;
            
                // pass 1: deflate 
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.None);
            
                    if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                        throw new Exception("deflating: " + compressor.Message);
            
                    ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                // pass 2: finish and flush
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.Finish);
            
                    if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                        throw new Exception("deflating: " + compressor.Message);
            
                    if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
                        ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                compressor.EndDeflate();
            
                ms.Seek(0, SeekOrigin.Begin);
                CompressedBytes = new byte[compressor.TotalBytesOut];
                ms.Read(CompressedBytes, 0, CompressedBytes.Length);
            }
            </code>
            </example>
            <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.EndDeflate">
            <summary>
            End a deflation session.
            </summary>
            <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.ResetDeflate">
            <summary>
            Reset a codec for another deflation session.
            </summary>
            <remarks>
            Call this to reset the deflation state.  For example if a thread is deflating
            non-consecutive blocks, you can call Reset() after the Deflate(Sync) of the first
            block and before the next Deflate(None) of the second block.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.SetDeflateParams(Best.HTTP.Shared.Compression.Zlib.CompressionLevel,Best.HTTP.Shared.Compression.Zlib.CompressionStrategy)">
            <summary>
            Set the CompressionStrategy and CompressionLevel for a deflation session.
            </summary>
            <param name="level">the level of compression to use.</param>
            <param name="strategy">the strategy to use for compression.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZlibCodec.SetDictionary(System.Byte[])">
            <summary>
            Set the dictionary to be used for either Inflation or Deflation.
            </summary>
            <param name="dictionary">The dictionary bytes to use.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="T:Best.HTTP.Shared.Compression.Zlib.ZlibConstants">
            <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibConstants.WindowBitsMax">
            <summary>
            The maximum number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibConstants.WindowBitsDefault">
            <summary>
            The default number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibConstants.Z_OK">
            <summary>
            indicates everything is A-OK
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibConstants.Z_STREAM_END">
            <summary>
            Indicates that the last operation reached the end of the stream.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibConstants.Z_NEED_DICT">
            <summary>
            The operation ended in need of a dictionary. 
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibConstants.Z_STREAM_ERROR">
            <summary>
            There was an error with the stream - not enough data, not open and readable, etc.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibConstants.Z_DATA_ERROR">
            <summary>
            There was an error with the data - not enough data, bad data, etc.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibConstants.Z_BUF_ERROR">
            <summary>
            There was an error with the working buffer.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibConstants.WorkingBufferSizeDefault">
            <summary>
            The size of the working buffer used in the ZlibCodec class. Defaults to 8192 bytes.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Compression.Zlib.ZlibConstants.WorkingBufferSizeMin">
            <summary>
            The minimum size of the working buffer used in the ZlibCodec class.  Currently it is 128 bytes.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Compression.Zlib.ZTree.DistanceCode(System.Int32)">
            <summary>
            Map from a distance to a distance code.
            </summary>
            <remarks> 
            No side effects. _dist_code[256] and _dist_code[257] are never used.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.Databases.Database`4.FromFirstMetadataIndex(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Loads the first content from the metadata indexes.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Databases.Database`4.FromMetadataIndex(System.Int32)">
            <summary>
            Loads the content from the metadata index.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Databases.Database`4.FromMetadatas(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Loads all content from the metadatas.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Databases.Database`4.FromMetadataIndexes(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Loads all content from the metadata indexes.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.Databases.DiskManager`1.CacheSize">
            <summary>
            Sum size of the cached contents
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.Databases.Indexing.NoAllocList`1">
            <summary>
            Implements most common list functions. With best case (no or only one item) it doesn't do any allocation.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Databases.Indexing.Node`2.Depth">
            <summary>
            Depth of the node.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.Databases.Indexing.Node`2.BalanceFactor">
            <summary>
            Difference between LeftDepth and RightDepth.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.Databases.Indexing.Node`2.LeftDepth">
            <summary>
            Left node's Depth, or -1 if it's null.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.Databases.Indexing.Node`2.RightDepth">
            <summary>
            Right node's Depth, or -1 if it's null.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Databases.Indexing.AVLTree`2.RemoveNode(Best.HTTP.Shared.Databases.Indexing.Node{`0,`1})">
            <summary>
            Removes node and reparent any child it has.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Databases.IndexingService`2.Index(`1)">
            <summary>
            Index newly added metadata
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Databases.IndexingService`2.Remove(`1)">
            <summary>
            Remove metadata from all indexes.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Databases.IndexingService`2.Clear">
            <summary>
            Clear all indexes
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Databases.IndexingService`2.GetOptimizedIndexes">
            <summary>
            Get indexes in an optimized order. This is usually one of the indexes' WalkHorizontal() call.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Databases.MetadataService`2.CreateFrom(System.IO.Stream)">
            <summary>
            Called when metadata loaded from file
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Databases.MetadataService`2.CreateDefault(`1,System.Int32,System.Int32,System.Action{`1,`0})">
            <summary>
            Called by a concrete MetadataService implementation to create a new metadata
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Extensions.Extensions.AsciiToString(System.Byte[])">
            <summary>
            On WP8 platform there are no ASCII encoding.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Extensions.Extensions.GetASCIIBytes(System.String)">
            <summary>
            On WP8 platform there are no ASCII encoding.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Extensions.Extensions.IsHostIsAnIPAddress(System.Uri)">
            <summary>
            Returns true if the Uri's host is a valid IPv4 or IPv6 address.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Extensions.Extensions.IsIpV4AddressValid(System.String)">
            <summary>
            Validates an IPv4 address.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Extensions.Extensions.IsIpV6AddressValid(System.String)">
            <summary>
            Validates an IPv6 address.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Extensions.Extensions.ReadBuffer(System.IO.Stream,System.Byte[])">
            <summary>
            Will fill the entire buffer from the stream. Will throw an exception when the underlying stream is closed.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.Extensions.HeaderParser">
            <summary>
            Will parse a comma-separeted header value
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.Extensions.HeaderValue">
            <summary>
            Used in string parsers. Its Value is optional.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.Extensions.HeartbeatManager">
            <summary>
            A manager class that can handle subscribing and unsubscribeing in the same update.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.Extensions.KeyValuePairList">
            <summary>
            Base class for specialized parsers
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Extensions.TimerData.CreateNew">
            <summary>
            Create a new TimerData but the Created field will be set to the current time.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.HTTPManager">
            <summary>
            Global entry point to access and manage main services of the plugin.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.HTTPManager.#cctor">
            <summary>
            Static constructor. Setup default values.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.HTTPManager.OnSetupFinished">
            <summary>
            Delegate for the setup finished event.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.HTTPManager.PerHostSettings">
            <summary>
            Instance of the per-host settings manager.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.HTTPManager.CurrentFrameDateTime">
            <summary>
            Cached DateTime value for cases where high resolution isn't needed.
            </summary>
            <remarks>Warning!! It must be used only on the main update thread!</remarks>
        </member>
        <member name="P:Best.HTTP.Shared.HTTPManager.RootSaveFolderProvider">
            <summary>
            By default the plugin will save all cache and cookie data under the path returned by Application.persistentDataPath.
            You can assign a function to this delegate to return a custom root path to define a new path.
            <remarks>This delegate will be called on a non Unity thread!</remarks>
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.HTTPManager.Proxy">
            <summary>
            The global, default proxy for all HTTPRequests. The HTTPRequest's Proxy still can be changed per-request. Default value is null.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.HTTPManager.Heartbeats">
            <summary>
            Heartbeat manager to use less threads in the plugin. The heartbeat updates are called from the OnUpdate function.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.HTTPManager.Logger">
            <summary>
            A basic Best.HTTP.Logger.ILogger implementation to be able to log intelligently additional informations about the plugin's internal mechanism.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.HTTPManager.IOService">
            <summary>
            An IIOService implementation to handle filesystem operations.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.HTTPManager.UserAgent">
            <summary>
            User-agent string that will be sent with each requests.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.HTTPManager.IsQuitting">
            <summary>
            It's true if the application is quitting and the plugin is shutting down itself.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.HTTPManager.LocalCache">
            <summary>
            The local content cache, maintained by the plugin. When set to a non-null value, Maintain called immediately on the cache.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.HTTPManager.Setup">
            <summary>
            Initializes the HTTPManager with default settings. This method should be called on Unity's main thread before using the HTTP plugin. By default it gets called by <see cref="T:Best.HTTP.Shared.HTTPUpdateDelegator"/>.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.HTTPManager.GetRootSaveFolder">
            <summary>
            Will return where the various caches should be saved.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.HTTPManager.OnUpdate">
            <summary>
            Updates the HTTPManager. This method should be called regularly from a Unity event (e.g., Update, LateUpdate).
            It processes various events and callbacks and manages internal tasks.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.HTTPManager.OnQuit">
            <summary>
            Shuts down the HTTPManager and performs cleanup operations. This method should be called when the application is quitting.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.HTTPManager.AbortAll">
            <summary>
            Aborts all ongoing HTTP requests and performs an immediate shutdown of the HTTPManager.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.ThreadingMode">
            <summary>
            Threading mode the plugin will use to call HTTPManager.OnUpdate().
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.ThreadingMode.UnityUpdate">
            <summary>
            HTTPManager.OnUpdate() is called from the HTTPUpdateDelegator's Update functions (Unity's main thread).
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.ThreadingMode.Threaded">
            <summary>
            The plugin starts a dedicated thread to call HTTPManager.OnUpdate() periodically.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.ThreadingMode.None">
            <summary>
            HTTPManager.OnUpdate() will not be called automatically.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.HTTPUpdateDelegator">
            <summary>
            Will route some U3D calls to the HTTPManager.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.HTTPUpdateDelegator.Instance">
            <summary>
            The singleton instance of the HTTPUpdateDelegator
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.HTTPUpdateDelegator.IsCreated">
            <summary>
            True, if the Instance property should hold a valid value.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.HTTPUpdateDelegator.IsThreadRunning">
            <summary>
            It's true if the dispatch thread running.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.HTTPUpdateDelegator.CurrentThreadingMode">
            <summary>
            The current threading mode the plugin is in.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.HTTPUpdateDelegator.ThreadFrequencyInMS">
            <summary>
            How much time the plugin should wait between two update call. Its default value 100 ms.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.HTTPUpdateDelegator.OnBeforeApplicationQuit">
            <summary>
            Called in the OnApplicationQuit function. If this function returns False, the plugin will not start to
            shut down itself.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.HTTPUpdateDelegator.OnApplicationForegroundStateChanged">
            <summary>
            Called when the Unity application's foreground state changed.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.HTTPUpdateDelegator.CheckInstance">
            <summary>
            Will create the HTTPUpdateDelegator instance and set it up.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.HTTPUpdateDelegator.IsMainThread">
            <summary>
            Return true if the call happens on the Unity main thread. Setup must be called before to save the thread id!
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.HTTPUpdateDelegator.SetThreadingMode(Best.HTTP.Shared.ThreadingMode)">
            <summary>
            Set directly the threading mode to use.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.HTTPUpdateDelegator.SwapThreadingMode">
            <summary>
            Swaps threading mode between Unity's Update function or a distinct thread.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.HTTPUpdateDelegator.PingUpdateThread">
            <summary>
            Pings the update thread to call HTTPManager.OnUpdate immediately.
            </summary>
            <remarks>Works only when the current threading mode is Threaded!</remarks>
        </member>
        <member name="T:Best.HTTP.Shared.Logger.FileOutput">
            <summary>
            Provides an implementation of <see cref="T:Best.HTTP.Shared.Logger.ILogOutput"/> that writes log messages to a file.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.Logger.FileOutput.AcceptColor">
            <summary>
            Gets a value indicating whether this log output accepts color codes. Always returns <c>false</c>.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.FileOutput.#ctor(System.String)">
            <summary>
            Initializes a new instance of the FileOutput class with the specified file name.
            </summary>
            <param name="fileName">The name of the file to write log messages to.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.FileOutput.Write(Best.HTTP.Shared.Logger.Loglevels,System.String)">
            <summary>
            Writes a log message to the file.
            </summary>
            <param name="level">The log level of the message.</param>
            <param name="logEntry">The log message to write.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.FileOutput.Flush">
            <summary>
            Flushes any buffered log messages to the file.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.FileOutput.Dispose">
            <summary>
            Releases any resources used by the FileOutput instance.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.Logger.Loglevels">
            <summary>
            Available logging levels.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Logger.Loglevels.All">
            <summary>
            All message will be logged.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Logger.Loglevels.Information">
            <summary>
            Only Informations and above will be logged.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Logger.Loglevels.Warning">
            <summary>
            Only Warnings and above will be logged.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Logger.Loglevels.Error">
            <summary>
            Only Errors and above will be logged.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Logger.Loglevels.Exception">
            <summary>
            Only Exceptions will be logged.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.Logger.Loglevels.None">
            <summary>
            No logging will occur.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.Logger.ILogOutput">
            <summary>
            Represents an output target for log messages.
            </summary>
            <remarks>
            <para>
            This interface defines methods for writing log messages to an output target.
            Implementations of this interface are used to configure where log messages
            should be written.
            </para>
            <para>
            Two of its out-of-the-box implementations are
            <list type="bullet">
                <item><description><see cref="T:Best.HTTP.Shared.Logger.UnityOutput">UnityOutput</see></description></item>
                <item><description><see cref="T:Best.HTTP.Shared.Logger.FileOutput">FileOutput</see></description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.Logger.ILogOutput.AcceptColor">
            <summary>
            Gets a value indicating whether the log output supports colored text.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.ILogOutput.Write(Best.HTTP.Shared.Logger.Loglevels,System.String)">
            <summary>
            Writes a log entry to the output.
            </summary>
            <param name="level">The logging level of the entry.</param>
            <param name="logEntry">The log message to write.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.ILogOutput.Flush">
            <summary>
            Flushes any buffered log entries to the output.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.Logger.ILogger">
            <summary>
            Represents a logger for recording log messages.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.Logger.ILogger.Level">
            <summary>
            Gets or sets the minimum severity level for logging.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.Logger.ILogger.Output">
            <summary>
            Gets or sets the output target for log messages.
            </summary>
            <value>
            The <see cref="T:Best.HTTP.Shared.Logger.ILogOutput"/> instance used to write log messages.
            </value>
        </member>
        <member name="P:Best.HTTP.Shared.Logger.ILogger.IsDiagnostic">
            <summary>
            Gets a value indicating whether diagnostic logging is enabled.
            </summary>
            <remarks>
            Diagnostic logging is enabled when <see cref="P:Best.HTTP.Shared.Logger.ILogger.Level"/> is set to <see cref="F:Best.HTTP.Shared.Logger.Loglevels.All"/>.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.ILogger.Verbose(System.String,System.String,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Logs a message with <see cref="F:Best.HTTP.Shared.Logger.Loglevels.All"/> level.
            </summary>
            <param name="division">The division or category of the log message.</param>
            <param name="msg">The verbose log message.</param>
            <param name="context">The optional <see cref="T:Best.HTTP.Shared.Logger.LoggingContext"/> for additional context.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.ILogger.Information(System.String,System.String,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Logs a message with <see cref="F:Best.HTTP.Shared.Logger.Loglevels.Information"/> level.
            </summary>
            <param name="division">The division or category of the log message.</param>
            <param name="msg">The verbose log message.</param>
            <param name="context">The optional <see cref="T:Best.HTTP.Shared.Logger.LoggingContext"/> for additional context.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.ILogger.Warning(System.String,System.String,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Logs a message with <see cref="F:Best.HTTP.Shared.Logger.Loglevels.Warning"/> level.
            </summary>
            <param name="division">The division or category of the log message.</param>
            <param name="msg">The verbose log message.</param>
            <param name="context">The optional <see cref="T:Best.HTTP.Shared.Logger.LoggingContext"/> for additional context.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.ILogger.Error(System.String,System.String,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Logs a message with <see cref="F:Best.HTTP.Shared.Logger.Loglevels.Error"/> level.
            </summary>
            <param name="division">The division or category of the log message.</param>
            <param name="msg">The verbose log message.</param>
            <param name="context">The optional <see cref="T:Best.HTTP.Shared.Logger.LoggingContext"/> for additional context.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.ILogger.Exception(System.String,System.String,System.Exception,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Logs a message with <see cref="F:Best.HTTP.Shared.Logger.Loglevels.Exception"/> level.
            </summary>
            <param name="division">The division or category of the log message.</param>
            <param name="msg">The verbose log message.</param>
            <param name="context">The optional <see cref="T:Best.HTTP.Shared.Logger.LoggingContext"/> for additional context.</param>
        </member>
        <member name="T:Best.HTTP.Shared.Logger.LoggingContext">
            <summary>
            Represents a logging context for categorizing and organizing log messages.
            </summary>
            <remarks>
            The LoggingContext class is used to provide additional context information
            to log messages, allowing for better categorization and organization of log output. It can be
            associated with specific objects or situations to enrich log entries with context-specific data.
            </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.Logger.LoggingContext.Hash">
            <summary>
            Gets the unique hash value of this logging context.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.LoggingContext.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the LoggingContext class associated with the specified object.
            </summary>
            <param name="boundto">The object to associate the context with.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.LoggingContext.Add(System.String,System.Int64)">
            <summary>
            Adds a <c>long</c> value to the logging context.
            </summary>
            <param name="key">The key to associate with the value.</param>
            <param name="value">The <c>long</c> value to add.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.LoggingContext.Add(System.String,System.Boolean)">
            <summary>
            Adds a <c>bool</c> value to the logging context.
            </summary>
            <param name="key">The key to associate with the value.</param>
            <param name="value">The <c>bool</c> value to add.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.LoggingContext.Add(System.String,System.String)">
            <summary>
            Adds a <c>string</c> value to the logging context.
            </summary>
            <param name="key">The key to associate with the value.</param>
            <param name="value">The <c>string</c> value to add.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.LoggingContext.Add(System.String,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Adds a <c>LoggingContext</c> value to the logging context.
            </summary>
            <param name="key">The key to associate with the value.</param>
            <param name="value">The <c>LoggingContext</c> value to add.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.LoggingContext.GetStringField(System.String)">
            <summary>
            Gets the <c>string</c> field with the specified name from the logging context.
            </summary>
            <param name="fieldName">The name of the <c>string</c> field to retrieve.</param>
            <returns>The value of the <c>string</c> field or <c>null</c> if not found.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.LoggingContext.Remove(System.String)">
            <summary>
            Removes a field from the logging context by its key.
            </summary>
            <param name="key">The key of the field to remove.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.LoggingContext.ToJson(System.Text.StringBuilder)">
            <summary>
            Converts the logging context and its associated fields to a JSON string representation.
            </summary>
            <param name="sb">A <see cref="T:System.Text.StringBuilder"/> instance to which the JSON string is appended.</param>
            <remarks>
            This method serializes the logging context and its associated fields into a JSON format
            for structured logging purposes. The resulting JSON string represents the context and its fields, making it
            suitable for inclusion in log entries for better analysis and debugging.
            </remarks>
        </member>
        <member name="T:Best.HTTP.Shared.Logger.UnityOutput">
            <summary>
            Provides an implementation of <see cref="T:Best.HTTP.Shared.Logger.ILogOutput"/> that writes log messages to the Unity Debug Console.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.Logger.UnityOutput.AcceptColor">
            <summary>
            Gets a value indicating whether this log output accepts color codes.
            </summary>
            <remarks>
            This property returns <c>true</c> when running in the Unity Editor and <c>false</c> otherwise.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.UnityOutput.Write(Best.HTTP.Shared.Logger.Loglevels,System.String)">
            <summary>
            Writes a log message to the Unity Debug Console based on the specified log level.
            </summary>
            <param name="level">The log level of the message.</param>
            <param name="logEntry">The log message to write.</param>
        </member>
        <member name="M:Best.HTTP.Shared.Logger.UnityOutput.Best#HTTP#Shared#Logger#ILogOutput#Flush">
            <summary>
            This implementation does nothing.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.FileSystem.FileStreamModes">
            <summary>
            These are the different modes that the plugin want's to use a filestream.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.FileSystem.FileStreamModes.Create">
            <summary>
            Create a new file.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.FileSystem.FileStreamModes.OpenRead">
            <summary>
            Open an existing file for reading.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.FileSystem.FileStreamModes.OpenReadWrite">
            <summary>
            Open or create a file for read and write.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.FileSystem.FileStreamModes.Append">
            <summary>
            Open an existing file for writing to the end.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.FileSystem.IIOService">
            <summary>
            Interface for file-system abstraction.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.FileSystem.IIOService.DirectoryCreate(System.String)">
            <summary>
            Create a directory for the given path.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.FileSystem.IIOService.DirectoryExists(System.String)">
            <summary>
            Return true if the directory exists for the given path.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.FileSystem.IIOService.DirectoryDelete(System.String)">
            <summary>
            Delete the directory.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.FileSystem.IIOService.GetFiles(System.String)">
            <summary>
            Return with the file names for the given path.
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.FileSystem.IIOService.FileDelete(System.String)">
            <summary>
            Delete the file for the given path.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.FileSystem.IIOService.FileExists(System.String)">
            <summary>
            Return true if the file exists on the given path.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.FileSystem.IIOService.CreateFileStream(System.String,Best.HTTP.Shared.PlatformSupport.FileSystem.FileStreamModes)">
            <summary>
            Create a stream that can read and/or write a file on the given path.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.IL2CPP.Option">
            <summary>
            The code generation options available for IL to C++ conversion.
            Enable or disabled these with caution.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.IL2CPP.Option.NullChecks">
             <summary>
             Enable or disable code generation for null checks.
            
             Global null check support is enabled by default when il2cpp.exe
             is launched from the Unity editor.
            
             Disabling this will prevent NullReferenceException exceptions from
             being thrown in generated code. In *most* cases, code that dereferences
             a null pointer will crash then. Sometimes the point where the crash
             happens is later than the location where the null reference check would
             have been emitted though.
             </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.IL2CPP.Option.ArrayBoundsChecks">
             <summary>
             Enable or disable code generation for array bounds checks.
            
             Global array bounds check support is enabled by default when il2cpp.exe
             is launched from the Unity editor.
            
             Disabling this will prevent IndexOutOfRangeException exceptions from
             being thrown in generated code. This will allow reading and writing to
             memory outside of the bounds of an array without any runtime checks.
             Disable this check with extreme caution.
             </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.IL2CPP.Option.DivideByZeroChecks">
             <summary>
             Enable or disable code generation for divide by zero checks.
            
             Global divide by zero check support is disabled by default when il2cpp.exe
             is launched from the Unity editor.
            
             Enabling this will cause DivideByZeroException exceptions to be
             thrown in generated code. Most code doesn't need to handle this
             exception, so it is probably safe to leave it disabled.
             </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.IL2CPP.Il2CppSetOptionAttribute">
             <summary>
             Use this attribute on a class, method, or property to inform the IL2CPP code conversion utility to override the
             global setting for one of a few different runtime checks.
            
             Example:
            
                 [Il2CppSetOption(Option.NullChecks, false)]
                 public static string MethodWithNullChecksDisabled()
                 {
                     var tmp = new Object();
                     return tmp.ToString();
                 }
             </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.IL2CPP.PreserveAttribute">
            <summary>
            https://docs.unity3d.com/Manual/ManagedCodeStripping.html
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Memory.UserModeLock">
            <summary>
            Light-weight user-mode lock for code blocks that has rare contentions and doesn't take a long time to finish.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool">
            <summary>
            The BufferPool is a foundational element of the Best HTTP package, aiming to reduce dynamic memory allocation overheads by reusing byte arrays. The concept is elegantly simple: rather than allocating and deallocating memory for every requirement, byte arrays can be "borrowed" and "returned" within this pool. Once returned, these arrays are retained for subsequent use, minimizing repetitive memory operations.
            <para>While the BufferPool is housed within the Best HTTP package, its benefits are not limited to just HTTP operations. All protocols and packages integrated with or built upon the Best HTTP package utilize and benefit from the BufferPool. This ensures that memory is used efficiently and performance remains optimal across all integrated components.</para>
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool.NoData">
            <summary>
            Represents an empty byte array that can be returned for zero-length requests.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool.IsEnabled">
            <summary>
            Gets or sets a value indicating whether the buffer pooling mechanism is enabled or disabled.
            Disabling will also clear all stored entries.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool.RemoveOlderThan">
            <summary>
            Specifies the duration after which buffer entries, once released back to the pool, are deemed old and will be
            considered for removal in the next maintenance cycle.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool.RunMaintenanceEvery">
            <summary>
            Specifies how frequently the maintenance cycle should run to manage old buffers.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool.MinBufferSize">
            <summary>
            Specifies the minimum buffer size that will be allocated. If a request is made for a size smaller than this and canBeLarger is <c>true</c>, 
            this size will be used.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool.MaxBufferSize">
            <summary>
            Specifies the maximum size of a buffer that the system will consider storing back into the pool.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool.MaxPoolSize">
            <summary>
            Specifies the maximum total size of all stored buffers. When the buffer reach this threshold, new releases will be declined.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool.RemoveEmptyLists">
            <summary>
            Indicates whether to remove buffer stores that don't hold any buffers from the free list.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool.IsDoubleReleaseCheckEnabled">
            <summary>
            If set to <c>true</c>, and a byte array is released back to the pool more than once, an error will be logged.
            </summary>
            <remarks>Error checking is expensive and has a very large overhead! Turn it on with caution!</remarks>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool.Get(System.Int64,System.Boolean,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Fetches a byte array from the pool.
            </summary>
            <remarks>Depending on the `canBeLarger` parameter, the returned buffer may be larger than the requested size!</remarks>
            <param name="size">Requested size of the buffer.</param>
            <param name="canBeLarger">If <c>true</c>, the returned buffer can be larger than the requested size.</param>
            <param name="context">Optional context for logging purposes.</param>
            <returns>A byte array from the pool or a newly allocated one if suitable size is not available.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool.ReleaseBulk(System.Collections.Concurrent.ConcurrentQueue{Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment})">
            <summary>
            Releases a list of buffer segments back to the pool in a bulk operation.
            </summary>
            <param name="segments">List of buffer segments to release.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool.ReleaseBulk(System.Collections.Generic.List{Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment})">
            <summary>
            Releases a list of buffer segments back to the pool in a bulk operation.
            </summary>
            <param name="segments">List of buffer segments to release.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool.Release(System.Byte[])">
            <summary>
            Releases a byte array back to the pool.
            </summary>
            <param name="buffer">Buffer to be released back to the pool.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool.Resize(System.Byte[]@,System.Int32,System.Boolean,System.Boolean,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Resizes a byte array by returning the old one to the pool and fetching (or creating) a new one of the specified size.
            </summary>
            <param name="buffer">Buffer to resize.</param>
            <param name="newSize">New size for the buffer.</param>
            <param name="canBeLarger">If <c>true</c>, the new buffer can be larger than the specified size.</param>
            <param name="clear">If <c>true</c>, the new buffer will be cleared (set to all zeros).</param>
            <param name="context">Optional context for logging purposes.</param>
            <returns>A resized buffer.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool.Clear">
            <summary>
            Clears all stored entries in the buffer pool instantly, releasing memory.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool.Maintain">
            <summary>
            Internal method called by the plugin to remove old, non-used buffers.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment">
            <summary>
            Represents a segment (a continuous section) of a byte array, providing functionalities to 
            work with a portion of the data without copying.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment.Empty">
            <summary>
            Represents an empty buffer segment.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment.Data">
            <summary>
            The underlying data of the buffer segment.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment.Offset">
            <summary>
            The starting offset of the segment within the data.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment.Count">
            <summary>
            The number of bytes in the segment that contain valid data.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the BufferSegment struct.
            </summary>
            <param name="data">The data for the buffer segment.</param>
            <param name="offset">The starting offset of the segment.</param>
            <param name="count">The number of bytes in the segment.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment.AsAutoRelease">
            <summary>
            Converts the buffer segment to an AutoReleaseBuffer to use it in a local using statement.
            </summary>
            <returns>A new AutoReleaseBuffer instance containing the data of the buffer segment.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment.Slice(System.Int32)">
            <summary>
            Creates a new segment starting from the specified offset.
            </summary>
            <remarks>The new segment will reference the same underlying byte[] as the original, without creating a copy of the data.</remarks>
            <param name="newOffset">The starting offset of the new segment.</param>
            <returns>A new buffer segment that references the same underlying data.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment.Slice(System.Int32,System.Int32)">
            <summary>
            Creates a new segment with the specified offset and count.
            </summary>
            <remarks>The new segment will reference the same underlying byte[] as the original, without creating a copy of the data.</remarks>
            <param name="offset">The starting offset of the new segment.</param>
            <param name="count">The number of bytes in the new segment.</param>
            <returns>A new buffer segment that references the same underlying data.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment.CopyTo(System.Byte[])">
            <summary>
            Copyies the buffer's content to the received array.
            </summary>
            <param name="to">The array the data will be copied into.</param>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Memory.BufferStore">
            <summary>
            Private data struct that contains the size - byte arrays mapping. 
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferStore.Size">
            <summary>
            Size/length of the arrays stored in the buffers.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferStore.buffers">
            <summary>
            
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Memory.BufferStore.#ctor(System.Int64,System.Byte[])">
            <summary>
            Create a new store with its first byte[] to store.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Memory.BufferDesc">
            <summary>
            Helper struct for <see cref="T:Best.HTTP.Shared.PlatformSupport.Memory.BufferPool"/>.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferDesc.buffer">
            <summary>
            The actual reference to the stored byte array.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferDesc.released">
            <summary>
            When the buffer is put back to the pool. Based on this value the pool will calculate the age of the buffer.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSQueryResult">
            <summary>
            Represents the result of a DNS query, including the original host name, resolved IP addresses, and any error.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSQueryResult.HostName">
            <summary>
            The host name used in the DNS query.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSQueryResult.Addresses">
            <summary>
            The resolved IP addresses associated with the host name.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSQueryResult.Error">
            <summary>
            Any error that occurred during the DNS query.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSIPAddress">
            <summary>
            Represents an IP address obtained from DNS resolution.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSIPAddress.IPAddress">
            <summary>
            The resolved IP address.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSIPAddress.IsWorkedLastTime">
            <summary>
            Indicates whether this IP address worked during the last connection attempt.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheOptions">
            <summary>
            Represents options for configuring the DNS cache behavior.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheOptions.RefreshAfter">
            <summary>
            The time interval after which DNS cache entries should be refreshed.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheOptions.RemoveAfter">
            <summary>
            The time interval after which DNS cache entries should be removed if not used.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheOptions.CancellationCheckGranularity">
            <summary>
            The granularity of cancellation checks for DNS queries.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheOptions.MaintenanceFrequency">
            <summary>
            The frequency of cache maintenance.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSQueryParameters">
            <summary>
            Represents parameters for a DNS query, including the host name, address, cancellation token, logging context, callback, and tag.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSQueryParameters.Key">
            <summary>
            The hash key associated with the DNS query.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSQueryParameters.Hostname">
            <summary>
            The host name used in the DNS query.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSQueryParameters.Address">
            <summary>
            The URI address used in the DNS query.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSQueryParameters.Token">
            <summary>
            The cancellation token used to cancel the DNS query.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSQueryParameters.Context">
            <summary>
            Optional logging context.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSQueryParameters.Callback">
            <summary>
            The callback to be invoked upon completion of the DNS query.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSQueryParameters.Tag">
            <summary>
            An optional object reference associated with the DNS query.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSQueryParameters.IsPrefetch">
            <summary>
            Indicates whether the DNS query is a prefetch query.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCache">
             <summary>
             The DNSCache class is a static utility that manages DNS caching and queries within the Best HTTP library.
             It helps improve network efficiency by caching DNS query results, reducing the need for redundant DNS resolutions.
             </summary>
             <remarks>
             <para>By utilizing the DNSCache class and its associated features, you can optimize DNS resolution in your network communication, leading to improved performance and reduced latency in your applications.</para>
             <para>
             Its key features include:
             <list type="bullet">
                 <item>
                     <term>Improving Network Efficiency</term>
                     <description>The DNSCache class is designed to enhance network efficiency by caching DNS query results.
                     When your application needs to resolve hostnames to IP addresses for making network requests, the DNSCache stores previously resolved results.
                     This reduces the need for redundant DNS resolutions, making network communication faster and more efficient.
                     </description>
                 </item>
                 
                 <item>
                     <term>DNS Prefetching</term>
                     <description>You can use the DNSCache to initiate DNS prefetch operations.
                     Prefetching allows you to resolve and cache DNS records for hostnames in advance, reducing latency for future network requests.
                     This is particularly useful when you expect to make multiple network requests to the same hostnames, as it helps to avoid DNS resolution delays.
                     </description>
                 </item>
            
                 <item>
                     <term>Marking IP Addresses as Non-Working</term>
                     <description>In cases where a previously resolved IP address is determined to be non-functional (e.g., due to network issues), you can use the DNSCache to report IP addresses as non-working.
                     This information helps the cache make better decisions about which IP addresses to use for future network connections. <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRingmaster"/> gives higher priority for adresses not marked as non-working.
                     </description>
                 </item>
            
                 <item>
                     <term>Clearing the DNS Cache</term>
                     <description>If you need to reset the DNS cache and remove all stored DNS resolutions, you can use the Clear method provided by the DNSCache class.
                     This operation can be useful in scenarios where you want to start with a fresh cache.
                     </description>
                 </item>
            
                 <item>
                     <term>Performing DNS Queries</term>
                     <description>The primary function of the DNSCache class is to perform DNS queries with specified parameters.
                     It resolves DNS records for a given hostname and caches the results. This can be called directly or used internally by the Best HTTP library for resolving hostnames.
                     </description>
                 </item>
            
                 <item>
                     <term>Configuring Cache Behavior</term>
                     <description>You can configure the behavior of the DNS cache using the DNSCacheOptions class.
                     This includes setting refresh intervals for cache entries, defining the granularity of cancellation checks for DNS queries, and specifying the frequency of cache maintenance.
                     </description>
                 </item>
             </list>
             </para>
             </remarks>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCache.Options">
            <summary>
            Options for configuring the DNS cache behavior, including refresh intervals and maintenance frequency.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCache.Prefetch(System.String)">
            <summary>
            Initiates a DNS prefetch operation for the specified host name. DNS prefetching is used to resolve and cache
            DNS records for host names in advance, reducing latency for future network requests.
            </summary>
            <param name="hostName">The host name to prefetch.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCache.ReportAsNonWorking(System.String,System.Net.IPAddress,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Reports an IP address as non-working for the specified host name. In cases where a previously resolved IP address
            is determined to be non-functional, this method updates the cache to mark the IP address as non-working.
            </summary>
            <param name="hostName">The host name associated with the IP address.</param>
            <param name="address">The <see cref="T:System.Net.IPAddress"/> to report as non-working.</param>
            <param name="context">Optional logging context for debugging purposes.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCache.Clear">
            <summary>
            Clears the DNS cache, removing all cached DNS records. This operation can be used to reset the cache
            and remove all stored DNS resolutions.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCache.Query(Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSQueryParameters)">
            <summary>
            Performs a DNS query with the specified parameters. It resolves DNS records for a given host name,
            caching the results to reduce the need for redundant DNS resolutions.
            </summary>
            <param name="parameters">The parameters for the DNS query.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCache.CheckForCanceled(System.DateTime,System.Object)">
            <summary>
            It's plan-b for the case where BeginGetHostAddresses take too long and no reply in time. If the query's Token is canceled it will call the callback if it's still available.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry">
            <summary>
            Represents a cached entry for DNS query results, including resolved IP addresses and metadata.
            </summary>
            <remarks>
            Almost immutable, all changes are done in-class in a thread-safe manner.
            </remarks>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry.Key">
            <summary>
            Gets the 128-bit hash derived from the host name.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry.Host">
            <summary>
            Gets the host name this entry stores the IP addresses for.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry.ResolvedAt">
            <summary>
            Gets the timestamp when the entry was last resolved.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry.LastUsed">
            <summary>
            Gets the timestamp when the entry was last used by calling <see cref="M:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry.GetAddresses"/>.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry._resolvedAddresses">
            <summary>
            Resolved IP addresses. It's private, accesible through the <see cref="M:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry.GetAddresses"/> call only.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry._isRefreshing">
            <summary>
            Flag that is set to <c>true</c> when the cache is refreshing this host.
            </summary>
            <remarks>
            When set to <c>true</c>, <see cref="M:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry.IsStalled(System.DateTime)"/> will always return as non-stalled.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry.#ctor(UnityEngine.Hash128,System.String,System.Int64,System.Collections.Generic.List{Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSIPAddress})">
            <summary>
            Initializes a new instance of the DNSCacheEntry class.
            </summary>
            <param name="key">The 128-bit hash key derived from the host name.</param>
            <param name="host">The host name associated with this entry.</param>
            <param name="resolvedAddresses">The list of <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSIPAddress"/> containing the resolved IP addresses.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry.DeriveWith(System.Collections.Generic.List{Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSIPAddress})">
            <summary>
            Called to clone the entry. The new entry will inherit the last used timestamp.
            </summary>
            <param name="resolvedAddresses">The list of <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSIPAddress"/> containing the resolved IP addresses.</param>
            <returns>A new DNSCacheEntry instance with updated resolved addresses.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry.IsStalled(System.DateTime)">
            <summary>
            Checks if the entry is stalled and needs to be refreshed.
            </summary>
            <param name="now">The current timestamp.</param>
            <returns><c>true</c> if the entry is stalled; otherwise, <c>false</c>.</returns>
            <remarks>
            The entry is considered stalled if it is not currently being refreshed (i.e., <see cref="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry._isRefreshing"/> is false)
            and the time since the last resolution exceeds the refresh interval specified in <see cref="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheOptions.RefreshAfter"/>.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry.IsReadyToRemove(System.DateTime)">
            <summary>
            Checks if the entry is ready to be removed from the cache.
            </summary>
            <param name="now">The current timestamp.</param>
            <returns><c>true</c> if the entry is ready for removal; otherwise, <c>false</c>.</returns>
            <remarks>
            The entry is considered ready for removal if the time since it was last used exceeds the removal interval specified in <see cref="F:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheOptions.RemoveAfter"/>.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry.Refresh">
            <summary>
            Refreshes the entry by initiating a DNS prefetch (by calling <see cref="M:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCache.Prefetch(System.String)"/>) for the associated host name.
            </summary>
            <remarks>
            This method initiates a DNS prefetch operation for the host name associated with this entry.
            DNS prefetching is used to resolve and cache DNS records for host names in advance, reducing latency for future network requests.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry.GetAddresses">
            <summary>
            Gets the resolved IP addresses associated with this entry.
            </summary>
            <returns>An array of <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSIPAddress"/> representing resolved IP addresses.</returns>
            <remarks>
            This method returns the resolved IP addresses associated with this entry and updates the last used timestamp.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSCacheEntry.ReportNonWorking(System.Net.IPAddress,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Reports an IP address as non-working for the specified host name. In cases where a previously resolved IP address
            is determined to be non-functional, this method updates the cache to mark the IP address as non-working.
            </summary>
            <param name="nonWorking">The non-working IP address to report.</param>
            <param name="context">Optional logging context for debugging purposes.</param>
            <remarks>
            This method is used to report an IP address associated with a host name as non-working.
            When a previously resolved IP address is determined to be non-functional, this method updates the cache to mark the IP address as non-working.
            It can be useful in situations where network errors or issues with specific IP addresses need to be recorded and managed.
            </remarks>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IPeekableContentProvider">
            <summary>
            The IPeekableContentProvider interface defines an abstraction for providing content to an <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer"/> with the ability to peek at the content without consuming it.
            It is an essential part of content streaming over a TCP connection.
            </summary>
            <remarks>
            <para>
            Key Functions of IPeekableContentProvider:
            </para>
            <list type="bullet">
            <item>
            <term>Content Provision</term><description>It provides content to an associated <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer"/> without immediately consuming the content. This allows the consumer to examine the data before processing.
            </description></item>
            <item>
            <term>Two-Way Binding</term><description>Supports establishing a two-way binding between the <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IPeekableContentProvider"/> and an <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer"/>, enabling bidirectional communication between the provider and consumer.
            </description></item>
            <item>
            <term>Unbinding</term><description>Provides methods for unbinding a content consumer, terminating the association between the provider and consumer.
            </description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IPeekableContentProvider.Peekable">
            <summary>
            Gets the <see cref="T:Best.HTTP.Shared.Streams.PeekableContentProviderStream"/> associated with this content provider, which allows peeking at the content without consuming it.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IPeekableContentProvider.Consumer">
            <summary>
            Gets the <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer"/> implementor that will be notified through <see cref="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer.OnContent"/> calls when new data is available in the TCPStreamer.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IPeekableContentProvider.SetTwoWayBinding(Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer)">
            <summary>
            Sets up a two-way binding between this content provider and an <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer"/>. This enables bidirectional communication between the provider and consumer.
            </summary>
            <param name="consumer">The <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer"/> to bind to.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IPeekableContentProvider.Unbind">
            <summary>
            Unbinds the content provider from its associated content consumer. This terminates the association between the provider and consumer.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IPeekableContentProvider.UnbindIf(Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer)">
            <summary>
            Unbinds the content provider from a specific content consumer if it is currently bound to that consumer.
            </summary>
            <param name="consumer">The <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer"/> to unbind from.</param>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer">
            <summary>
            The IContentConsumer interface represents a consumer of content provided by an <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IPeekableContentProvider"/>. It defines methods for handling received content and connection-related events.
            </summary>
            <remarks>
            <para>
            Key Functions of IContentConsumer:
            </para>
            <list type="bullet">
            <item>
            <term>Content Handling</term><description>Defines methods for handling incoming content, allowing consumers to process data as it becomes available.
            </description></item>
            <item>
            <term>Connection Management</term><description>Provides event methods to notify consumers of connection closure and error conditions, facilitating graceful handling of connection-related issues.
            </description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer.ContentProvider">
            <summary>
            Gets the <see cref="T:Best.HTTP.Shared.Streams.PeekableContentProviderStream"/> associated with this content consumer, which allows access to incoming content.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer.SetBinding(Best.HTTP.Shared.Streams.PeekableContentProviderStream)">
            <summary>
            This method should not be called directly. It is used internally to set the binding between the content consumer and its associated content provider.
            </summary>
            <param name="contentProvider">The <see cref="T:Best.HTTP.Shared.Streams.PeekableContentProviderStream"/> to bind to.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer.UnsetBinding">
            <summary>
            This method should not be called directly. It is used internally to unset the binding between the content consumer and its associated content provider.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer.OnContent">
            <summary>
            Called when new content is available from the associated content provider.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer.OnConnectionClosed">
            <summary>
            Called when the connection is closed by the remote peer. It notifies the content consumer about the connection closure.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer.OnError(System.Exception)">
            <summary>
            Called when an error occurs during content processing or connection handling. It provides the exception that caused the error.
            </summary>
            <param name="ex">The <see cref="T:System.Exception"/> that represents the error condition.</param>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.NegotiationSteps">
            <summary>
            Represents the different steps of the negotiation process.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.INegotiationPeer">
            <summary>
            Interface for a peer that participates in the negotiation process.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.INegotiationPeer.GetSupportedProtocolNames(Best.HTTP.Shared.PlatformSupport.Network.Tcp.Negotiator)">
            <summary>
            Gets the list of supported ALPN protocol names for negotiation.
            </summary>
            <param name="negotiator">The negotiation instance.</param>
            <returns>A list of supported ALPN protocol names.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.INegotiationPeer.MustStopAdvancingToNextStep(Best.HTTP.Shared.PlatformSupport.Network.Tcp.Negotiator,Best.HTTP.Shared.PlatformSupport.Network.Tcp.NegotiationSteps,Best.HTTP.Shared.PlatformSupport.Network.Tcp.NegotiationSteps,System.Exception)">
            <summary>
            Indicates whether the negotiation process must stop advancing to the next step.
            </summary>
            <param name="negotiator">The negotiation instance.</param>
            <param name="finishedStep">The step that has just finished.</param>
            <param name="nextStep">The next step in the negotiation process.</param>
            <param name="error">An optional error encountered during negotiation.</param>
            <returns><c>true</c> if negotiation must stop for any reason advancing to the next step; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.INegotiationPeer.EvaluateProxyNegotiationFailure(Best.HTTP.Shared.PlatformSupport.Network.Tcp.Negotiator,System.Exception,System.Boolean)">
            <summary>
            Handles the evaluation of a proxy negotiation failure.
            </summary>
            <param name="negotiator">The negotiation instance.</param>
            <param name="error">The error encountered during proxy negotiation.</param>
            <param name="resendForAuthentication">Indicates whether to resend for authentication.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.INegotiationPeer.OnNegotiationFailed(Best.HTTP.Shared.PlatformSupport.Network.Tcp.Negotiator,System.Exception)">
            <summary>
            Handles the negotiation failure.
            </summary>
            <param name="negotiator">The negotiation instance.</param>
            <param name="error">The error encountered during negotiation.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.INegotiationPeer.OnNegotiationFinished(Best.HTTP.Shared.PlatformSupport.Network.Tcp.Negotiator,Best.HTTP.Shared.Streams.PeekableContentProviderStream,Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer,System.String)">
            <summary>
            Handles the successful completion of negotiation.
            </summary>
            <param name="negotiator">The negotiation instance.</param>
            <param name="stream">The negotiated stream.</param>
            <param name="streamer">The TCP streamer.</param>
            <param name="negotiatedProtocol">The negotiated protocol.</param>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.NegotiationParameters">
            <summary>
            Represents the parameters for a negotiation.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.NegotiationParameters.proxy">
            <summary>
            Optional proxy instance must be used during negotiation.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.NegotiationParameters.createProxyTunel">
            <summary>
            Sets a value indicating whether to create a proxy tunnel.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.NegotiationParameters.targetUri">
            <summary>
            Sets the target URI for negotiation.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.NegotiationParameters.negotiateTLS">
            <summary>
            Sets a value indicating whether to negotiate TLS.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.NegotiationParameters.token">
            <summary>
            Sets the cancellation token for negotiation.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.NegotiationParameters.hostSettings">
            <summary>
            Sets the <see cref="T:Best.HTTP.Hosts.Settings.HostSettings"/> that can be used during the negotiation process.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.NegotiationParameters.context">
            <summary>
            Optional logging context for debugging purposes.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.Negotiator">
            <summary>
            <para>The Negotiator class acts as a central coordinator for the negotiation of network connections, abstracting away the complexities of DNS resolution, TCP socket creation, proxy negotiation, and TLS setup.
            It allows for customization and extensibility, making it a versatile tool for establishing network connections in a flexible and controlled manner.</para>
            <list type="bullet">
                <item><description>The Negotiator class represents a component responsible for managing the negotiation process. It helps facilitate communication with various network layers, such as DNS resolution, TCP socket creation, proxy handling, and TLS negotiation.</description></item>
                <item><description>The class is designed to be flexible and extensible by allowing developers to define a custom negotiation peer that implements the INegotiationPeer interface. This allows developers to adapt the negotiation process to specific requirements and protocols.</description></item>
                <item><description>It orchestrates the negotiation process through a series of steps defined by the NegotiationSteps enum. These steps include DNSQuery, TCPRace, Proxy, TLSNegotiation</description></item>
                <item><description>Handles errors and exceptions that may occur during negotiation, ensuring graceful fallback or termination of the negotiation process when necessary.</description></item>
                <item><description>When TLS negotiation is required, it selects the appropriate TLS negotiation method based on the configuration and available options, such as BouncyCastle or the system's TLS framework.</description></item>
                <item><description>If a proxy is configured, the Negotiator class handles proxy negotiation and tunneling, allowing communication through a proxy server.</description></item>
                <item><description>It supports cancellation through a CancellationToken, allowing the negotiation process to be canceled if needed.</description></item>
                <item><description>The class uses extensive logging to provide information about the progress and outcomes of the negotiation process, making it easier to diagnose and debug issues.</description></item>
            </list>
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.Tcp.Negotiator.Peer">
            <summary>
            Gets the negotiation peer associated with this negotiator.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.Tcp.Negotiator.Parameters">
            <summary>
            Gets the negotiation parameters for this negotiator.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.Tcp.Negotiator.Streamer">
            <summary>
            Gets the TCP streamer associated with this negotiator.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.Tcp.Negotiator.Stream">
            <summary>
            Gets the peekable content provider stream associated with this negotiator.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.Negotiator.#ctor(Best.HTTP.Shared.PlatformSupport.Network.Tcp.INegotiationPeer,Best.HTTP.Shared.PlatformSupport.Network.Tcp.NegotiationParameters)">
            <summary>
            Initializes a new instance of the Negotiator class.
            </summary>
            <param name="peer">The negotiation peer for this negotiator.</param>
            <param name="parameters">The negotiation parameters for this negotiator.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.Negotiator.Start">
            <summary>
            Starts the negotiation process.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.Negotiator.OnCancellationRequested">
            <summary>
            Handles cancellation requests during negotiation.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.Streams.NonblockingTCPStream">
            <summary>
            A non-blocking-read stream over a TCPStreamer that buffers the received bytes from the network in a Peekable stream.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRingmasterSettings">
            <summary>
            Contains settings related to TCP Ringmaster, which manages and optimizes TCP connections.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRingmasterSettings.MaxSimultaneousRacers">
            <summary>
            The maximum number of simultaneous TCP racers. Racers are used to establish and manage connections.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRingmasterSettings.ShuffleAddresses">
            <summary>
            Determines whether to shuffle addresses before assigning racing lanes.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRingmasterSettings.CustomAddressShuffleAlgorithm">
            <summary>
            Callback to implement a custom address shuffle algorithm. When assigned, no plugin-defined shuffle algorithm will be executed.
            </summary>
            <remarks>It must be thread-safe.</remarks>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRingmasterSettings.CancellationCheckingGranularity">
            <summary>
            The granularity of cancellation checking for TCP races. It specifies the time interval for checking if a race should be canceled.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRaceResult">
            <summary>
            Represents the result of a TCP race competition, including the winning socket or an error.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRaceResult.WinningSocket">
            <summary>
            The socket that won the race competition, if available.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRaceResult.Error">
            <summary>
            The error encountered during the race competition, if any.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRaceResult.#ctor(System.Net.Sockets.Socket,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRaceResult"/> class with the winning socket and an error, if any.
            </summary>
            <param name="socket">The winning socket of the race competition, if available.</param>
            <param name="ex">The error encountered during the race competition, if any.</param>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.Race">
            <summary>
            Represents a TCP race competition with parameters and status.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.Race.Parameters">
            <summary>
            The parameters for the TCP race competition.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.Race.NextAddressIndex">
            <summary>
            The index of the next address to connect to.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.Race.RunningLanes">
            <summary>
            The number of running lanes in the competition.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.RacingLane">
            <summary>
            Represents a racing lane in a TCP race competition.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.RacingLane.Race">
            <summary>
            The associated race and its parameters.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.RacingLane.AddressIndex">
            <summary>
            The index of the address to connect to.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.RacingLane.LaneIndex">
            <summary>
            The index of the racing lane.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.RacingLane.Socket">
            <summary>
            The socket used for the racing lane.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRaceParameters">
            <summary>
            Contains parameters and settings for a TCP race competition to establish connections.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRaceParameters.Addresses">
            <summary>
            An array of DNS IP addresses to be used for racing to establish a connection.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRaceParameters.Hostname">
            <summary>
            The hostname to connect to.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRaceParameters.Port">
            <summary>
            The port to connect to.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRaceParameters.Token">
            <summary>
            The cancellation token used to cancel the TCP race competition.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRaceParameters.AnnounceWinnerCallback">
            <summary>
            A callback function to announce the winner of the TCP race competition.
            </summary>
            <param name="parameters">The TCPRaceParameters used for the race competition.</param>
            <param name="result">The result of the race competition, including the winning socket or an error.</param>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRaceParameters.Context">
            <summary>
            Optional context for logging and tracking purposes.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRaceParameters.Tag">
            <summary>
            A user-defined tag associated with the TCP race parameters.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRingmaster">
            <summary>
            <para>TCPRingmaster provides a method called <see cref="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRingmaster.StartCompetion(Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRaceParameters)"/>, which is used to initiate a competition among multiple TCP connections.
            Each connection attempt races against the others to establish a connection, and the first successful connection is considered the winner.</para>
            The class allows to specify a callback function (through <see cref="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRaceParameters.AnnounceWinnerCallback"/>) that gets invoked when a winning connection is established or when the competition is canceled.
            This callback can be used to take action based on the competition outcome.
            <para>Additionally it includes logic for optimizing the order in which connection attempts are made:
            <list type="bullet">
                <item><description>It can shuffle the order of addresses to improve the chances of quickly finding a working address.</description></item>
                <item><description>It handles scenarios where some addresses may not be working and prioritizes working addresses.</description></item>
            </list>
            </para>
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRingmaster.StartCompetion(Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRaceParameters)">
            <summary>
            Starts a TCP race competition to establish connections based on the provided parameters.
            </summary>
            <param name="parameters">The parameters and settings for the TCP race competition.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPRingmaster.ShuffleAddresses(Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSIPAddress[])">
            <summary>
            Inplace shuffles addresses.
            </summary>
            <param name="addresses">The array of <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.DNS.Cache.DNSIPAddress"/> to shuffle.</param>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.ITCPStreamerContentConsumer">
            <summary>
            The ITCPStreamerContentConsumer interface represents a specialized content consumer for use with <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/>. It offers methods for writing data to the streamer and handling content-related events.
            </summary>
            <remarks>
            <para>
            Key Functions of ITCPStreamerContentConsumer:
            </para>
            <list type="bullet">
            <item>
            <term>Data Writing</term><description>Provides methods to write data to the associated <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/> instance, allowing content to be sent over the TCP connection.
            </description></item>
            <item>
            <term>Content Handling</term><description>Defines event methods for notifying consumers when new content is available, the connection is closed, or errors occur during data transfer.
            </description></item>
            </list>
            </remarks>
            <seealso cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.ITCPStreamerContentConsumer.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the specified data buffer to the associated <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/> instance. The data is copied into a new buffer and passed to the streamer for transmission.
            </summary>
            <param name="buffer">The byte array containing the data to be written.</param>
            <param name="offset">The zero-based byte offset in the buffer from which to begin writing.</param>
            <param name="count">The number of bytes to write from the buffer.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.ITCPStreamerContentConsumer.Write(Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment)">
            <summary>
            Writes the specified <see cref="T:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment"/> directly to the associated <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/> instance. The content of the buffer is passed to the streamer for transmission, and the ownership of the buffer is transferred to the <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/> too.
            </summary>
            <param name="buffer">The <see cref="T:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment"/> containing the data to be written.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.ITCPStreamerContentConsumer.OnContent(Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer)">
            <summary>
            Called when new content is available from the associated <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/> instance.
            </summary>
            <param name="streamer">The <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/> instance providing the content.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.ITCPStreamerContentConsumer.OnConnectionClosed(Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer)">
            <summary>
            Called when the connection is closed by the remote peer. It notifies the content consumer about the connection closure.
            </summary>
            <param name="streamer">The <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/> instance for which the connection is closed.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.ITCPStreamerContentConsumer.OnError(Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer,System.Exception)">
            <summary>
            Called when an error occurs during content processing or connection handling. It provides the <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/> instance and the <see cref="T:System.Exception"/> that caused the error.
            </summary>
            <param name="streamer">The <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/> instance where the error occurred.</param>
            <param name="ex">The <see cref="T:System.Exception"/> that represents the error condition.</param>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer">
            <summary>
            The TCPStreamer class is a versatile component that abstracts the complexities of TCP communication, making it easier to handle data streaming between networked applications or devices. It ensures reliable and efficient data transfer while handling various aspects of network communication and error management.
            </summary>
            <remarks>
            <para>
            TCPStreamer serves several key functions:
            </para>
            <list type="bullet">
            <item>
            <term>Data Streaming</term><description>It enables the streaming of data between two endpoints over a TCP connection, ideal for scenarios involving the transfer of large data volumes in manageable chunks.
            </description></item>
            <item>
            <term>Buffer Management</term><description>The class efficiently manages buffering for both incoming and outgoing data, ensuring smooth and efficient data transfer.
            </description></item>
            <item>
            <term>Asynchronous Communication</term><description>Utilizing asynchronous communication patterns, it supports non-blocking operations, essential for applications requiring concurrent data processing.
            </description></item>
            <item>
            <term>Error Handling</term><description>Comprehensive error-handling mechanisms address exceptions that may occur during TCP communication, enhancing robustness in the face of network issues or errors.
            </description></item>
            <item>
            <term>Resource Management</term><description>It handles memory buffer management and resource disposal when the TCP connection is closed or the class is disposed.
            </description></item>
            <item>
            <term>Integration with Heartbeat</term><description>Implementing the <see cref="T:Best.HTTP.Shared.Extensions.IHeartbeat"/> interface, it can be seamlessly integrated into systems using heartbeat mechanisms for network connection monitoring and management.
            </description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer.ContentConsumer">
            <summary>
            Gets or sets the content consumer that interacts with this <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/> instance, allowing data to be written to the streamer for transmission.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer.Socket">
            <summary>
            Gets the underlying <see cref="P:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer.Socket"/> associated with this <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/> instance.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer.Context">
            <summary>
            Gets the optional <see cref="T:Best.HTTP.Shared.Logger.LoggingContext"/> associated with this <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/> instance, facilitating logging and diagnostics.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer.IsConnectionClosed">
            <summary>
            Gets a value indicating whether the TCP connection is closed.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer.MinReceiveBufferSize">
            <summary>
            Gets the minimum receive buffer size for the TCP socket.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer.Length">
            <summary>
            Gets the total length of buffered data for reading from the stream.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer.MaxBufferedReadAmount">
            <summary>
            Gets or sets the maximum amount of buffered data allowed for reading from the stream.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer.MaxBufferedWriteAmount">
            <summary>
            Gets or sets the maximum amount of buffered data allowed for writing to the stream.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer.#ctor(System.Net.Sockets.Socket,System.UInt32,System.UInt32,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Initializes a new instance of the TCPStreamer class with the specified <see cref="T:System.Net.Sockets.Socket"/> and parent <see cref="T:Best.HTTP.Shared.Logger.LoggingContext"/>.
            </summary>
            <param name="socket">The underlying <see cref="T:System.Net.Sockets.Socket"/> representing the TCP connection.</param>
            <param name="parentLoggingContext">The optional  parent <see cref="T:Best.HTTP.Shared.Logger.LoggingContext"/> for logging and diagnostics.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer.DequeueReceived">
            <summary>
            Dequeues received data from the stream's buffer and returns a <see cref="T:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment"/> containing the data.
            </summary>
            <returns>A <see cref="T:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment"/> containing the received data.</returns>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer.BeginReceive">
            <summary>
            Begins receiving data from the TCP connection asynchronously. This method ensures that only one receive operation happens at a time.
            </summary>
            <remarks>
            When calling this method, it ensures that there is only one active receive operation at a time, preventing overlapping receives. This optimization helps prevent data loss and improves the reliability of the receive process.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer.EnqueueToSend(Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment)">
            <summary>
            Enqueues data to be sent over the TCP connection. The data is added to the stream's outgoing buffer for transmission.
            </summary>
            <param name="buffer">The <see cref="T:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment"/> containing the data to be sent.</param>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer.Dispose">
            <summary>
            Disposes of the <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/> instance, releasing associated resources.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer.Close">
            <summary>
            Closes the TCP connection gracefully and performs cleanup operations.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.PlatformSupport.Text.StringBuilderPool">
            <summary>
            Implements pooling logic for <see cref="T:System.Text.StringBuilder"/> instances.
            </summary>
        </member>
        <member name="P:Best.HTTP.Shared.PlatformSupport.Text.StringBuilderPool.IsEnabled">
            <summary>
            Setting this property to false the pooling mechanism can be disabled.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Text.StringBuilderPool.RemoveOlderThan">
            <summary>
            Buffer entries that released back to the pool and older than this value are moved when next maintenance is triggered.
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.PlatformSupport.Text.StringBuilderPool.RunMaintenanceEvery">
            <summary>
            How often pool maintenance must run.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.Streams.BufferPoolMemoryStream">
            <summary>
            This is a modified MemoryStream class to use VariableSizedBufferPool
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.Streams.PeekableContentProviderStream">
            <summary>
            A PeekableStream implementation that also implements the <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.IPeekableContentProvider"/> interface too.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Streams.PeekableContentProviderStream.Unbind">
            <summary>
            This will set Consumer to null.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.Streams.PeekableContentProviderStream.UnbindIf(Best.HTTP.Shared.PlatformSupport.Network.Tcp.IContentConsumer)">
            <summary>
            Set Consumer to null if the current one is the one passed in the parameter. 
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.Streams.StreamList">
            <summary>
            Wrapper of multiple streams. Writes and reads are both supported. Read goes trough all the streams.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.Streams.WriteOnlyBufferedStream">
            <summary>
            A custom buffer stream implementation that will not close the underlying stream.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.TLS.AbstractTls13Client.GetNegotiatedApplicationProtocol">
            <summary>
            TCPConnector has to know what protocol got negotiated
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.TLS.Crypto.Impl.FastAesEngine">
             an implementation of the AES (Rijndael), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor, they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations, 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each, for a total of 2Kbytes,
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first.
            
             The slowest version uses no static tables at all and computes the values in each round.
             </p>
             <p>
             This file contains the middle performance version with 2Kbytes of static tables for round precomputation.
             </p>
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastAesEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastAesEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastAesEngine.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Best.HTTP.Shared.TLS.Crypto.Impl.FastCcmBlockCipher">
            Implements the Counter with Cipher Block Chaining mode (CCM) detailed in
            NIST Special Publication 800-38C.
            <p>
            <b>Note</b>: this mode is a packet mode - it needs all the data up front.
            </p>
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastCcmBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used.
        </member>
        <member name="P:Best.HTTP.Shared.TLS.Crypto.Impl.FastCcmBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastCcmBlockCipher.GetMac">
             Returns a byte array containing the mac calculated as part of the
             last encrypt or decrypt operation.
            
             @return the last mac calculated.
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastCcmBlockCipher.ProcessPacket(System.Byte[],System.Int32,System.Int32)">
             Process a packet of data for either CCM decryption or encryption.
            
             @param in data for processing.
             @param inOff offset at which data starts in the input array.
             @param inLen length of the data in the input array.
             @return a byte array containing the processed input..
             @throws IllegalStateException if the cipher is not appropriately set up.
             @throws InvalidCipherTextException if the input data is truncated or the mac check fails.
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastCcmBlockCipher.ProcessPacket(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             Process a packet of data for either CCM decryption or encryption.
            
             @param in data for processing.
             @param inOff offset at which data starts in the input array.
             @param inLen length of the data in the input array.
             @param output output array.
             @param outOff offset into output array to start putting processed bytes.
             @return the number of bytes added to output.
             @throws IllegalStateException if the cipher is not appropriately set up.
             @throws InvalidCipherTextException if the input data is truncated or the mac check fails.
             @throws DataLengthException if output buffer too short.
        </member>
        <member name="T:Best.HTTP.Shared.TLS.Crypto.Impl.FastChaCha7539Engine">
            <summary>
            Implementation of Daniel J. Bernstein's ChaCha stream cipher.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastChaCha7539Engine.#ctor">
            <summary>
            Creates a 20 rounds ChaCha engine.
            </summary>
        </member>
        <member name="T:Best.HTTP.Shared.TLS.Crypto.Impl.FastChaChaEngine">
            <summary>
            Implementation of Daniel J. Bernstein's ChaCha stream cipher.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastChaChaEngine.#ctor">
            <summary>
            Creates a 20 rounds ChaCha engine.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastChaChaEngine.#ctor(System.Int32)">
            <summary>
            Creates a ChaCha engine with a specific number of rounds.
            </summary>
            <param name="rounds">the number of rounds (must be an even number).</param>
        </member>
        <member name="T:Best.HTTP.Shared.TLS.Crypto.Impl.FastGcmBlockCipher">
            <summary>
            Implements the Galois/Counter mode (GCM) detailed in NIST Special Publication 800-38D.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastGcmBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <remarks>
            MAC sizes from 32 bits to 128 bits (must be a multiple of 8) are supported. The default is 128 bits.
            Sizes less than 96 are not recommended, but are supported for specialized applications.
            </remarks>
        </member>
        <member name="T:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305">
            <summary>
            Poly1305 message authentication code, designed by D. J. Bernstein.
            </summary>
            <remarks>
            Poly1305 computes a 128-bit (16 bytes) authenticator, using a 128 bit nonce and a 256 bit key
            consisting of a 128 bit key applied to an underlying cipher, and a 128 bit key (with 106
            effective key bits) used in the authenticator.
            
            The polynomial calculation in this implementation is adapted from the public domain <a
            href="https://github.com/floodyberry/poly1305-donna">poly1305-donna-unrolled</a> C implementation
            by Andrew M (@floodyberry).
            </remarks>
            <seealso cref="T:Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator"/>
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.r0">
            Polynomial key 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.r1">
            Polynomial key 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.r2">
            Polynomial key 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.r3">
            Polynomial key 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.r4">
            Polynomial key 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.s1">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.s2">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.s3">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.s4">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.k0">
            Encrypted nonce 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.k1">
            Encrypted nonce 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.k2">
            Encrypted nonce 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.k3">
            Encrypted nonce 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.currentBlock">
            Current block of buffered input 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.currentBlockOffset">
            Current offset in input buffer 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.h0">
            Polynomial accumulator 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.h1">
            Polynomial accumulator 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.h2">
            Polynomial accumulator 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.h3">
            Polynomial accumulator 
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.h4">
            Polynomial accumulator 
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.#ctor">
            Constructs a Poly1305 MAC, where the key passed to init() will be used directly.
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
            Constructs a Poly1305 MAC, using a 128 bit block cipher.
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastPoly1305.Init(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>
            Initialises the Poly1305 MAC.
            </summary>
            <param name="parameters">a {@link ParametersWithIV} containing a 128 bit nonce and a {@link KeyParameter} with
                     a 256 bit key complying to the {@link Poly1305KeyGenerator Poly1305 key format}.</param>
        </member>
        <member name="T:Best.HTTP.Shared.TLS.Crypto.Impl.FastSalsa20Engine">
            <summary>
            Implementation of Daniel J. Bernstein's Salsa20 stream cipher, Snuffle 2005
            </summary>
        </member>
        <member name="F:Best.HTTP.Shared.TLS.Crypto.Impl.FastSalsa20Engine.StateSize">
            Constants 
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastSalsa20Engine.#ctor">
            <summary>
            Creates a 20 round Salsa20 engine.
            </summary>
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastSalsa20Engine.#ctor(System.Int32)">
            <summary>
            Creates a Salsa20 engine with a specific number of rounds.
            </summary>
            <param name="rounds">the number of rounds (must be an even number).</param>
        </member>
        <member name="T:Best.HTTP.Shared.TLS.Crypto.Impl.FastSicBlockCipher">
            Implements the Segmented Integer Counter (SIC) mode on top of a simple
            block cipher.
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastSicBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param c the block cipher to be used.
        </member>
        <member name="P:Best.HTTP.Shared.TLS.Crypto.Impl.FastSicBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="T:Best.HTTP.Shared.TLS.Crypto.Impl.FastTlsAeadCipher">
            <summary>A generic TLS 1.2 AEAD cipher.</summary>
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastTlsAeadCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.Shared.TLS.Crypto.Impl.FastTlsBlockCipher">
            <summary>A generic TLS 1.0-1.2 block cipher. This can be used for AES or 3DES for example.</summary>
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.Impl.FastTlsBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHmac,Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.Crypto.TlsHmac,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Best.HTTP.Shared.TLS.Crypto.FastCbcBlockCipher">
            implements Cipher-Block-Chaining (CBC) mode on top of a simple cipher.
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.FastCbcBlockCipher.#ctor(Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of chaining.
        </member>
        <member name="P:Best.HTTP.Shared.TLS.Crypto.FastCbcBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.FastCbcBlockCipher.Init(System.Boolean,Best.HTTP.SecureProtocol.Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Best.HTTP.Shared.TLS.Crypto.FastCbcBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CBC".
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.FastCbcBlockCipher.GetBlockSize">
             return the block size of the underlying cipher.
            
             @return the block size of the underlying cipher.
        </member>
        <member name="M:Best.HTTP.Shared.TLS.Crypto.FastCbcBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="T:Best.HTTP.Shared.TLS.Labels">
            <summary>
            https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format
            </summary>
        </member>
        <member name="T:Best.HTTP.JSON.Json">
             <summary>
             Based on the download from http://techblog.procurios.nl/k/news/view/14605/14863/how-do-i-write-my-own-parser-%28for-json%29.html
             This class encodes and decodes JSON strings.
             Spec. details, see http://www.json.org/
            
             JSON uses Arrays and Objects. These correspond here to the datatypes List and Dictionary.
             All numbers are parsed to doubles.
             </summary>
        </member>
        <member name="M:Best.HTTP.JSON.Json.Decode(System.String)">
            <summary>
            Parses the string json into a value
            </summary>
            <param name="json">A JSON string.</param>
            <returns>A List, a Dictionary, a double, a string, null, true, or false</returns>
        </member>
        <member name="M:Best.HTTP.JSON.Json.Decode(System.String,System.Boolean@)">
            <summary>
            Parses the string json into a value; and fills 'success' with the successfullness of the parse.
            </summary>
            <param name="json">A JSON string.</param>
            <param name="success">Successful parse?</param>
            <returns>A List, a Dictionary, a double, a string, null, true, or false</returns>
        </member>
        <member name="M:Best.HTTP.JSON.Json.Encode(System.Object)">
            <summary>
            Converts a Dictionary / List object into a JSON string
            </summary>
            <param name="json">A Dictionary / List</param>
            <returns>A JSON encoded string, or null if object 'json' is not serializable</returns>
        </member>
        <member name="M:Best.HTTP.JSON.LitJson.JsonData.ContainsKey(System.String)">
            <summary>
            Determines whether the json contains an element that has the specified key.
            </summary>
            <param name="key">The key to locate in the json.</param>
            <returns>true if the json contains an element that has the specified key; otherwise, false.</returns>
        </member>
        <member name="T:Best.HTTP.Caching.HTTPCacheBuilder">
            <summary>
            A builder struct for constructing an instance of the HTTPCache class with optional configuration options and callbacks.
            </summary>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCacheBuilder.WithOptions(Best.HTTP.Caching.HTTPCacheOptions)">
            <summary>
            Sets the configuration options for the HTTP cache.
            </summary>
            <param name="options">The <see cref="T:Best.HTTP.Caching.HTTPCacheOptions"/> containing cache configuration settings.</param>
            <returns>The current <see cref="T:Best.HTTP.Caching.HTTPCacheBuilder"/> instance for method chaining.</returns>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCacheBuilder.WithOptions(Best.HTTP.Caching.HTTPCacheOptionsBuilder)">
            <summary>
            Sets the configuration options for the HTTP cache using an <see cref="T:Best.HTTP.Caching.HTTPCacheOptionsBuilder"/>.
            </summary>
            <param name="optionsBuilder">An <see cref="T:Best.HTTP.Caching.HTTPCacheOptionsBuilder"/> for building cache configuration settings.</param>
            <returns>The current <see cref="T:Best.HTTP.Caching.HTTPCacheBuilder"/> instance for method chaining.</returns>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCacheBuilder.WithBeforeBeginCacheCallback(Best.HTTP.Caching.OnBeforeBeginCacheDelegate)">
            <summary>
            Sets a callback delegate to be executed before caching of an entity begins.
            </summary>
            <param name="callback">The delegate to be executed before caching starts.</param>
            <returns>The current <see cref="T:Best.HTTP.Caching.HTTPCacheBuilder"/> instance for method chaining.</returns>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCacheBuilder.Build">
            <summary>
            Builds and returns an instance of the <see cref="T:Best.HTTP.Caching.HTTPCache"/> with the specified configuration options and callback delegate.
            </summary>
            <returns>An <see cref="T:Best.HTTP.Caching.HTTPCache"/> instance configured with the specified options and callback.</returns>
        </member>
        <member name="T:Best.HTTP.Caching.HTTPCacheOptionsBuilder">
            <summary>
            A builder struct for constructing an instance of <see cref="T:Best.HTTP.Caching.HTTPCacheOptions"/> with optional configuration settings.
            </summary>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCacheOptionsBuilder.WithMaxCacheSize(System.UInt64)">
            <summary>
            Sets the maximum cache size for the HTTP cache.
            </summary>
            <param name="maxCacheSize">The maximum size, in bytes, that the cache can reach.</param>
            <returns>The current <see cref="T:Best.HTTP.Caching.HTTPCacheOptionsBuilder"/> instance for method chaining.</returns>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCacheOptionsBuilder.WithDeleteOlderThen(System.TimeSpan)">
            <summary>
            Sets the maximum duration for which cached entries will be retained.
            By default all entities (even stalled ones) are kept cached until they are evicted to make room for new, fresh ones.
            </summary>
            <param name="olderThan">The maximum age for cached entries to be retained.</param>
            <returns>The current <see cref="T:Best.HTTP.Caching.HTTPCacheOptionsBuilder"/> instance for method chaining.</returns>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCacheOptionsBuilder.Build">
            <summary>
            Builds and returns an instance of <see cref="T:Best.HTTP.Caching.HTTPCacheOptions"/> with the specified configuration settings.
            </summary>
            <returns>An <see cref="T:Best.HTTP.Caching.HTTPCacheOptions"/> instance configured with the specified settings.</returns>
        </member>
        <member name="T:Best.HTTP.Caching.ErrorTypeForValidation">
            <summary>
            Types of errors that can occur during cache validation.
            </summary>
        </member>
        <member name="F:Best.HTTP.Caching.ErrorTypeForValidation.None">
            <summary>
            Indicates that no error has occurred during validation.
            </summary>
        </member>
        <member name="F:Best.HTTP.Caching.ErrorTypeForValidation.ServerError">
            <summary>
            Indicates a server error has occurred during validation.
            </summary>
        </member>
        <member name="F:Best.HTTP.Caching.ErrorTypeForValidation.ConnectionError">
            <summary>
            Indicates a connection error has occurred during validation.
            </summary>
        </member>
        <member name="T:Best.HTTP.Caching.OnBeforeBeginCacheDelegate">
            <summary>
            Represents a delegate that can be used to perform actions before caching of an entity begins.
            </summary>
            <param name="method">The HTTP method used in the request.</param>
            <param name="uri">The URI of the HTTP request.</param>
            <param name="statusCode">The HTTP status code of the response.</param>
            <param name="headers">The HTTP response headers.</param>
            <param name="context">An optional logging context for debugging.</param>
        </member>
        <member name="T:Best.HTTP.Caching.OnCacheSizeChangedDelegate">
            <summary>
            Represents a delegate that can be used to handle cache size change events.
            </summary>
        </member>
        <member name="T:Best.HTTP.Caching.HTTPCache">
            <summary>
            Manages caching of HTTP responses and associated metadata.
            </summary>
            <remarks>
            <para>The `HTTPCache` class provides a powerful caching mechanism for HTTP responses in Unity applications. 
            It allows you to store and retrieve HTTP responses efficiently, reducing network requests and improving 
            the performance of your application. By utilizing HTTP caching, you can enhance user experience, reduce 
            bandwidth usage, and optimize loading times.
            </para>
            <para>
            Key features:
            <list type="bullet">
                <item><term>Optimal User Experience</term><description>Users experience faster load times and smoother interactions, enhancing user satisfaction.</description></item>
                <item><term>Efficient Caching</term><description>It enables efficient caching of HTTP responses, reducing the need to fetch data from the network repeatedly.</description></item>
                <item><term>Improved Performance</term><description>Caching helps improve the performance of your Unity application by reducing latency and decreasing loading times.</description></item>
                <item><term>Bandwidth Optimization</term><description>By storing and reusing cached responses, you can minimize bandwidth usage, making your application more data-friendly.</description></item>
                <item><term>Offline Access</term><description>Cached responses allow your application to function even when the device is offline or has limited connectivity.</description></item>
                <item><term>Reduced Server Load</term><description>Fewer network requests mean less load on your server infrastructure, leading to cost savings and improved server performance.</description></item>
                <item><term>Manual Cache Control</term><description>You can also manually control caching by adding, removing, or updating cached responses.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Best.HTTP.Caching.HTTPCache.RootFolderName">
            <summary>
            Constants defining folder and file names used in the HTTP cache storage.
            </summary>
        </member>
        <member name="F:Best.HTTP.Caching.HTTPCache.CacheHostName">
            <summary>
            This is the reversed domain the plugin uses for file paths when it have to load content from the local cache.
            </summary>
        </member>
        <member name="F:Best.HTTP.Caching.HTTPCache.OnCacheSizeChanged">
            <summary>
            Event that is triggered when the size of the cache changes.
            </summary>
        </member>
        <member name="P:Best.HTTP.Caching.HTTPCache.Options">
            <summary>
            Gets the options that define the behavior of the HTTP cache.
            </summary>
        </member>
        <member name="P:Best.HTTP.Caching.HTTPCache.CacheSize">
            <summary>
            Gets the current size of the HTTP cache in bytes.
            </summary>
        </member>
        <member name="F:Best.HTTP.Caching.HTTPCache.OnBeforeBeginCache">
            <summary>
            Called before the plugin calls <see cref="M:Best.HTTP.Caching.HTTPCache.BeginCache(Best.HTTP.HTTPMethods,System.Uri,System.Int32,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{System.String}},Best.HTTP.Shared.Logger.LoggingContext)"/> to decide whether the content will be cached or not.
            </summary>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.#ctor(Best.HTTP.Caching.HTTPCacheOptions)">
            <summary>
            Initializes a new instance of the HTTPCache class with the specified cache options.
            </summary>
            <param name="options">The HTTP cache options specifying cache size and deletion policy.</param>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.CalculateHash(Best.HTTP.HTTPMethods,System.Uri)">
            <summary>
            Calculates a unique hash identifier based on the HTTP method and URI.
            </summary>
            <param name="method">The HTTP method used in the request.</param>
            <param name="uri">The URI of the HTTP request.</param>
            <returns>A unique hash identifier for the combination of method and URI.</returns>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.GetHashDirectory(UnityEngine.Hash128)">
            <summary>
            Generates the directory path based on the given hash where cached content is stored.
            </summary>
            <param name="hash">A unique hash identifier for the cached content, returned by <see cref="M:Best.HTTP.Caching.HTTPCache.CalculateHash(Best.HTTP.HTTPMethods,System.Uri)"/>.</param>
            <returns>The directory path for the cached content associated with the given hash.</returns>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.GetHeaderPathFromHash(UnityEngine.Hash128)">
            <summary>
            Generates the file path for the header cache associated with the given hash.
            </summary>
            <param name="hash">A unique hash identifier for the cached content, returned by <see cref="M:Best.HTTP.Caching.HTTPCache.CalculateHash(Best.HTTP.HTTPMethods,System.Uri)"/>.</param>
            <returns>The file path for the header cache associated with the given hash.</returns>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.GetContentPathFromHash(UnityEngine.Hash128)">
            <summary>
            Generates the file path for the content cache associated with the given hash.
            </summary>
            <param name="hash">A unique hash identifier for the cached content, returned by <see cref="M:Best.HTTP.Caching.HTTPCache.CalculateHash(Best.HTTP.HTTPMethods,System.Uri)"/>.</param>
            <returns>The file path for the content cache associated with the given hash.</returns>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.AreCacheFilesExists(UnityEngine.Hash128)">
            <summary>
            Checks whether cache files (header and content) associated with the given hash exist.
            </summary>
            <param name="hash">A unique hash identifier for the cached content.</param>
            <returns><c>true</c> if both header and content cache files exist, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.SetupValidationHeaders(Best.HTTP.HTTPRequest)">
            <summary>
            Sets up validation headers on an HTTP request if a locally cached response exists.
            </summary>
            <param name="request">The <see cref="T:Best.HTTP.HTTPRequest"/> to which validation headers will be added.</param>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.IsThereEnoughSpaceAfterMaintain(System.UInt64,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            If necessary tries to make enough space in the cache by calling Maintain.
            </summary>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.BeginCache(Best.HTTP.HTTPMethods,System.Uri,System.Int32,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{System.String}},Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Initiates the caching process for an HTTP response, creating an <see cref="T:Best.HTTP.Caching.HTTPCacheContentWriter"/> if caching is enabled and all predconditions are met.
            </summary>
            <param name="method">The <see cref="T:Best.HTTP.HTTPRequest"/> method used to fetch the response.</param>
            <param name="uri">The URI for the response.</param>
            <param name="statusCode">The HTTP status code of the response.</param>
            <param name="headers">The HTTP headers of the response.</param>
            <param name="context">An optional logging context for debugging.</param>
            <returns>An <see cref="T:Best.HTTP.Caching.HTTPCacheContentWriter"/> instance for writing the response content to the cache, or null if caching is not enabled or not possible.</returns>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.EndCache(Best.HTTP.Caching.HTTPCacheContentWriter,System.Boolean,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Finalizes the caching process and takes appropriate actions based on the completion status.
            </summary>
            <param name="cacheResult">The <see cref="T:Best.HTTP.Caching.HTTPCacheContentWriter"/> instance representing the caching operation.</param>
            <param name="completedWithoutIssue">A boolean indicating whether the caching process completed without issues.</param>
            <param name="context">An optional logging context for debugging.</param>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.BeginReadContent(UnityEngine.Hash128,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Initiates the process of reading cached content associated with a given hash. Call BeginReadContent to acquire a Stream object that points to the cached resource.
            </summary>
            <param name="hash">A hash from <see cref="M:Best.HTTP.Caching.HTTPCache.CalculateHash(Best.HTTP.HTTPMethods,System.Uri)"/> identifying the resource.</param>
            <param name="context">An optional <see cref="T:Best.HTTP.Shared.Logger.LoggingContext"/></param>
            <returns>A stream for reading the cached content, or null if the content could not be read (the resource isn't cached or currently downloading).</returns>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.EndReadContent(UnityEngine.Hash128,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Finalizes the process of reading cached content associated with a given hash.
            </summary>
            <param name="hash">The unique hash identifier for the cached content.</param>
            <param name="context">An optional logging context for debugging.</param>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.Delete(UnityEngine.Hash128,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Deletes a cached entry identified by the given hash, including its associated header and content files.
            </summary>
            <param name="hash">The unique hash identifier for the cached entry to be deleted.</param>
            <param name="context">An optional logging context for debugging.</param>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.RefreshHeaders(UnityEngine.Hash128,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{System.String}},Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Refreshes the headers of a cached HTTP response with new headers.
            </summary>
            <param name="hash">A unique hash identifier for the cached response from a <see cref="M:Best.HTTP.Caching.HTTPCache.CalculateHash(Best.HTTP.HTTPMethods,System.Uri)"/> call.</param>
            <param name="newHeaders">A dictionary of new headers to replace or merge with existing headers.</param>
            <param name="context">Used by the plugin to add an addition logging context for debugging. It can be <c>null</c>.</param>
            <returns><c>true</c> if the headers were successfully refreshed; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.CanServeWithoutValidation(UnityEngine.Hash128,Best.HTTP.Caching.ErrorTypeForValidation,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Checks whether the caches resource identified by the hash is can be served from the local store with the given error conditions. 
            </summary>
            <remarks>This check reflects the very current state, even if it returns <c>true</c>, a request might just executing to get a write lock on it to refresh the content.</remarks>
            <param name="hash"><see cref="T:UnityEngine.Hash128"/> hash returned by <see cref="M:Best.HTTP.Caching.HTTPCache.CalculateHash(Best.HTTP.HTTPMethods,System.Uri)"/> identifying a resource.</param>
            <param name="errorType">Possible error condition that can occur during validation. Servers can provision that certain stalled resources can be served if revalidation fails.</param>
            <param name="context">Used by the plugin to add an addition logging context for debugging. It can be <c>null</c>.</param>
            <returns><c>true</c> if the cached response can be served without validating it with the origin server; otherwise, <c>false</c></returns>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.Redirect(Best.HTTP.HTTPRequest,UnityEngine.Hash128)">
            <summary>
            Redirects a request to a cached entity.
            </summary>
            <param name="request">The <see cref="T:Best.HTTP.HTTPRequest"/> that will be redirected.</param>
            <param name="hash">Hash obtained from <see cref="M:Best.HTTP.Caching.HTTPCache.CalculateHash(Best.HTTP.HTTPMethods,System.Uri)"/>.</param>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCache.Clear">
            <summary>
            Clears the HTTP cache by removing all cached entries and associated metadata.
            </summary>
        </member>
        <member name="T:Best.HTTP.Caching.HTTPCacheContentWriter">
            <summary>
            Represents a writer for caching HTTP response content.
            </summary>
        </member>
        <member name="P:Best.HTTP.Caching.HTTPCacheContentWriter.Cache">
            <summary>
            Gets the parent HTTPCache instance associated with this content writer.
            </summary>
        </member>
        <member name="P:Best.HTTP.Caching.HTTPCacheContentWriter.Hash">
            <summary>
            Hash identifying the resource. If <see cref="M:Best.HTTP.Caching.HTTPCacheContentWriter.Write(Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment)"/> fails, it becomes an invalid one.
            </summary>
        </member>
        <member name="P:Best.HTTP.Caching.HTTPCacheContentWriter.ExpectedLength">
            <summary>
            Expected length of the content. Has a non-zero value only when the server is sending a "content-length" header.
            </summary>
        </member>
        <member name="P:Best.HTTP.Caching.HTTPCacheContentWriter.ProcessedLength">
            <summary>
            Number of bytes written to the cache.
            </summary>
        </member>
        <member name="P:Best.HTTP.Caching.HTTPCacheContentWriter.Context">
            <summary>
            Context of this cache writer used for logging.
            </summary>
        </member>
        <member name="F:Best.HTTP.Caching.HTTPCacheContentWriter._contentStream">
            <summary>
            Underlying stream the download bytes are written into.
            </summary>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCacheContentWriter.Write(Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment)">
            <summary>
            Writes content to the underlying stream. 
            </summary>
            <param name="segment"><see cref="T:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment"/> holding a reference to the data and containing information about the offset and count of the valid range of data.</param>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCacheContentWriter.Close">
            <summary>
            Close the underlying stream and invalidate the hash.
            </summary>
        </member>
        <member name="T:Best.HTTP.Caching.LockTypes">
            <summary>
            Possible lock-states a cache-content can be in.
            </summary>
        </member>
        <member name="F:Best.HTTP.Caching.LockTypes.Unlocked">
            <summary>
            No reads or writes are happening on the cached content.
            </summary>
        </member>
        <member name="F:Best.HTTP.Caching.LockTypes.Write">
            <summary>
            There's one writer operating on the cached content. No other writes or reads allowed while this lock is held on the content.
            </summary>
        </member>
        <member name="F:Best.HTTP.Caching.LockTypes.Read">
            <summary>
            There's at least one read operation happening on the cached content. No writes allowed while this lock is held on the content.
            </summary>
        </member>
        <member name="T:Best.HTTP.Caching.CacheMetadata">
            <summary>
            Metadata stored for every cached content. It contains only limited data about the content to help early cache decision making and cache management.
            </summary>
        </member>
        <member name="P:Best.HTTP.Caching.CacheMetadata.Hash">
            <summary>
            Unique hash of the cached content, generated by <see cref="M:Best.HTTP.Caching.HTTPCache.CalculateHash(Best.HTTP.HTTPMethods,System.Uri)"/>.
            </summary>
        </member>
        <member name="P:Best.HTTP.Caching.CacheMetadata.ContentLength">
            <summary>
            Size of the stored content in bytes.
            </summary>
        </member>
        <member name="P:Best.HTTP.Caching.CacheMetadata.LastAccessTime">
            <summary>
            When the last time the content is accessed. Also initialized when the initial download completes.
            </summary>
        </member>
        <member name="P:Best.HTTP.Caching.CacheMetadata.Lock">
            <summary>
            What kind of lock the content is currently in.
            </summary>
        </member>
        <member name="P:Best.HTTP.Caching.CacheMetadata.ReadLockCount">
            <summary>
            Number of readers.
            </summary>
        </member>
        <member name="T:Best.HTTP.Caching.CacheFlags">
            <summary>
            Possible caching flags that a `Cache-Control` header can send.
            </summary>
        </member>
        <member name="F:Best.HTTP.Caching.CacheFlags.None">
            <summary>
            No special treatment required.
            </summary>
        </member>
        <member name="F:Best.HTTP.Caching.CacheFlags.MustRevalidate">
            <summary>
            Indicates whether the entity must be revalidated with the server or can be serverd directly from the cache without touching the server when the content is considered stale.
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="https://www.rfc-editor.org/rfc/rfc9111.html#name-must-revalidate"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Best.HTTP.Caching.CacheFlags.NoCache">
            <summary>
            If it's true, the client always have to revalidate the cached content when it's stale.
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="https://www.rfc-editor.org/rfc/rfc9111.html#name-no-cache-2"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Best.HTTP.Caching.CacheMetadataContent">
            <summary>
            Cached content associated with a <see cref="T:Best.HTTP.Caching.CacheMetadata"/>.
            </summary>
            <remarks>This is NOT the cached content received from the server! It's for storing caching values to decide on how the content can be used.</remarks>
        </member>
        <member name="F:Best.HTTP.Caching.CacheMetadataContent.ETag">
            <summary>
            ETag of the entity.
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Best.HTTP.Caching.CacheMetadataContent.LastModified">
            <summary>
            LastModified date of the entity. Use ToString("r") to convert it to the format defined in RFC 1123.
            </summary>
        </member>
        <member name="F:Best.HTTP.Caching.CacheMetadataContent.Expires">
            <summary>
            When the cache will expire.
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="https://www.rfc-editor.org/rfc/rfc9111.html#name-expires"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Best.HTTP.Caching.CacheMetadataContent.Age">
            <summary>
            The age that came with the response
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="https://www.rfc-editor.org/rfc/rfc9111.html#name-age"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Best.HTTP.Caching.CacheMetadataContent.MaxAge">
            <summary>
            Maximum how long the entry should served from the cache without revalidation.
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="https://www.rfc-editor.org/rfc/rfc9111.html#name-max-age-2"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Best.HTTP.Caching.CacheMetadataContent.Date">
            <summary>
            The Date that came with the response.
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Date"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Best.HTTP.Caching.CacheMetadataContent.StaleWhileRevalidate">
            <summary>
            It's a grace period to serve staled content without revalidation.
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="https://www.rfc-editor.org/rfc/rfc5861.html#section-3"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Best.HTTP.Caching.CacheMetadataContent.StaleIfError">
            <summary>
            Allows the client to serve stale content if the server responds with an 5xx error.
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="https://www.rfc-editor.org/rfc/rfc5861.html#section-4"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Best.HTTP.Caching.CacheMetadataContent.Flags">
            <summary>
            bool values packed into one single flag.
            </summary>
        </member>
        <member name="F:Best.HTTP.Caching.CacheMetadataContent.RequestTime">
            <summary>
            The value of the clock at the time of the request that resulted in the stored response.
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="https://www.rfc-editor.org/rfc/rfc9111.html#section-4.2.3-3.8"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Best.HTTP.Caching.CacheMetadataContent.ResponseTime">
            <summary>
            The value of the clock at the time the response was received.
            </summary>
        </member>
        <member name="T:Best.HTTP.Caching.HTTPCacheOptions">
            <summary>
            Represents the configuration options for the HTTP cache.
            </summary>
        </member>
        <member name="P:Best.HTTP.Caching.HTTPCacheOptions.DeleteOlder">
            <summary>
            Gets or sets the maximum duration for which cached entries will be retained.
            </summary>
        </member>
        <member name="P:Best.HTTP.Caching.HTTPCacheOptions.MaxCacheSize">
            <summary>
            Gets or sets the maximum size, in bytes, that the cache can reach.
            </summary>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCacheOptions.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Best.HTTP.Caching.HTTPCacheOptions"/> class with default settings.
            </summary>
        </member>
        <member name="M:Best.HTTP.Caching.HTTPCacheOptions.#ctor(System.TimeSpan,System.UInt64)">
            <summary>
            Initializes a new instance of the <see cref="T:Best.HTTP.Caching.HTTPCacheOptions"/> class with custom settings.
            </summary>
            <param name="deleteOlder">The maximum age for cached entries to be retained.</param>
            <param name="maxCacheSize">The maximum size, in bytes, that the cache can reach.</param>
        </member>
        <member name="T:Best.HTTP.Cookies.Cookie">
            <summary>
            The Cookie implementation based on <see href="http://tools.ietf.org/html/rfc6265">RFC-6265</see>.
            </summary>
        </member>
        <member name="P:Best.HTTP.Cookies.Cookie.Name">
            <summary>
            The name of the cookie.
            </summary>
        </member>
        <member name="P:Best.HTTP.Cookies.Cookie.Value">
            <summary>
            The value of the cookie.
            </summary>
        </member>
        <member name="P:Best.HTTP.Cookies.Cookie.Date">
            <summary>
            The Date when the Cookie is registered.
            </summary>
        </member>
        <member name="P:Best.HTTP.Cookies.Cookie.LastAccess">
            <summary>
            When this Cookie last used in a request.
            </summary>
        </member>
        <member name="P:Best.HTTP.Cookies.Cookie.Expires">
            <summary>
            The Expires attribute indicates the maximum lifetime of the cookie, represented as the date and time at which the cookie expires.
            The user agent is not required to retain the cookie until the specified date has passed.
            In fact, user agents often evict cookies due to memory pressure or privacy concerns.
            </summary>
        </member>
        <member name="P:Best.HTTP.Cookies.Cookie.MaxAge">
            <summary>
            The Max-Age attribute indicates the maximum lifetime of the cookie, represented as the number of seconds until the cookie expires.
            The user agent is not required to retain the cookie for the specified duration.
            In fact, user agents often evict cookies due to memory pressure or privacy concerns.
            </summary>
        </member>
        <member name="P:Best.HTTP.Cookies.Cookie.IsSession">
            <summary>
            If a cookie has neither the Max-Age nor the Expires attribute, the user agent will retain the cookie until "the current session is over".
            </summary>
        </member>
        <member name="P:Best.HTTP.Cookies.Cookie.Domain">
            <summary>
            The Domain attribute specifies those hosts to which the cookie will be sent.
            For example, if the value of the Domain attribute is "example.com", the user agent will include the cookie
            in the Cookie header when making HTTP requests to example.com, www.example.com, and www.corp.example.com.
            If the server omits the Domain attribute, the user agent will return the cookie only to the origin server.
            </summary>
        </member>
        <member name="P:Best.HTTP.Cookies.Cookie.Path">
            <summary>
            The scope of each cookie is limited to a set of paths, controlled by the Path attribute.
            If the server omits the Path attribute, the user agent will use the "directory" of the request-uri's path component as the default value.
            </summary>
        </member>
        <member name="P:Best.HTTP.Cookies.Cookie.IsSecure">
            <summary>
            The Secure attribute limits the scope of the cookie to "secure" channels (where "secure" is defined by the user agent).
            When a cookie has the Secure attribute, the user agent will include the cookie in an HTTP request only if the request is
            transmitted over a secure channel (typically HTTP over Transport Layer Security (TLS)).
            </summary>
        </member>
        <member name="P:Best.HTTP.Cookies.Cookie.IsHttpOnly">
            <summary>
            The HttpOnly attribute limits the scope of the cookie to HTTP requests.
            In particular, the attribute instructs the user agent to omit the cookie when providing access to
            cookies via "non-HTTP" APIs (such as a web browser API that exposes cookies to scripts).
            </summary>
        </member>
        <member name="P:Best.HTTP.Cookies.Cookie.SameSite">
            <summary>
            SameSite prevents the browser from sending this cookie along with cross-site requests.
            The main goal is mitigate the risk of cross-origin information leakage.
            It also provides some protection against cross-site request forgery attacks.
            Possible values for the flag are lax or strict.
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="https://web.dev/samesite-cookies-explained/">SameSite cookies explained</see></description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Best.HTTP.Cookies.Cookie.GuessSize">
            <summary>
            Guess the storage size of the cookie.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Best.HTTP.Cookies.CookieJar">
            <summary>
            The Cookie Jar implementation based on RFC 6265(http://tools.ietf.org/html/rfc6265).
            </summary>
        </member>
        <member name="P:Best.HTTP.Cookies.CookieJar.MaximumSize">
            <summary>
            Maximum size of the Cookie Jar in bytes. It's default value is 10485760 (10 MB).
            </summary>
        </member>
        <member name="P:Best.HTTP.Cookies.CookieJar.IsSavingSupported">
            <summary>
            Returns true if File apis are supported.
            </summary>
        </member>
        <member name="F:Best.HTTP.Cookies.CookieJar.AccessThreshold">
            <summary>
            The plugin will delete cookies that are accessed this threshold ago. Its default value is 7 days.
            </summary>
        </member>
        <member name="F:Best.HTTP.Cookies.CookieJar.IsSessionOverride">
            <summary>
            If this property is set to <c>true</c>, then new cookies treated as session cookies and these cookies are not saved to disk. Its default value is <c>false</c>.
            </summary>
        </member>
        <member name="F:Best.HTTP.Cookies.CookieJar.Cookies">
            <summary>
            List of the Cookies
            </summary>
        </member>
        <member name="F:Best.HTTP.Cookies.CookieJar.rwLock">
            <summary>
            Synchronization object for thread safety.
            </summary>
        </member>
        <member name="M:Best.HTTP.Cookies.CookieJar.SetFromRequest(Best.HTTP.HTTPResponse)">
            <summary>
            Will set or update all cookies from the response object.
            </summary>
        </member>
        <member name="M:Best.HTTP.Cookies.CookieJar.Maintain(System.Boolean)">
            <summary>
            Deletes all expired or 'old' cookies, and will keep the sum size of cookies under the given size.
            </summary>
        </member>
        <member name="M:Best.HTTP.Cookies.CookieJar.Persist">
            <summary>
            Saves the Cookie Jar to a file.
            </summary>
            <remarks>Not implemented under Unity WebPlayer</remarks>
        </member>
        <member name="M:Best.HTTP.Cookies.CookieJar.Load">
            <summary>
            Load previously persisted cookie library from the file.
            </summary>
        </member>
        <member name="M:Best.HTTP.Cookies.CookieJar.Get(System.Uri)">
            <summary>
            Returns all Cookies that corresponds to the given Uri.
            </summary>
        </member>
        <member name="M:Best.HTTP.Cookies.CookieJar.Set(System.Uri,Best.HTTP.Cookies.Cookie)">
            <summary>
            Will add a new, or overwrite an old cookie if already exists.
            </summary>
        </member>
        <member name="M:Best.HTTP.Cookies.CookieJar.Set(Best.HTTP.Cookies.Cookie)">
            <summary>
            Will add a new, or overwrite an old cookie if already exists.
            </summary>
        </member>
        <member name="M:Best.HTTP.Cookies.CookieJar.Clear">
            <summary>
            Deletes all cookies from the Jar.
            </summary>
        </member>
        <member name="M:Best.HTTP.Cookies.CookieJar.Clear(System.TimeSpan)">
            <summary>
            Removes cookies that older than the given parameter.
            </summary>
        </member>
        <member name="M:Best.HTTP.Cookies.CookieJar.Clear(System.String)">
            <summary>
            Removes cookies that matches to the given domain.
            </summary>
        </member>
        <member name="M:Best.HTTP.Cookies.CookieJar.Find(Best.HTTP.Cookies.Cookie,System.Int32@)">
            <summary>
            Find and return a Cookie and his index in the list.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.ConnectionBase">
            <summary>
            Abstract base class for concrete connection implementation (HTTP/1, HTTP/2, WebGL, File).
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.ConnectionBase.HostKey">
            <summary>
            The address of the server that this connection is bound to.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.ConnectionBase.State">
            <summary>
            The state of this connection.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.ConnectionBase.CurrentRequest">
            <summary>
            If the State is HTTPConnectionStates.Processing, then it holds a HTTPRequest instance. Otherwise it's null.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.ConnectionBase.KeepAliveTime">
            <summary>
            How much the connection kept alive after its last request processing.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.ConnectionBase.AssignedRequests">
            <summary>
            Number of assigned requests to process.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.ConnectionBase.MaxAssignedRequests">
            <summary>
            Maximum number of assignable requests.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.ConnectionBase.StartTime">
            <summary>
            When we start to process the current request. It's set after the connection is established.
            </summary>
        </member>
        <member name="M:Best.HTTP.Hosts.Connections.ConnectionBase.Shutdown(Best.HTTP.Shared.ShutdownTypes)">
            <summary>
            Called when the plugin shuts down immediately.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.KeepAliveHeader">
            <summary>
            https://tools.ietf.org/html/draft-thomson-hybi-http-timeout-03
            Test servers: http://tools.ietf.org/ http://nginx.org/
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.KeepAliveHeader.TimeOut">
            <summary>
            A host sets the value of the "timeout" parameter to the time that the host will allow an idle connection to remain open before it is closed. A connection is idle if no data is sent or received by a host.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.KeepAliveHeader.MaxRequests">
            <summary>
            The "max" parameter has been used to indicate the maximum number of requests that would be made on the connection.This parameter is deprecated.Any limit on requests can be enforced by sending "Connection: close" and closing the connection.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.ConnectionHelper">
            <summary>
            Static helper class to handle cases where the plugin has to do additional logic based on the received response. These are like connection management, handling redirections, loading from local cache, authentication challanges, etc.
            </summary>
        </member>
        <member name="M:Best.HTTP.Hosts.Connections.ConnectionHelper.HandleResponse(Best.HTTP.HTTPRequest,System.Boolean@,Best.HTTP.Hosts.Connections.HTTPConnectionStates@,Best.HTTP.Hosts.Connections.KeepAliveHeader@,Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Called when the whole response received
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.HTTP1.HTTP1ContentConsumer.AssignedRequests">
            <summary>
            Number of assigned requests to process.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.HTTP1.HTTP1ContentConsumer.MaxAssignedRequests">
            <summary>
            Maximum number of assignable requests
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.HTTP1.PeekableHTTP1Response">
            <summary>
            An HTTP 1.1 response implementation that can utilize a peekable stream.
            Its main entry point is the ProcessPeekable method that should be called after every chunk of data downloaded.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.HTTP2.WebSocketOverHTTP2Settings">
            <summary>
            Settings for HTTP/2 connections when the Connect protocol is available.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.HTTP2.WebSocketOverHTTP2Settings.EnableWebSocketOverHTTP2">
            <summary>
            Set it to false to disable Websocket Over HTTP/2 (RFC 8441). It's true by default.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.HTTP2.WebSocketOverHTTP2Settings.EnableImplementationFallback">
            <summary>
            Set it to disable fallback logic from the Websocket Over HTTP/2 implementation to the 'old' HTTP/1 implementation when it fails to connect.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.HTTP2.HTTP2ConnectionSettings">
            <summary>
            Settings for HTTP/2 connections.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2ConnectionSettings.EnableHTTP2Connections">
            <summary>
            When set to false, the plugin will not try to use HTTP/2 connections.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2ConnectionSettings.HeaderTableSize">
            <summary>
            Maximum size of the HPACK header table.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2ConnectionSettings.MaxConcurrentStreams">
            <summary>
            Maximum concurrent http2 stream on http2 connection will allow. Its default value is 128;
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2ConnectionSettings.InitialStreamWindowSize">
            <summary>
            Initial window size of a http2 stream. Its default value is 65535, can be controlled through the HTTPRequest's DownloadSettings object.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2ConnectionSettings.InitialConnectionWindowSize">
            <summary>
            Global window size of a http/2 connection. Its default value is the maximum possible value on 31 bits.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2ConnectionSettings.MaxFrameSize">
            <summary>
            Maximum size of a http2 frame.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2ConnectionSettings.MaxHeaderListSize">
            <summary>
            Not used.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2ConnectionSettings.MaxIdleTime">
            <summary>
            With HTTP/2 only one connection will be open so we can keep it open longer as we hope it will be reused more.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2ConnectionSettings.PingFrequency">
            <summary>
            Time between two ping messages.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2ConnectionSettings.Timeout">
            <summary>
            Timeout to receive a ping acknowledgement from the server. If no ack reveived in this time the connection will be treated as broken.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2ConnectionSettings.EnableConnectProtocol">
            <summary>
            Set to true to enable RFC 8441 "Bootstrapping WebSockets with HTTP/2" (https://tools.ietf.org/html/rfc8441).
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2ConnectionSettings.WebSocketOverHTTP2Settings">
            <summary>
            Settings for WebSockets over HTTP/2 (RFC 8441)
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.HTTP2.HTTP2AltSVCFrame">
            <summary>
            https://tools.ietf.org/html/rfc7838#section-4
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.HTTP2.HTTP2Settings">
            <summary>
            <see href="https://httpwg.org/specs/rfc7540.html#iana-settings">Settings Registry</see>
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2Settings.HEADER_TABLE_SIZE">
            <summary>
            Allows the sender to inform the remote endpoint of the maximum size of the
            header compression table used to decode header blocks, in octets.
            The encoder can select any size equal to or less than this value
            by using signaling specific to the header compression format inside a header block (see [COMPRESSION]).
            The initial value is 4,096 octets.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2Settings.ENABLE_PUSH">
            <summary>
            This setting can be used to disable server push (Section 8.2).
            An endpoint MUST NOT send a PUSH_PROMISE frame if it receives this parameter set to a value of 0.
            An endpoint that has both set this parameter to 0 and had it acknowledged MUST treat the receipt of a
            PUSH_PROMISE frame as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
            
            The initial value is 1, which indicates that server push is permitted.
            Any value other than 0 or 1 MUST be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2Settings.MAX_CONCURRENT_STREAMS">
            <summary>
            Indicates the maximum number of concurrent streams that the sender will allow. This limit is directional:
            it applies to the number of streams that the sender permits the receiver to create.
            Initially, there is no limit to this value. It is recommended that this value be no smaller than 100,
            so as to not unnecessarily limit parallelism.
            
            A value of 0 for SETTINGS_MAX_CONCURRENT_STREAMS SHOULD NOT be treated as special by endpoints.
            A zero value does prevent the creation of new streams;
            however, this can also happen for any limit that is exhausted with active streams.
            Servers SHOULD only set a zero value for short durations; if a server does not wish to accept requests,
            closing the connection is more appropriate.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2Settings.INITIAL_WINDOW_SIZE">
             <summary>
             Indicates the sender's initial window size (in octets) for stream-level flow control.
             The initial value is 2^16-1 (65,535) octets.
            
             This setting affects the window size of all streams (see Section 6.9.2).
            
             Values above the maximum flow-control window size of 2^31-1 MUST be treated as a connection error
             (Section 5.4.1) of type FLOW_CONTROL_ERROR.
             </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2Settings.MAX_FRAME_SIZE">
             <summary>
             Indicates the size of the largest frame payload that the sender is willing to receive, in octets.
            
             The initial value is 2^14 (16,384) octets.
             The value advertised by an endpoint MUST be between this initial value and the maximum allowed frame size
             (2^24-1 or 16,777,215 octets), inclusive.
             Values outside this range MUST be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
             </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2Settings.MAX_HEADER_LIST_SIZE">
             <summary>
             This advisory setting informs a peer of the maximum size of header list that the sender is prepared to accept, in octets.
             The value is based on the uncompressed size of header fields,
             including the length of the name and value in octets plus an overhead of 32 octets for each header field.
            
             For any given request, a lower limit than what is advertised MAY be enforced. The initial value of this setting is unlimited.
             </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2Settings.ENABLE_CONNECT_PROTOCOL">
            <summary>
            https://tools.ietf.org/html/rfc8441
             Upon receipt of SETTINGS_ENABLE_CONNECT_PROTOCOL with a value of 1, a client MAY use the Extended CONNECT as defined in this document when creating new streams.
             Receipt of this parameter by a server does not have any impact.
             
             A sender MUST NOT send a SETTINGS_ENABLE_CONNECT_PROTOCOL parameter with the value of 0 after previously sending a value of 1.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsRegistry">
            <summary>
            Represents a registry for HTTP/2 settings.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsRegistry.IsReadOnly">
            <summary>
            Gets a value indicating whether the registry is read-only.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsRegistry.OnSettingChangedEvent">
            <summary>
            Event triggered when a setting changes.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsRegistry.Item(Best.HTTP.Hosts.Connections.HTTP2.HTTP2Settings)">
            <summary>
            Indexer to get or set values based on an <see cref="T:Best.HTTP.Hosts.Connections.HTTP2.HTTP2Settings"/> key.
            </summary>
            <param name="setting">The setting key.</param>
            <returns>The value associated with the given setting key.</returns>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsRegistry.IsChanged">
            <summary>
            Gets a value indicating whether any setting has changed.
            </summary>
        </member>
        <member name="M:Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsRegistry.#ctor(Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsManager,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the HTTP2SettingsRegistry class.
            </summary>
            <param name="parent">The parent <see cref="T:Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsManager"/>.</param>
            <param name="readOnly">Whether this registry is read-only.</param>
            <param name="treatItAsAlreadyChanged">Whether to treat the registry as if a setting has already changed.</param>
        </member>
        <member name="M:Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsRegistry.Merge(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{Best.HTTP.Hosts.Connections.HTTP2.HTTP2Settings,System.UInt32}})">
            <summary>
            Merges the specified settings into the current registry.
            </summary>
            <param name="settings">The settings to merge.</param>
        </member>
        <member name="M:Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsRegistry.Merge(Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsRegistry)">
            <summary>
            Merges settings from another HTTP2SettingsRegistry into the current registry.
            </summary>
            <param name="from">The registry to merge settings from.</param>
        </member>
        <member name="M:Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsRegistry.CreateFrame(Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            Creates a new HTTP/2 frame based on the current registry settings.
            </summary>
            <param name="context">The logging context.</param>
            <returns>A new HTTP/2 frame.</returns>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsManager">
            <summary>
            Class to manager local and remote HTTP/2 settings.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsManager.MySettings">
            <summary>
            This is the ACKd or default settings that we sent to the server.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsManager.InitiatedMySettings">
            <summary>
            This is the setting that can be changed. It will be sent to the server ASAP, and when ACKd, it will be copied
            to MySettings.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsManager.RemoteSettings">
            <summary>
            Settings of the remote peer
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.HTTP2.HTTP2Stream">
            <summary>
            Implements an HTTP/2 logical stream.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.HTTP2.HTTP2Stream.HasFrameToSend">
            <summary>
            This flag is checked by the connection to decide whether to do a new processing-frame sending round before sleeping until new data arrives
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.HTTP2.HTTP2Stream.NextInteraction">
            <summary>
            Next interaction scheduled by the stream relative to *now*. Its default is TimeSpan.MaxValue == no interaction.
            </summary>
        </member>
        <member name="M:Best.HTTP.Hosts.Connections.HTTP2.HTTP2Stream.#ctor(System.UInt32,Best.HTTP.Hosts.Connections.HTTP2.HTTP2ContentConsumer,Best.HTTP.Hosts.Connections.HTTP2.HTTP2SettingsManager,Best.HTTP.Hosts.Connections.HTTP2.HPACKEncoder)">
            <summary>
            Constructor to create a client stream.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.HTTP2.HuffmanTableEntry">
            <summary>
            A pre-generated table entry in a Huffman-Tree.
            </summary>
        </member>
        <member name="M:Best.HTTP.Hosts.Connections.HTTP2.HuffmanTableEntry.GetBitAtIdx(System.Byte)">
            <summary>
            It must return 0 or 1 at bit index. Indexing will be relative to the Bits representing the current code. Idx grows from left to right. Idx must be between [1..Bits].
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.HTTPConnectionStates">
            <summary>
            Possible states of a Http Connection.
            The ideal lifecycle of a connection that has KeepAlive is the following: Initial => [Processing => WaitForRecycle => Free] => Closed.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTPConnectionStates.Initial">
            <summary>
            This Connection instance is just created.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTPConnectionStates.Processing">
            <summary>
            This Connection is processing a request
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTPConnectionStates.WaitForProtocolShutdown">
            <summary>
            Wait for the upgraded protocol to shut down.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTPConnectionStates.Recycle">
            <summary>
            The Connection is finished processing the request, it's waiting now to deliver it's result.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTPConnectionStates.Free">
            <summary>
            The request result's delivered, it's now up to processing again.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTPConnectionStates.Closed">
            <summary>
            If it's not a KeepAlive connection, or something happened, then we close this connection and remove from the pool.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Connections.HTTPConnectionStates.ClosedResendRequest">
            <summary>
            Same as the Closed state, but processing this request requires resending the last processed request too.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.HTTPOverTCPConnection">
            <summary>
            Represents and manages a connection to a server.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.HTTPOverTCPConnection.AssignedRequests">
            <summary>
            Number of assigned requests to process.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.HTTPOverTCPConnection.MaxAssignedRequests">
            <summary>
            Maximum number of assignable requests.
            </summary>
        </member>
        <member name="M:Best.HTTP.Hosts.Connections.HTTPOverTCPConnection.TrySetErrorState(Best.HTTP.HTTPRequest,System.Exception)">
            <summary>
            Returns true if an error state is set to the request and the connection is closing.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.IDownloadContentBufferAvailable">
            <summary>
            Defines an interface for notifying connections when space becomes available in a buffer for downloading data.
            Connections implementating of this interface are used to signal their internal logic that they can transfer data into the available buffer space.
            </summary>
        </member>
        <member name="M:Best.HTTP.Hosts.Connections.IDownloadContentBufferAvailable.BufferAvailable(Best.HTTP.Response.DownloadContentStream)">
            <summary>
            Notifies a connection that space has become available in the buffer for downloading data.
            When invoked, this method indicates to a connection that it can transfer additional data into the buffer for further processing.
            </summary>
            <param name="stream">The <see cref="T:Best.HTTP.Response.DownloadContentStream"/> instance associated with the buffer.</param>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.IHTTPRequestHandler">
            <summary>
            Common interface for implementations that will coordinate request processing inside a connection.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.IHTTPRequestHandler.AssignedRequests">
            <summary>
            Number of assigned requests to process.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.IHTTPRequestHandler.MaxAssignedRequests">
            <summary>
            Maximum number of assignable requests.
            </summary>
        </member>
        <member name="M:Best.HTTP.Hosts.Connections.IHTTPRequestHandler.Shutdown(Best.HTTP.Shared.ShutdownTypes)">
            <summary>
            An immediate shutdown request that called only on application closure.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Connections.IThreadSignaler">
            <summary>
            Interface for signaling upload threads.
            </summary>
        </member>
        <member name="P:Best.HTTP.Hosts.Connections.IThreadSignaler.Context">
            <summary>
            A <see cref="T:Best.HTTP.Shared.Logger.LoggingContext"/> instance for debugging purposes.
            </summary>
            <remarks>
            To help <see cref="T:Best.HTTP.Request.Upload.UploadStreamBase"/> implementors log in the IThreadSignaler's context,
            the interface implementors must make their logging context accessible.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Hosts.Connections.IThreadSignaler.SignalThread">
            <summary>
            Signals the associated thread to resume or wake up.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Settings.AsteriskStringComparer">
            <summary>
            Moves any added asterisk(*) to the end of the list.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Settings.TlsClientFactoryDelegate">
            <summary>
            Delegate for creating a TLS 1.3 client instance.
            </summary>
            <param name="uri">The URI of the request.</param>
            <param name="protocols">A list of supported TLS ALPN protocols.</param>
            <param name="context">The logging context for the operation.</param>
            <returns>A TLS 1.3 client instance.</returns>
        </member>
        <member name="T:Best.HTTP.Hosts.Settings.HTTRequestSettings">
            <summary>
            Settings for HTTP requests.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.HTTRequestSettings.ConnectTimeout">
            <summary>
            The timeout for establishing a connection.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.HTTRequestSettings.RequestTimeout">
            <summary>
            The maximum time allowed for the request to complete.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Settings.HTTP1ConnectionSettings">
            <summary>
            Settings for HTTP/1 connections.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.HTTP1ConnectionSettings.TryToReuseConnections">
            <summary>
            Indicates whether the connection should be open after receiving the response.
            </summary>
            <remarks>
            If set to <c>true</c>, internal TCP connections will be reused whenever possible.
            If making rare requests to the server, it's recommended to change this to <c>false</c>.
            </remarks>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.HTTP1ConnectionSettings.MaxConnectionIdleTime">
            <summary>
            The maximum time a connection can remain idle before being closed.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Settings.ClientCertificateSelector">
            <summary>
            Delegate for selecting a client certificate.
            </summary>
            <param name="targetHost">The target host.</param>
            <param name="localCertificates">A collection of local certificates.</param>
            <param name="remoteCertificate">The remote certificate.</param>
            <param name="acceptableIssuers">An array of acceptable certificate issuers.</param>
            <returns>The selected X.509 certificate.</returns>
        </member>
        <member name="T:Best.HTTP.Hosts.Settings.TLSHandlers">
            <summary>
            Available TLS handlers.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.TLSHandlers.BouncyCastle">
            <summary>
            To use the 3rd party BouncyCastle implementation.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.TLSHandlers.Framework">
            <summary>
            To use .net's SslStream.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Settings.BouncyCastleSettings">
            <summary>
            Settings for Bouncy Castle TLS.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.BouncyCastleSettings.TlsClientFactory">
            <summary>
            Delegate for creating a TLS 1.3 client instance using Bouncy Castle.
            </summary>
        </member>
        <member name="M:Best.HTTP.Hosts.Settings.BouncyCastleSettings.DefaultTlsClientFactory(System.Uri,System.Collections.Generic.List{Best.HTTP.SecureProtocol.Org.BouncyCastle.Tls.ProtocolName},Best.HTTP.Shared.Logger.LoggingContext)">
            <summary>
            The default TLS 1.3 client factory.
            </summary>
            <param name="uri">The URI of the request.</param>
            <param name="protocols">A list of supported TLS ALPN protocols.</param>
            <param name="context">The logging context for the operation.</param>
            <returns>A TLS 1.3 client instance.</returns>
        </member>
        <member name="T:Best.HTTP.Hosts.Settings.FrameworkTLSSettings">
            <summary>
            Settings for .NET's SslStream based handler.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.FrameworkTLSSettings.TlsVersions">
            <summary>
            The supported TLS versions.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.FrameworkTLSSettings.CheckCertificateRevocation">
            <summary>
            Indicates whether to check certificate revocation.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.FrameworkTLSSettings.DefaultCertificationValidator">
            <summary>
            The default certification validator.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.FrameworkTLSSettings.ClientCertificationProvider">
            <summary>
            Delegate for providing a client certificate.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Settings.TLSSettings">
            <summary>
            Settings for TLS.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.TLSSettings.TLSHandler">
            <summary>
            The selected TLS handler.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.TLSSettings.BouncyCastleSettings">
            <summary>
            Settings for Bouncy Castle.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.TLSSettings.FrameworkTLSSettings">
            <summary>
            .NET's SslStream settings.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Settings.HostVariantSettings">
            <summary>
            Settings for <see cref="T:Best.HTTP.HostSetting.HostVariant"/>s.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.HostVariantSettings.MaxConnectionPerVariant">
            <summary>
            The maximum number of connections allowed per host variant.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.HostVariantSettings.MaxAssignedRequestsFactor">
            <summary>
            Factor used when calculations are made whether to open a new connection to the server or not.
            </summary>
            <remarks>
            It has an effect on HTTP/2 connections only.
            <para>Higher values (gte <c>1.0f</c>) delay, lower values (lte <c>1.0f</c>) bring forward creation of new connections.</para>
            </remarks>
        </member>
        <member name="T:Best.HTTP.Hosts.Settings.LowLevelConnectionSettings">
            <summary>
            Represents the low-level TCP buffer settings for connections.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.LowLevelConnectionSettings.TCPWriteBufferSize">
            <summary>
            Gets or sets the size of the TCP write buffer in bytes. 
            </summary>
            <remarks>
            <para>Default value is 1 MiB.</para>
            <para>This determines the maximum amount of data that that the <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/> class can buffer up if it's already in a write operation.
            Increasing this value can potentially improve write performance, especially for large messages or data streams. 
            However, setting it too high might consume a significant amount of memory, especially if there are many active connections.
            </para>
            </remarks>
            <value>The size of the TCP write buffer in bytes.</value>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.LowLevelConnectionSettings.ReadBufferSize">
            <summary>
            Gets or sets the size of the read buffer in bytes. 
            </summary>
            <value>The size of the read buffer in bytes.</value>
            <remarks>
            <para>Default value is 1 MiB.</para>
            <para>This determines the maximum amount of data that low level streams and the <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.TCPStreamer"/> can buffer up for consuming by higher level layers.
            Adjusting this value can affect the read performance of the application. 
            Like the write buffer, setting this too high might be memory-intensive, especially with many connections. 
            It's advised to find a balance that suits the application's needs and resources.
            </para>
            </remarks>
        </member>
        <member name="T:Best.HTTP.Hosts.Settings.HostSettings">
            <summary>
            Contains settings that can be associated with a specific host or host variant.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.HostSettings.LowLevelConnectionSettings">
            <summary>
            Gets or sets the low-level TCP buffer settings for connections associated with the host or host variant.
            </summary>
            <value>The low-level TCP buffer settings.</value>
            <remarks>
            These settings determine the buffer sizes for reading from and writing to TCP connections, 
            which can impact performance and memory usage.
            </remarks>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.HostSettings.RequestSettings">
            <summary>
            Settings related to HTTP requests made to this host or host variant.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.HostSettings.HTTP1ConnectionSettings">
            <summary>
            Settings related to HTTP/1.x connection behavior.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.HostSettings.TCPRingmasterSettings">
            <summary>
            Settings related to TCP Ringmaster used in non-webgl platforms.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.HostSettings.HTTP2ConnectionSettings">
            <summary>
            Settings related to HTTP/2 connection behavior.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.HostSettings.TLSSettings">
            <summary>
            Settings related to TLS (Transport Layer Security) behavior.
            </summary>
        </member>
        <member name="F:Best.HTTP.Hosts.Settings.HostSettings.HostVariantSettings">
            <summary>
            Settings related to <see cref="T:Best.HTTP.HostSetting.HostVariant"/> behavior.
            </summary>
        </member>
        <member name="T:Best.HTTP.Hosts.Settings.HostSettingsManager">
            Host Settings Hierarchy for the following hosts, settings are stored as leafs:
            
            *.com
            *.example.com
            example.com
            
            '*' matches one or more subdomains so *.example.com 
             - matches a.example.com and a.b.example.com
             - but doesn't match example.com!
            
                                         
                                          
                               [com]                 [localhost]                [org]                      [*]
                          +------+------+                 |                       |                         |
                          |             |              [setting]                 [*]                     [setting]
                    [example]          [*]                                        |
                    /       \           |                                      [setting]
                  [b]     [setting]  [setting]
                   |
                  [a]
                   |
                [setting]
            
            <summary>
            Manages host-specific settings for HTTP requests based on hostnames.
            The HostSettingsManager is a powerful tool for fine-tuning HTTP request and connection behaviors
            on a per-host basis. It enables you to define custom settings for specific hostnames 
            while maintaining default settings for all other hosts. This level of granularity allows you to
            optimize and customize HTTP requests for different endpoints within your application.
            </summary>
            <remarks>
            When host-specific settings are not found for a given host variant, the default <see cref="T:Best.HTTP.Hosts.Settings.HostSettings"/>
            associated with the "*" host will be returned.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Hosts.Settings.HostSettingsManager.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Best.HTTP.Hosts.Settings.HostSettingsManager"/> class with default settings for all hosts ("*").
            </summary>
        </member>
        <member name="M:Best.HTTP.Hosts.Settings.HostSettingsManager.AddDefault(System.Uri)">
            <summary>
            Adds default settings for the host part of the specified URI. This is equivalent to calling <see cref="M:Best.HTTP.Hosts.Settings.HostSettingsManager.Add(System.Uri,Best.HTTP.Hosts.Settings.HostSettings)"/> with the a new <see cref="T:Best.HTTP.Hosts.Settings.HostSettings"/>.
            </summary>
            <param name="uri">The URI for which default settings should be applied. Only the host part of the URI will be used.</param>
            <returns>A <see cref="T:Best.HTTP.Hosts.Settings.HostSettings"/> instance with default values.</returns>
        </member>
        <member name="M:Best.HTTP.Hosts.Settings.HostSettingsManager.AddDefault(System.String)">
            <summary>
            Adds default settings for the the specified host name. This is equivalent to calling <see cref="M:Best.HTTP.Hosts.Settings.HostSettingsManager.Add(System.String,Best.HTTP.Hosts.Settings.HostSettings)"/> with the a new <see cref="T:Best.HTTP.Hosts.Settings.HostSettings"/>.
            </summary>
            <param name="hostname">The hostname for which default settings should be applied.</param>
            <returns>A <see cref="T:Best.HTTP.Hosts.Settings.HostSettings"/> instance with default values.</returns>
        </member>
        <member name="M:Best.HTTP.Hosts.Settings.HostSettingsManager.Add(System.Uri,Best.HTTP.Hosts.Settings.HostSettings)">
            <summary>
            Adds host-specific settings for the host part of the specified URI.
            </summary>
            <param name="uri">The URI for which settings should be applied. Only the host part of the URI will be used.</param>
            <param name="settings">The <see cref="T:Best.HTTP.Hosts.Settings.HostSettings"/> to apply.</param>
        </member>
        <member name="M:Best.HTTP.Hosts.Settings.HostSettingsManager.Add(System.String,Best.HTTP.Hosts.Settings.HostSettings)">
            <summary>
            Adds host-specific settings for the specified hostname.
            </summary>
            <param name="hostname">The hostname for which settings should be applied.</param>
            <param name="settings">The <see cref="T:Best.HTTP.Hosts.Settings.HostSettings"/> to apply.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either the hostname or settings is null.</exception>
            <exception cref="T:System.FormatException">Thrown when the hostname contains more than one asterisk ('*').</exception>
        </member>
        <member name="M:Best.HTTP.Hosts.Settings.HostSettingsManager.Get(Best.HTTP.HostSetting.HostVariant)">
            <summary>
            Gets <see cref="T:Best.HTTP.Hosts.Settings.HostSettings"/> for the host part of the specified <see cref="T:Best.HTTP.HostSetting.HostVariant"/>. Returns the default settings associated with "*" when not found.
            </summary>
            <param name="variant">The <see cref="T:Best.HTTP.HostSetting.HostVariant"/> for which settings should be retrieved. Only the host part of the variant will be used.</param>
            <returns>The host settings for the specified host variant or the default settings for "*" if not found.</returns>
        </member>
        <member name="M:Best.HTTP.Hosts.Settings.HostSettingsManager.Get(Best.HTTP.HostSetting.HostKey)">
            <summary>
            Gets <see cref="T:Best.HTTP.Hosts.Settings.HostSettings"/> for the host part of the specified <see cref="T:Best.HTTP.HostSetting.HostKey"/>. Returns the default settings associated with "*" when not found.
            </summary>
            <param name="hostKey">The <see cref="T:Best.HTTP.HostSetting.HostKey"/> for which settings should be retrieved. Only the host part of the host key will be used.</param>
            <returns>The host settings for the specified host key or the default settings for "*" if not found.</returns>
        </member>
        <member name="M:Best.HTTP.Hosts.Settings.HostSettingsManager.Get(System.Uri)">
            <summary>
            Gets <see cref="T:Best.HTTP.Hosts.Settings.HostSettings"/> for the host part of the specified <see cref="T:System.Uri"/>. Returns the default settings associated with "*" when not found.
            </summary>
            <param name="uri">The <see cref="T:System.Uri"/> for which settings should be retrieved. Only the host part of the URI will be used.</param>
            <returns>The host settings for the specified URI or the default settings for "*" if not found.</returns>
        </member>
        <member name="M:Best.HTTP.Hosts.Settings.HostSettingsManager.Get(System.String)">
            <summary>
            Gets <see cref="T:Best.HTTP.Hosts.Settings.HostSettings"/> for the host part of the specified hostname. Returns the default settings associated with "*" when not found.
            </summary>
            <param name="hostname">The hostname for which settings should be retrieved. Only the host part of the hostname will be used.</param>
            <returns>The host settings for the specified hostname or the default settings for "*" if not found.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the hostname is null.</exception>
        </member>
        <member name="M:Best.HTTP.Hosts.Settings.HostSettingsManager.Clear">
            <summary>
            Clears all host-specific settings and resetting the default ("*") with default values.
            </summary>
        </member>
        <member name="T:Best.HTTP.HostSetting.HostKey">
            <summary>
            The <see cref="T:Best.HTTP.HostSetting.HostKey"/> struct represents a unique key for identifying hosts based on their <see cref="T:System.Uri"/> and <see cref="T:Best.HTTP.Request.Settings.ProxySettings"/>.
            </summary>
            <remarks>
            <para>
            The <see cref="T:Best.HTTP.HostSetting.HostKey"/> struct is designed to uniquely identify a host based on its URI (Uniform Resource Identifier) and optional proxy settings.
            It provides a way to create, compare, and hash host keys, enabling efficient host variant management in the <see cref="T:Best.HTTP.HostSetting.HostManager"/>.
            </para>
            <para>
            Key features of the <see cref="T:Best.HTTP.HostSetting.HostKey"/> struct include:
            </para>
            <list type="bullet">
                <item>
                    <term>Uniqueness</term>
                    <description>
                    Each <see cref="T:Best.HTTP.HostSetting.HostKey"/> is guaranteed to be unique for a specific host, considering both the URI and proxy settings.
                    </description>
                </item>
                <item>
                    <term>Hashing</term>
                    <description>
                    The struct provides a method to calculate a hash code for a <see cref="T:Best.HTTP.HostSetting.HostKey"/>, making it suitable for use as a dictionary key.
                    </description>
                </item>
                <item>
                    <term>Creation</term>
                    <description>
                    You can create a <see cref="T:Best.HTTP.HostSetting.HostKey"/> instance from a <see cref="T:System.Uri"/> and optional <see cref="T:Best.HTTP.Request.Settings.ProxySettings"/>.
                    </description>
                </item>
            </list>
            <para>
            Usage of the <see cref="T:Best.HTTP.HostSetting.HostKey"/> struct is typically handled internally by the BestHTTP library to manage unique hosts and optimize resource usage.
            Developers can use it when dealing with host-specific operations or customization of the library's behavior.
            </para>
            </remarks>
        </member>
        <member name="F:Best.HTTP.HostSetting.HostKey.Uri">
            <summary>
            Gets the URI (Uniform Resource Identifier) associated with the host.
            </summary>
        </member>
        <member name="F:Best.HTTP.HostSetting.HostKey.Proxy">
            <summary>
            Gets the proxy settings associated with the host.
            </summary>
        </member>
        <member name="F:Best.HTTP.HostSetting.HostKey.Key">
            <summary>
            Gets the unique hash key for the host.
            </summary>
        </member>
        <member name="P:Best.HTTP.HostSetting.HostKey.Host">
            <summary>
            Gets the host name from the URI or "file" if the URI is a file URI.
            </summary>
        </member>
        <member name="M:Best.HTTP.HostSetting.HostKey.#ctor(System.Uri,Best.HTTP.Request.Settings.ProxySettings)">
            <summary>
            Initializes a new instance of the <see cref="T:Best.HTTP.HostSetting.HostKey"/> struct with the specified URI and proxy settings.
            </summary>
            <param name="uri">The URI of the host.</param>
            <param name="proxy">The proxy settings associated with the host, or <c>null</c> if no proxy is used.</param>
        </member>
        <member name="M:Best.HTTP.HostSetting.HostKey.From(Best.HTTP.HTTPRequest)">
            <summary>
            Creates a <see cref="T:Best.HTTP.HostSetting.HostKey"/> instance from an HTTP request.
            </summary>
            <param name="request">The HTTP request from which to extract the current URI and proxy settings.</param>
            <returns>A <see cref="T:Best.HTTP.HostSetting.HostKey"/> representing the host of the HTTP request.</returns>
        </member>
        <member name="M:Best.HTTP.HostSetting.HostKey.From(System.Uri,Best.HTTP.Request.Settings.ProxySettings)">
            <summary>
            Creates a <see cref="T:Best.HTTP.HostSetting.HostKey"/> instance from a URI and proxy settings.
            </summary>
            <param name="uri">The URI of the host.</param>
            <param name="proxy">The proxy settings associated with the host, or <c>null</c> if no proxy is used.</param>
            <returns>A <see cref="T:Best.HTTP.HostSetting.HostKey"/> representing the host with the given URI and proxy settings.</returns>
        </member>
        <member name="T:Best.HTTP.HostSetting.HostManager">
            <summary>
            The <see cref="T:Best.HTTP.HostSetting.HostManager"/> class provides centralized management for <see cref="T:Best.HTTP.HostSetting.HostVariant"/> objects associated with HTTP requests and connections.
            </summary>
            <remarks>
            <para>
            The <see cref="T:Best.HTTP.HostSetting.HostManager"/> class acts as a central registry for managing <see cref="T:Best.HTTP.HostSetting.HostVariant"/> objects, each associated with a unique <see cref="T:Best.HTTP.HostSetting.HostKey"/>.
            It facilitates the creation, retrieval, and management of <see cref="T:Best.HTTP.HostSetting.HostVariant"/> instances based on HTTP requests and connections.
            </para>
            <para>
            A <see cref="T:Best.HTTP.HostSetting.HostVariant"/> represents a specific host and port combination (e.g., "http://example.com:80" or "https://example.com:443") and
            manages the connections and request queues for that host. The class ensures that a single <see cref="T:Best.HTTP.HostSetting.HostVariant"/> instance is used for
            each unique host, helping optimize resource usage and connection pooling.
            </para>
            <para>
            Key features of the <see cref="T:Best.HTTP.HostSetting.HostManager"/> class include:
            </para>
            <list type="bullet">
                <item>
                    <term>Creation and Retrieval</term>
                    <description>
                    The class allows you to create and retrieve <see cref="T:Best.HTTP.HostSetting.HostVariant"/> instances based on HTTP requests, connections, or <see cref="T:Best.HTTP.HostSetting.HostKey"/>.
                    It ensures that a single <see cref="T:Best.HTTP.HostSetting.HostVariant"/> is used for each unique host.
                    </description>
                </item>
                <item>
                    <term>Queue Management</term>
                    <description>
                    The <see cref="T:Best.HTTP.HostSetting.HostManager"/> manages the queue of pending requests for each <see cref="T:Best.HTTP.HostSetting.HostVariant"/>, ensuring efficient request processing.
                    </description>
                </item>
                <item>
                    <term>Connection Management</term>
                    <description>
                    The class handles the management of connections associated with <see cref="T:Best.HTTP.HostSetting.HostVariant"/> objects, including recycling idle connections,
                    removing idle connections, and shutting down connections when needed.
                    </description>
                </item>
            </list>
            <para>
            Usage of the <see cref="T:Best.HTTP.HostSetting.HostManager"/> class is typically transparent to developers and is handled internally by the Best HTTP library. However,
            it provides a convenient and efficient way to manage connections and requests when needed.
            </para>
            </remarks>
        </member>
        <member name="F:Best.HTTP.HostSetting.HostManager.hosts">
            <summary>
            Dictionary to store <see cref="T:Best.HTTP.HostSetting.HostKey"/>-<see cref="T:Best.HTTP.HostSetting.HostVariant"/> mappings.
            </summary>
        </member>
        <member name="M:Best.HTTP.HostSetting.HostManager.GetHostVariant(Best.HTTP.HTTPRequest)">
            <summary>
            Gets the <see cref="T:Best.HTTP.HostSetting.HostVariant"/> associated with an HTTP request.
            </summary>
            <param name="request">The HTTP request.</param>
            <returns>The <see cref="T:Best.HTTP.HostSetting.HostVariant"/> for the request's host.</returns>
        </member>
        <member name="M:Best.HTTP.HostSetting.HostManager.GetHostVariant(Best.HTTP.Hosts.Connections.ConnectionBase)">
            <summary>
            Gets the <see cref="T:Best.HTTP.HostSetting.HostVariant"/> associated with a connection.
            </summary>
            <param name="connection">The HTTP connection.</param>
            <returns>The <see cref="T:Best.HTTP.HostSetting.HostVariant"/> for the connection's host.</returns>
        </member>
        <member name="M:Best.HTTP.HostSetting.HostManager.GetHostVariant(Best.HTTP.HostSetting.HostKey)">
            <summary>
            Gets the <see cref="T:Best.HTTP.HostSetting.HostVariant"/> associated with a HostKey.
            </summary>
            <param name="key">The HostKey for which to get the HostVariant.</param>
            <returns>The <see cref="T:Best.HTTP.HostSetting.HostVariant"/> for the specified HostKey.</returns>
        </member>
        <member name="M:Best.HTTP.HostSetting.HostManager.RemoveAllIdleConnections">
            <summary>
            Removes all idle connections for all hosts.
            </summary>
        </member>
        <member name="M:Best.HTTP.HostSetting.HostManager.TryToSendQueuedRequests">
            <summary>
            Tries to send queued requests for all hosts.
            </summary>
        </member>
        <member name="M:Best.HTTP.HostSetting.HostManager.Shutdown">
            <summary>
            Shuts down all connections for all hosts.
            </summary>
        </member>
        <member name="M:Best.HTTP.HostSetting.HostManager.Clear">
            <summary>
            Clears all hosts and their associated variants.
            </summary>
        </member>
        <member name="T:Best.HTTP.HostSetting.HostProtocolSupport">
            <summary>
            An enumeration representing the protocol support for a host.
            </summary>
        </member>
        <member name="F:Best.HTTP.HostSetting.HostProtocolSupport.Unknown">
            <summary>
            Protocol support is unknown or undetermined.
            </summary>
        </member>
        <member name="F:Best.HTTP.HostSetting.HostProtocolSupport.HTTP1">
            <summary>
            The host supports HTTP/1.
            </summary>
        </member>
        <member name="F:Best.HTTP.HostSetting.HostProtocolSupport.HTTP2">
            <summary>
            The host supports HTTP/2.
            </summary>
        </member>
        <member name="F:Best.HTTP.HostSetting.HostProtocolSupport.File">
            <summary>
            This is a file-based host.
            </summary>
        </member>
        <member name="T:Best.HTTP.HostSetting.HostVariant">
            <summary>
            <para>The HostVariant class is a critical component in managing HTTP connections and handling HTTP requests for a specific host. It maintains a queue of requests and a list of active connections associated with the host, ensuring efficient utilization of available resources. Additionally, it supports protocol version detection (HTTP/1 or HTTP/2) for optimized communication with the host.</para>
            <list type="bullet">
                <item><description>It maintains a queue of requests to ensure efficient and controlled use of available connections.</description></item>
                <item><description>It supports HTTP/1 and HTTP/2 protocol versions, allowing requests to be sent using the appropriate protocol based on the host's protocol support.</description></item>
                <item><description>Provides methods for sending requests, recycling connections, managing connection state, and handling the shutdown of connections and the host variant itself.</description></item>
                <item><description>It includes logging for diagnostic purposes, helping to monitor and debug the behavior of connections and requests.</description></item>
            </list>
            <para>In summary, the HostVariant class plays a central role in managing HTTP connections and requests for a specific host, ensuring efficient and reliable communication with that host while supporting different protocol versions.</para>
            </summary>
        </member>
        <member name="T:Best.HTTP.HTTPMethods">
            <summary>
            Represents the HTTP methods used in HTTP requests.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPMethods.Get">
            <summary>
            The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI.
            If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the
            entity in the response and not the source text of the process, unless that text happens to be the output of the process.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPMethods.Head">
            <summary>
            The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response.
            The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request.
            This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself.
            This method is often used for testing hypertext links for validity, accessibility, and recent modification.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPMethods.Post">
            <summary>
            The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line.
            POST is designed to allow a uniform method to cover the following functions:
            <list type="bullet">
                <item><description>Annotation of existing resources;</description></item>
                <item><description>Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles;</description></item>
                <item><description>Providing a block of data, such as the result of submitting a form, to a data-handling process;</description></item>
                <item><description>Extending a database through an append operation.</description></item>
            </list>
            The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI.
            The posted entity is subordinate to that URI in the same way that a file is subordinate to a directory containing it,
            a news article is subordinate to a newsgroup to which it is posted, or a record is subordinate to a database.
            The action performed by the POST method might not result in a resource that can be identified by a URI. In this case,
            either 200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPMethods.Put">
            <summary>
            The PUT method requests that the enclosed entity be stored under the supplied Request-URI.
            If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server.
            If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent,
            the origin server can create the resource with that URI. If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response.
            If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request.
            If the resource could not be created or modified with the Request-URI, an appropriate error response SHOULD be given that reflects the nature of the problem.
            The recipient of the entity MUST NOT ignore any Content-* (e.g. Content-Range) headers that it does not understand or implement and MUST return a 501 (Not Implemented) response in such cases.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPMethods.Delete">
            <summary>
            The DELETE method requests that the origin server delete the resource identified by the Request-URI. This method MAY be overridden by human intervention (or other means) on the origin server.
            The client cannot be guaranteed that the operation has been carried out, even if the status code returned from the origin server indicates that the action has been completed successfully.
            However, the server SHOULD NOT indicate success unless, at the time the response is given, it intends to delete the resource or move it to an inaccessible location.
            A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has not yet been enacted, or 204 (No Content)
            if the action has been enacted but the response does not include an entity.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPMethods.Patch">
            <summary>
            The PATCH method requests that a set of changes described in the request entity be applied to the resource identified by the Request-URI.
            The set of changes is represented in a format called a "patchdocument" identified by a media type. If the Request-URI does not point to an existing resource,
            the server MAY create a new resource, depending on the patch document type (whether it can logically modify a null resource) and permissions, etc.
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="http://tools.ietf.org/html/rfc5789">RFC-5789</see></description></item>
                <item><description><see href="http://restcookbook.com/HTTP%20Methods/patch/">When should we use the PATCH HTTP method?</see></description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Best.HTTP.HTTPMethods.Trace">
            <summary>
            The HTTP TRACE method is used to perform a message loop-back test along the path to the target resource.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPMethods.Merge">
            <summary>
            The HTTP MERGE method is used to apply modifications to an existing resource.
            The MERGE HTTP method is not as commonly used as other methods like GET, POST, or PUT.
            It's often used in specific WebDAV (Web Distributed Authoring and Versioning) scenarios.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPMethods.Options">
            <summary>
            The HTTP OPTIONS method requests permitted communication options for a given URL or server.
            A client can specify a URL with this method, or an asterisk (*) to refer to the entire server.
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS">Mozilla Developer Networks - OPTIONS</see></description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Best.HTTP.HTTPMethods.Connect">
            <summary>
            The CONNECT method is primarily used in the context of HTTP proxies to establish a network connection through the proxy to a target host.
            It is used in the context of the HTTP CONNECT tunneling method.
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="https://datatracker.ietf.org/doc/html/rfc2616#section-9.9">RFC-2616</see></description></item>
                <item><description><see href="https://tools.ietf.org/html/rfc8441">RFC-8441</see></description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Best.HTTP.HTTPMethods.Query">
            <summary>
            The HTTP QUERY method is used to retrieve data based on a query parameter or search criteria.
            The QUERY method is not a standard HTTP method, and its usage may vary depending on the specific application or API you are working with.
            It might be used for querying data or resources with specific parameters.
            Details about the QUERY method would depend on the API or service you are interacting with.
            You should refer to the documentation or specifications provided by the API/service provider.
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="https://horovits.medium.com/http-s-new-method-for-data-apis-http-query-1ff71e6f73f3">HTTP's New Method For Data APIs: HTTP QUERY</see></description></item>
                <item><description><see href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-safe-method-w-body/">The HTTP QUERY Method (Draft)</see></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Best.HTTP.HTTPRange">
            <summary>
            Represents an HTTP range that specifies the byte range of a response content, received as an answer for a range-request.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRange.FirstBytePos">
            <summary>
            Gets the position of the first byte in the range that the server sent.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRange.LastBytePos">
            <summary>
            Gets the position of the last byte in the range that the server sent.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRange.ContentLength">
            <summary>
            Gets the total length of the full entity-body on the server. Returns -1 if this length is unknown or difficult to determine.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRange.IsValid">
            <summary>
            Gets a value indicating whether the HTTP range is valid.
            </summary>
        </member>
        <member name="T:Best.HTTP.OnRequestFinishedDelegate">
            <summary>
            Delegate for a callback function that is called after the request is fully processed.
            </summary>
        </member>
        <member name="T:Best.HTTP.OnHeaderEnumerationDelegate">
            <summary>
            Delegate for enumerating headers during request preparation.
            </summary>
            <param name="header">The header name.</param>
            <param name="values">A list of header values.</param>
        </member>
        <member name="T:Best.HTTP.HTTPRequest">
            <summary>
            Represents an HTTP request that allows you to send HTTP requests to remote servers and receive responses asynchronously.
            </summary>
            <remarks>
            <list type="bullet">
                <item><term>Asynchronous HTTP requests</term><description>Utilize a Task-based API for performing HTTP requests asynchronously.</description></item>
                <item><term>Unity coroutine support</term><description>Seamlessly integrate with Unity's coroutine system for coroutine-based request handling.</description></item>
                <item><term>HTTP method support</term><description>Support for various HTTP methods including GET, POST, PUT, DELETE, and more.</description></item>
                <item><term>Compression and decompression</term><description>Automatic request and response compression and decompression for efficient data transfer.</description></item>
                <item><term>Timing information</term><description>Collect detailed timing information about the request for performance analysis.</description></item>
                <item><term>Upload and download support</term><description>Support for uploading and downloading files with progress tracking.</description></item>
                <item><term>Customizable</term><description>Extensive options for customizing request headers, handling cookies, and more.</description></item>
                <item><term>Redirection handling</term><description>Automatic handling of request redirections for a seamless experience.</description></item>
                <item><term>Proxy server support</term><description>Ability to route requests through proxy servers for enhanced privacy and security.</description></item>
                <item><term>Authentication</term><description>Automatic authentication handling using authenticators for secure communication.</description></item>
                <item><term>Cancellation support</term><description>Ability to cancel requests to prevent further processing and release resources.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.CreateGet(System.String)">
            <summary>
            Creates an <see cref="F:Best.HTTP.HTTPMethods.Get">HTTP GET</see> request with the specified URL.
            </summary>
            <param name="url">The URL of the request.</param>
            <returns>An HTTPRequest instance for the GET request.</returns>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.CreateGet(System.Uri)">
            <summary>
            Creates an <see cref="F:Best.HTTP.HTTPMethods.Get">HTTP GET</see> request with the specified URI.
            </summary>
            <param name="uri">The URI of the request.</param>
            <returns>An HTTPRequest instance for the GET request.</returns>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.CreateGet(System.String,Best.HTTP.OnRequestFinishedDelegate)">
            <summary>
            Creates an <see cref="F:Best.HTTP.HTTPMethods.Get">HTTP GET</see> request with the specified URL and registers a callback function to be called
            when the request is fully processed.
            </summary>
            <param name="url">The URL of the request.</param>
            <param name="callback">A callback function to be called when the request is finished.</param>
            <returns>An HTTPRequest instance for the GET request.</returns>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.CreateGet(System.Uri,Best.HTTP.OnRequestFinishedDelegate)">
            <summary>
            Creates an <see cref="F:Best.HTTP.HTTPMethods.Get">HTTP GET</see> request with the specified URI and registers a callback function to be called
            when the request is fully processed.
            </summary>
            <param name="uri">The URI of the request.</param>
            <param name="callback">A callback function to be called when the request is finished.</param>
            <returns>An HTTPRequest instance for the GET request.</returns>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.CreatePost(System.String)">
            <summary>
            Creates an <see cref="F:Best.HTTP.HTTPMethods.Post">HTTP POST</see> request with the specified URL.
            </summary>
            <param name="url">The URL of the request.</param>
            <returns>An HTTPRequest instance for the POST request.</returns>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.CreatePost(System.Uri)">
            <summary>
            Creates an <see cref="F:Best.HTTP.HTTPMethods.Post">HTTP POST</see> request with the specified URI.
            </summary>
            <param name="uri">The URI of the request.</param>
            <returns>An HTTPRequest instance for the POST request.</returns>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.CreatePost(System.String,Best.HTTP.OnRequestFinishedDelegate)">
            <summary>
            Creates an <see cref="F:Best.HTTP.HTTPMethods.Post">HTTP POST</see> request with the specified URL and registers a callback function to be called
            when the request is fully processed.
            </summary>
            <param name="url">The URL of the request.</param>
            <param name="callback">A callback function to be called when the request is finished.</param>
            <returns>An HTTPRequest instance for the POST request.</returns>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.CreatePost(System.Uri,Best.HTTP.OnRequestFinishedDelegate)">
            <summary>
            Creates an <see cref="F:Best.HTTP.HTTPMethods.Post">HTTP POST</see> request with the specified URI and registers a callback function to be called
            when the request is fully processed.
            </summary>
            <param name="uri">The URI of the request.</param>
            <param name="callback">A callback function to be called when the request is finished.</param>
            <returns>An HTTPRequest instance for the POST request.</returns>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.CreatePut(System.String)">
            <summary>
            Creates an <see cref="F:Best.HTTP.HTTPMethods.Put">HTTP PUT</see> request with the specified URL.
            </summary>
            <param name="url">The URL of the request.</param>
            <returns>An HTTPRequest instance for the PUT request.</returns>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.CreatePut(System.Uri)">
            <summary>
            Creates an <see cref="F:Best.HTTP.HTTPMethods.Put">HTTP PUT</see> request with the specified URI.
            </summary>
            <param name="uri">The URI of the request.</param>
            <returns>An HTTPRequest instance for the PUT request.</returns>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.CreatePut(System.String,Best.HTTP.OnRequestFinishedDelegate)">
            <summary>
            Creates an <see cref="F:Best.HTTP.HTTPMethods.Put">HTTP PUT</see> request with the specified URL and registers a callback function to be called
            when the request is fully processed.
            </summary>
            <param name="url">The URL of the request.</param>
            <param name="callback">A callback function to be called when the request is finished.</param>
            <returns>An HTTPRequest instance for the PUT request.</returns>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.CreatePut(System.Uri,Best.HTTP.OnRequestFinishedDelegate)">
            <summary>
            Creates an <see cref="F:Best.HTTP.HTTPMethods.Put">HTTP PUT</see> request with the specified URI and registers a callback function to be called
            when the request is fully processed.
            </summary>
            <param name="uri">The URI of the request.</param>
            <param name="callback">A callback function to be called when the request is finished.</param>
            <returns>An HTTPRequest instance for the PUT request.</returns>
        </member>
        <member name="F:Best.HTTP.HTTPRequest.MethodNames">
            <summary>
            Cached uppercase values to save some cpu cycles and GC alloc per request.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRequest.MethodType">
            <summary>
            The method that how we want to process our request the server.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRequest.Uri">
            <summary>
            The original request's Uri.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRequest.CurrentUri">
            <summary>
            If redirected it contains the RedirectUri.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRequest.CurrentHostKey">
            <summary>
            A host-key that can be used to find the right host-variant for the request.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRequest.Response">
            <summary>
            The response received from the server.
            </summary>
            <remarks>If an exception occurred during reading of the response stream or can't connect to the server, this will be null!</remarks>
        </member>
        <member name="F:Best.HTTP.HTTPRequest.DownloadSettings">
            <summary>
            Download related options and settings.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPRequest.UploadSettings">
            <summary>
            Upload related options and settings.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPRequest.TimeoutSettings">
            <summary>
            Timeout settings for the request.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPRequest.RetrySettings">
            <summary>
            Retry settings for the request.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPRequest.ProxySettings">
            <summary>
            Proxy settings for the request.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRequest.RedirectSettings">
            <summary>
            Redirect settings for the request.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRequest.Callback">
            <summary>
            The callback function that will be called after the request is fully processed.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRequest.IsCancellationRequested">
            <summary>
            Indicates if <see cref="M:Best.HTTP.HTTPRequest.Abort"/> is called on this request.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRequest.CancellationTokenSource">
            <summary>
            Gets the cancellation token source for this request.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPRequest.OnCancellationRequested">
            <summary>
            Action called when <see cref="M:Best.HTTP.HTTPRequest.Abort"/> function is invoked.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRequest.Exception">
            <summary>
            Stores any exception that occurs during processing of the request or response.
            </summary>
            <remarks>This property if for debugging purposes as <see href="https://github.com/Benedicht/BestHTTP-Issues/issues/174">seen here</see>!</remarks>
        </member>
        <member name="P:Best.HTTP.HTTPRequest.Tag">
            <summary>
            Any user-object that can be passed with the request.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRequest.State">
            <summary>
            Current state of this request.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRequest.Timing">
            <summary>
            Timing information about the request.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPRequest.Authenticator">
            <summary>
            An IAuthenticator implementation that can be used to authenticate the request.
            </summary>
            <remarks>Out-of-the-box included authenticators are <see cref="T:Best.HTTP.Request.Authenticators.CredentialAuthenticator"/> and <see cref="T:Best.HTTP.Request.Authenticators.BearerTokenAuthenticator"/>.</remarks>
        </member>
        <member name="P:Best.HTTP.HTTPRequest.Context">
            <summary>
            Logging context of the request.
            </summary>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.#ctor(System.String)">
            <summary>
            Creates an HTTP GET request with the specified URL.
            </summary>
            <param name="url">The URL of the request.</param>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.#ctor(System.String,Best.HTTP.OnRequestFinishedDelegate)">
            <summary>
            Creates an HTTP GET request with the specified URL and registers a callback function to be called
            when the request is fully processed.
            </summary>
            <param name="url">The URL of the request.</param>
            <param name="callback">A callback function to be called when the request is finished.</param>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.#ctor(System.String,Best.HTTP.HTTPMethods)">
            <summary>
            Creates an HTTP GET request with the specified URL and HTTP method type.
            </summary>
            <param name="url">The URL of the request.</param>
            <param name="methodType">The HTTP method type for the request (e.g., GET, POST, PUT).</param>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.#ctor(System.String,Best.HTTP.HTTPMethods,Best.HTTP.OnRequestFinishedDelegate)">
            <summary>
            Creates an HTTP request with the specified URL, HTTP method type, and registers a callback function to be called
            when the request is fully processed.
            </summary>
            <param name="url">The URL of the request.</param>
            <param name="methodType">The HTTP method type for the request (e.g., GET, POST, PUT).</param>
            <param name="callback">A callback function to be called when the request is finished.</param>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.#ctor(System.Uri)">
            <summary>
            Creates an HTTP GET request with the specified URI.
            </summary>
            <param name="uri">The URI of the request.</param>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.#ctor(System.Uri,Best.HTTP.OnRequestFinishedDelegate)">
            <summary>
            Creates an HTTP GET request with the specified URI and registers a callback function to be called
            when the request is fully processed.
            </summary>
            <param name="uri">The URI of the request.</param>
            <param name="callback">A callback function to be called when the request is finished.</param>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.#ctor(System.Uri,Best.HTTP.HTTPMethods)">
            <summary>
            Creates an HTTP request with the specified URI and HTTP method type.
            </summary>
            <param name="uri">The URI of the request.</param>
            <param name="methodType">The HTTP method type for the request (e.g., GET, POST, PUT).</param>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.#ctor(System.Uri,Best.HTTP.HTTPMethods,Best.HTTP.OnRequestFinishedDelegate)">
            <summary>
            Creates an HTTP request with the specified URI, HTTP method type, and registers a callback function
            to be called when the request is fully processed.
            </summary>
            <param name="uri">The URI of the request.</param>
            <param name="methodType">The HTTP method type for the request (e.g., GET, POST, PUT).</param>
            <param name="callback">A callback function to be called when the request is finished.</param>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.AddHeader(System.String,System.String)">
            <summary>
            Adds a header-value pair to the Headers. Use it to add custom headers to the request.
            </summary>
            <example>AddHeader("User-Agent', "FooBar 1.0")</example>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.SetHeader(System.String,System.String)">
            <summary>
            For the given header name, removes any previously added values and sets the given one.
            </summary>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.RemoveHeader(System.String)">
            <summary>
            Removes the specified header and all of its associated values. Returns <c>true</c>, if the header found and succesfully removed.
            </summary>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.HasHeader(System.String)">
            <summary>
            Returns <c>true</c> if the given head name is already in the <see cref="P:Best.HTTP.HTTPRequest.Headers"/>.
            </summary>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.GetFirstHeaderValue(System.String)">
            <summary>
            Returns the first header or <c>null</c> for the given header name.
            </summary>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.GetHeaderValues(System.String)">
            <summary>
            Returns all header values for the given header or <c>null</c>.
            </summary>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.RemoveHeaders">
            <summary>
            Removes all headers.
            </summary>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.SetRangeHeader(System.Int64)">
            <summary>
            Sets the Range header to download the content from the given byte position. See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35
            </summary>
            <param name="firstBytePos">Start position of the download.</param>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.SetRangeHeader(System.Int64,System.Int64)">
            <summary>
            Sets the Range header to download the content from the given byte position to the given last position. See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35
            </summary>
            <param name="firstBytePos">Start position of the download.</param>
            <param name="lastBytePos">The end position of the download.</param>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.Send">
            <summary>
            Starts processing the request.
            </summary>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.Abort">
            <summary>
            Cancels any further processing of the HTTP request.
            </summary>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.Clear">
            <summary>
            Resets the request for a state where switching MethodType is possible.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPRequest.Current">
            <summary>
            <see cref="P:System.Collections.IEnumerator.Current"/> implementation, required for <see cref="T:UnityEngine.Coroutine"/> support.
            </summary>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.MoveNext">
            <summary>
            <see cref="M:System.Collections.IEnumerator.MoveNext"/> implementation, required for <see cref="T:UnityEngine.Coroutine"/> support.
            </summary>
            <returns><c>true</c> if the request isn't finished yet.</returns>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.Reset">
            <summary>
            <see cref="M:System.Collections.IEnumerator.MoveNext"/> implementation throwing <see cref="T:System.NotImplementedException"/>, required for <see cref="T:UnityEngine.Coroutine"/> support.
            </summary>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Best.HTTP.HTTPRequest.Dispose">
            <summary>
            Disposes of resources used by the HTTPRequest instance.
            </summary>
        </member>
        <member name="T:Best.HTTP.AsyncHTTPException">
            <summary>
            Represents an exception thrown during or as a result of a Task-based asynchronous HTTP operations.
            </summary>
        </member>
        <member name="F:Best.HTTP.AsyncHTTPException.StatusCode">
            <summary>
            Gets the status code of the server's response.
            </summary>
        </member>
        <member name="F:Best.HTTP.AsyncHTTPException.Content">
            <summary>
            Gets the content sent by the server. This is usually an error page for 4xx or 5xx responses.
            </summary>
        </member>
        <member name="T:Best.HTTP.HTTPRequestAsyncExtensions">
            <summary>
            A collection of extension methods for working with HTTP requests asynchronously using <see cref="T:System.Threading.Tasks.Task`1"/>.
            </summary>
        </member>
        <member name="M:Best.HTTP.HTTPRequestAsyncExtensions.GetAssetBundleAsync(Best.HTTP.HTTPRequest,System.Threading.CancellationToken)">
            <summary>
            Asynchronously sends an HTTP request and retrieves the response as an <see cref="T:UnityEngine.AssetBundle"/>.
            </summary>
            <param name="request">The <see cref="T:Best.HTTP.HTTPRequest"/> to send.</param>
            <param name="token">A cancellation token that can be used to cancel the operation.</param>
            <returns>
            A Task that represents the asynchronous operation. The Task will complete with the retrieved AssetBundle
            if the request succeeds. If the request fails or is canceled, the Task will complete with an exception.
            </returns>
        </member>
        <member name="M:Best.HTTP.HTTPRequestAsyncExtensions.GetHTTPResponseAsync(Best.HTTP.HTTPRequest,System.Threading.CancellationToken)">
            <summary>
            Asynchronously sends an HTTP request and retrieves the raw <see cref="T:Best.HTTP.HTTPResponse"/>.
            </summary>
            <remarks>
            This method is particularly useful when you want to access the raw response without any specific processing 
            like converting the data into a string, texture, or other formats. It provides flexibility in handling 
            the response for custom or advanced use cases.
            </remarks>
            <param name="request">The <see cref="T:Best.HTTP.HTTPRequest"/> to send.</param>
            <param name="token">An optional <see cref="T:System.Threading.CancellationToken"/> that can be used to cancel the operation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task`1"/> that represents the asynchronous operation. The value of TResult is the raw <see cref="T:Best.HTTP.HTTPResponse"/>.
            If the request completes successfully, the task will return the HTTPResponse. If there's an error during the request or if 
            the request gets canceled, the task will throw an exception, which can be caught and processed by the calling method.
            </returns>
            <exception cref="T:Best.HTTP.AsyncHTTPException">Thrown if there's an error in the request or if the server returns an error status code.</exception>
        </member>
        <member name="M:Best.HTTP.HTTPRequestAsyncExtensions.GetAsStringAsync(Best.HTTP.HTTPRequest,System.Threading.CancellationToken)">
            <summary>
            Asynchronously sends an <see cref="T:Best.HTTP.HTTPRequest"/> and retrieves the response content as a <c>string</c>.
            </summary>
            <param name="request">The <see cref="T:Best.HTTP.HTTPRequest"/> to send.</param>
            <param name="token">A cancellation token that can be used to cancel the operation.</param>
            <returns>
            A Task that represents the asynchronous operation. The Task will complete with the retrieved <c>string</c> content
            if the request succeeds. If the request fails or is canceled, the Task will complete with an exception.
            </returns>
        </member>
        <member name="M:Best.HTTP.HTTPRequestAsyncExtensions.GetAsTexture2DAsync(Best.HTTP.HTTPRequest,System.Threading.CancellationToken)">
            <summary>
            Asynchronously sends an <see cref="T:Best.HTTP.HTTPRequest"/> and retrieves the response content as a <see cref="T:UnityEngine.Texture2D"/>.
            </summary>
            <param name="request">The <see cref="T:Best.HTTP.HTTPRequest"/> to send.</param>
            <param name="token">A cancellation token that can be used to cancel the operation.</param>
            <returns>
            A Task that represents the asynchronous operation. The Task will complete with the retrieved <see cref="T:UnityEngine.Texture2D"/>
            if the request succeeds. If the request fails or is canceled, the Task will complete with an exception.
            </returns>
        </member>
        <member name="M:Best.HTTP.HTTPRequestAsyncExtensions.GetRawDataAsync(Best.HTTP.HTTPRequest,System.Threading.CancellationToken)">
            <summary>
            Asynchronously sends an <see cref="T:Best.HTTP.HTTPRequest"/> and retrieves the response content as a <c>byte[]</c>.
            </summary>
            <param name="request">The <see cref="T:Best.HTTP.HTTPRequest"/> to send.</param>
            <param name="token">A cancellation token that can be used to cancel the operation.</param>
            <returns>
            A Task that represents the asynchronous operation. The Task will complete with the retrieved <c>byte[]</c>
            if the request succeeds. If the request fails or is canceled, the Task will complete with an exception.
            </returns>
        </member>
        <member name="M:Best.HTTP.HTTPRequestAsyncExtensions.GetFromJsonResultAsync``1(Best.HTTP.HTTPRequest,System.Threading.CancellationToken)">
            <summary>
            Asynchronously sends an <see cref="T:Best.HTTP.HTTPRequest"/> and deserializes the response content into an object of type T using JSON deserialization.
            </summary>
            <typeparam name="T">The type to deserialize the JSON content into.</typeparam>
            <param name="request">The <see cref="T:Best.HTTP.HTTPRequest"/> to send.</param>
            <param name="token">A cancellation token that can be used to cancel the operation.</param>
            <returns>
            A Task that represents the asynchronous operation. The Task will complete with the deserialized object
            if the request succeeds and the response content can be deserialized. If the request fails, is canceled, or
            the response cannot be deserialized, the Task will complete with an exception.
            </returns>
        </member>
        <member name="T:Best.HTTP.HTTPRequestStates">
            <summary>
            Possible logical states of a HTTTPRequest object.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPRequestStates.Initial">
            <summary>
            Initial status of a request. No callback will be called with this status.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPRequestStates.Queued">
            <summary>
            The request queued for processing.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPRequestStates.Processing">
            <summary>
            Processing of the request started. In this state the client will send the request, and parse the response. No callback will be called with this status.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPRequestStates.Finished">
            <summary>
            The request finished without problem. Parsing the response done, the result can be used. The user defined callback will be called with a valid response object. The requests Exception property will be null.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPRequestStates.Error">
            <summary>
            The request finished with an unexpected error. The user defined callback will be called with a null response object. The request's Exception property may contain more info about the error, but it can be null.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPRequestStates.Aborted">
            <summary>
            The request aborted by the client(HTTPRequests Abort() function). The user defined callback will be called with a null response. The requests Exception property will be null.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPRequestStates.ConnectionTimedOut">
            <summary>
            Connecting to the server timed out. The user defined callback will be called with a null response. The requests Exception property will be null.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPRequestStates.TimedOut">
            <summary>
            The request didn't finished in the given time. The user defined callback will be called with a null response. The requests Exception property will be null.
            </summary>
        </member>
        <member name="T:Best.HTTP.Proxies.Autodetect.EnvironmentProxyDetector">
            <summary>
            Based on <see href="https://curl.se/docs/manual.html"/>'s "Environment Variables" section.
            </summary>
        </member>
        <member name="T:Best.HTTP.Proxies.Autodetect.FrameworkProxyDetector">
            <summary>
            This is a detector using the .net framework's implementation. It might work not just under Windows but MacOS and Linux too.
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient.defaultproxy?view=net-6.0">HttpClient.DefaultProxy Property</see></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Best.HTTP.Proxies.Autodetect.ProgrammaticallyAddedProxyDetector">
            <summary>
            This one just returns with HTTPManager.Proxy,
            so when ProgrammaticallyAddedProxyDetector is used in the first place for the ProxyDetector,
            HTTPManager.Proxy gets the highest priority.
            </summary>
        </member>
        <member name="T:Best.HTTP.Proxies.Autodetect.IProxyDetector">
            <summary>
            Interface for custom proxy-detection logic.
            </summary>
        </member>
        <member name="M:Best.HTTP.Proxies.Autodetect.IProxyDetector.GetProxy(Best.HTTP.HTTPRequest)">
            <summary>
            Receives the <see cref="T:Best.HTTP.HTTPRequest"/> instance this detector has to try to find a proxy.
            </summary>
            <param name="request"><see cref="T:Best.HTTP.HTTPRequest"/>instance to find a proxy for</param>
            <returns>A concrete <see cref="T:Best.HTTP.Proxies.Proxy"/> implementation, or <c>null</c> if no proxy could be found.</returns>
        </member>
        <member name="T:Best.HTTP.Proxies.Autodetect.ProxyDetectionMode">
            <summary>
            Possible detection modes the <see cref="T:Best.HTTP.Proxies.Autodetect.ProxyDetector"/> can be in.
            </summary>
        </member>
        <member name="F:Best.HTTP.Proxies.Autodetect.ProxyDetectionMode.Continuous">
            <summary>
            In Continuous mode the ProxyDetector will check for a proxy for every request.
            </summary>
        </member>
        <member name="F:Best.HTTP.Proxies.Autodetect.ProxyDetectionMode.CacheFirstFound">
            <summary>
            This mode will cache the first Proxy found and use it for consecutive requests.
            </summary>
        </member>
        <member name="T:Best.HTTP.Proxies.Autodetect.ProxyDetector">
            <summary>
            Helper class to contain, manage and execute logic to detect available proxy on the network. It's a wrapper class to execute the various <see cref="T:Best.HTTP.Proxies.Autodetect.IProxyDetector"/>s.
            </summary>
        </member>
        <member name="M:Best.HTTP.Proxies.Autodetect.ProxyDetector.Detach">
            <summary>
            Call Detach() to disable ProxyDetector's logic to find and set a proxy.
            </summary>
        </member>
        <member name="T:Best.HTTP.Proxies.HTTPProxy">
            <summary>
            Represents an HTTP proxy server that can be used to route HTTP requests through.
            </summary>
            <remarks>
            The HTTPProxy class is an implementation of the <see cref="T:Best.HTTP.Proxies.Proxy"/> base class, specifically designed for
            HTTP proxy servers. It provides features such as transparent proxy support, sending the entire URI, and handling proxy
            authentication. This class is used to configure and manage HTTP proxy settings for HTTP requests.
            </remarks>
        </member>
        <member name="P:Best.HTTP.Proxies.HTTPProxy.IsTransparent">
            <summary>
            Gets or sets whether the proxy can act as a transparent proxy. Default value is <c>true</c>.
            </summary>
            <remarks>
            A transparent proxy forwards client requests without modifying them. When set to <c>true</c>, the proxy behaves as a transparent
            proxy, meaning it forwards requests as-is. If set to <c>false</c>, it may modify requests, and this can be useful for certain
            advanced proxy configurations.
            </remarks>
        </member>
        <member name="P:Best.HTTP.Proxies.HTTPProxy.SendWholeUri">
            <summary>
            Gets or sets whether the proxy - when it's in non-transparent mode - excepts only the path and query of the request URI. Default value is <c>true</c>.
            </summary>
        </member>
        <member name="P:Best.HTTP.Proxies.HTTPProxy.NonTransparentForHTTPS">
            <summary>
            Gets or sets whether the plugin will use the proxy as an explicit proxy for secure protocols (HTTPS://, WSS://).
            </summary>
            <remarks>
            When set to <c>true</c>, the plugin will issue a CONNECT request to the proxy for secure protocols, even if the proxy is
            marked as transparent. This is commonly used for ensuring proper handling of encrypted traffic through the proxy.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Proxies.HTTPProxy.#ctor(System.Uri)">
            <summary>
            Creates a new instance of the HTTPProxy class with the specified proxy address.
            </summary>
            <param name="address">The address of the proxy server.</param>
        </member>
        <member name="M:Best.HTTP.Proxies.HTTPProxy.#ctor(System.Uri,Best.HTTP.Request.Authentication.Credentials)">
            <summary>
            Creates a new instance of the HTTPProxy class with the specified proxy address and credentials.
            </summary>
            <param name="address">The address of the proxy server.</param>
            <param name="credentials">The credentials for proxy authentication.</param>
        </member>
        <member name="M:Best.HTTP.Proxies.HTTPProxy.#ctor(System.Uri,Best.HTTP.Request.Authentication.Credentials,System.Boolean)">
            <summary>
            Creates a new instance of the HTTPProxy class with the specified proxy address, credentials, and transparency settings.
            </summary>
            <param name="address">The address of the proxy server.</param>
            <param name="credentials">The credentials for proxy authentication.</param>
            <param name="isTransparent">Specifies whether the proxy can act as a transparent proxy (<c>true</c>) or not (<c>false</c>).</param>
        </member>
        <member name="M:Best.HTTP.Proxies.HTTPProxy.#ctor(System.Uri,Best.HTTP.Request.Authentication.Credentials,System.Boolean,System.Boolean)">
            <summary>
            Creates a new instance of the HTTPProxy class with the specified proxy address, credentials, transparency settings, and URI handling.
            </summary>
            <param name="address">The address of the proxy server.</param>
            <param name="credentials">The credentials for proxy authentication.</param>
            <param name="isTransparent">Specifies whether the proxy can act as a transparent proxy (<c>true</c>) or not (<c>false</c>).</param>
            <param name="sendWholeUri">Specifies whether the proxy should send the entire URI (<c>true</c>) or just the path and query (<c>false</c>) for non-transparent proxies.</param>
        </member>
        <member name="M:Best.HTTP.Proxies.HTTPProxy.#ctor(System.Uri,Best.HTTP.Request.Authentication.Credentials,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:Best.HTTP.Proxies.HTTPProxy"/> class with the specified proxy address, credentials, transparency settings, URI handling, and HTTPS behavior.
            </summary>
            <param name="address">The address of the proxy server.</param>
            <param name="credentials">The credentials for proxy authentication.</param>
            <param name="isTransparent">Specifies whether the proxy can act as a transparent proxy (<c>true</c>) or not (<c>false</c>).</param>
            <param name="sendWholeUri">Specifies whether the proxy should send the entire URI (<c>true</c>) or just the path and query (<c>false</c>) for non-transparent proxies.</param>
            <param name="nonTransparentForHTTPS">Specifies whether the plugin should use the proxy as an explicit proxy for secure protocols (HTTPS://, WSS://) (<c>true</c>) or not (<c>false</c>).</param>
        </member>
        <member name="T:Best.HTTP.Proxies.Implementations.SOCKSMethods">
            <summary>
            https://tools.ietf.org/html/rfc1928
              The values currently defined for METHOD are:
                o  X'00' NO AUTHENTICATION REQUIRED
                o  X'01' GSSAPI
                o  X'02' USERNAME/PASSWORD
                o  X'03' to X'7F' IANA ASSIGNED
                o  X'80' to X'FE' RESERVED FOR PRIVATE METHODS
                o  X'FF' NO ACCEPTABLE METHODS
            </summary>
        </member>
        <member name="T:Best.HTTP.Proxies.ProxyConnectParameters">
            <summary>
            Represents parameters used when connecting through a proxy server.
            </summary>
            <remarks>
            The ProxyConnectParameters struct defines the parameters required when initiating a connection
            through a proxy server. It includes information about the proxy, target URI, and callbacks for success and error handling.
            This struct is commonly used during the negotiation steps in the <see cref="T:Best.HTTP.Shared.PlatformSupport.Network.Tcp.Negotiator"/> class.
            </remarks>
        </member>
        <member name="F:Best.HTTP.Proxies.ProxyConnectParameters.MaxAuthenticationAttempts">
            <summary>
            The maximum number of authentication attempts allowed during proxy connection.
            </summary>
        </member>
        <member name="F:Best.HTTP.Proxies.ProxyConnectParameters.proxy">
            <summary>
            The proxy server through which the connection is established.
            </summary>
        </member>
        <member name="F:Best.HTTP.Proxies.ProxyConnectParameters.stream">
            <summary>
            The stream used for communication with the proxy server.
            </summary>
        </member>
        <member name="F:Best.HTTP.Proxies.ProxyConnectParameters.uri">
            <summary>
            The target URI to reach through the proxy server.
            </summary>
        </member>
        <member name="F:Best.HTTP.Proxies.ProxyConnectParameters.token">
            <summary>
            A cancellation token that allows canceling the proxy connection operation.
            </summary>
        </member>
        <member name="F:Best.HTTP.Proxies.ProxyConnectParameters.AuthenticationAttempts">
            <summary>
            The number of authentication attempts made during proxy connection.
            </summary>
        </member>
        <member name="F:Best.HTTP.Proxies.ProxyConnectParameters.createTunel">
            <summary>
            Gets or sets a value indicating whether to create a proxy tunnel.
            </summary>
            <remarks>
            A proxy tunnel, also known as a TCP tunnel, is established when communication between the client and the target server
            needs to be relayed through the proxy without modification. Setting this field to <c>true</c> indicates the intention
            to create a tunnel, allowing the data to pass through the proxy without interpretation or alteration by the proxy.
            This is typically used for protocols like HTTPS, where end-to-end encryption is desired, and the proxy should act as a
            pass-through conduit.
            </remarks>
        </member>
        <member name="F:Best.HTTP.Proxies.ProxyConnectParameters.context">
            <summary>
            The logging context for debugging purposes.
            </summary>
        </member>
        <member name="F:Best.HTTP.Proxies.ProxyConnectParameters.OnSuccess">
            <summary>
            A callback to be executed upon successful proxy connection.
            </summary>
        </member>
        <member name="F:Best.HTTP.Proxies.ProxyConnectParameters.OnError">
            <summary>
            A callback to be executed upon encountering an error during proxy connection.
            </summary>
            <remarks>
            The callback includes parameters for the current connection parameters, the encountered exception,
            and a flag indicating whether the connection should be retried for authentication.
            </remarks>
        </member>
        <member name="T:Best.HTTP.Proxies.Proxy">
            <summary>
            Base class for proxy implementations, providing common proxy configuration and behavior.
            </summary>
            <remarks>
            The Proxy class serves as the base class for various proxy client implementations,
            such as <see cref="T:Best.HTTP.Proxies.HTTPProxy"/> and <see cref="T:Best.HTTP.Proxies.SOCKSProxy"/>. It provides a foundation for configuring proxy settings and handling
            proxy-related functionality common to all proxy types, like connecting to a proxy, setting up a request to go through the proxy
            and deciding whether an address is usable with the proxy or the plugin must connect directly.
            </remarks>
        </member>
        <member name="P:Best.HTTP.Proxies.Proxy.Address">
            <summary>
            Address of the proxy server. It has to be in the http://proxyaddress:port form.
            </summary>
        </member>
        <member name="P:Best.HTTP.Proxies.Proxy.Credentials">
            <summary>
            Credentials for authenticating with the proxy server.
            </summary>
        </member>
        <member name="P:Best.HTTP.Proxies.Proxy.Exceptions">
            <summary>
            List of exceptions for which the proxy should not be used. Elements of this list are compared to the Host (DNS or IP address) part of the uri.
            </summary>
        </member>
        <member name="M:Best.HTTP.Proxies.Proxy.#ctor(System.Uri,Best.HTTP.Request.Authentication.Credentials)">
            <summary>
            Initializes a new instance of the Proxy class with the specified proxy address and credentials.
            </summary>
            <param name="address">The address of the proxy server.</param>
            <param name="credentials">The credentials for proxy authentication.</param>
        </member>
        <member name="M:Best.HTTP.Proxies.Proxy.BeginConnect(Best.HTTP.Proxies.ProxyConnectParameters)">
            <summary>
            Initiates a connection through the proxy server. Used during the negotiation steps.
            </summary>
            <param name="parameters">Parameters for the proxy connection.</param>
        </member>
        <member name="M:Best.HTTP.Proxies.Proxy.GetRequestPath(System.Uri)">
            <summary>
            Gets the request path to be used for proxy communication. In some cases with HTTPProxy, the request must send the whole uri as the request path.
            </summary>
            <param name="uri">The target URI.</param>
            <returns>The request path for proxy communication.</returns>
        </member>
        <member name="M:Best.HTTP.Proxies.Proxy.SetupRequest(Best.HTTP.HTTPRequest)">
            <summary>
            Sets up an HTTP request to use the proxy as needed.
            </summary>
            <param name="request">The HTTP request to set up.</param>
            <returns><c>true</c> if the request should use the proxy; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Best.HTTP.Proxies.Proxy.UseProxyForAddress(System.Uri)">
            <summary>
            Determines whether the proxy should be used for a specific address based on the configured exceptions.
            </summary>
            <param name="address">The address to check for proxy usage.</param>
            <returns><c>true</c> if the proxy should be used for the address; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:Best.HTTP.Proxies.SOCKSProxy">
            <summary>
            Represents a SOCKS proxy used for making HTTP requests, supporting SOCKS version 5 (v5).
            </summary>
        </member>
        <member name="M:Best.HTTP.Proxies.SOCKSProxy.#ctor(System.Uri,Best.HTTP.Request.Authentication.Credentials)">
            <summary>
            Initializes a new instance of the SOCKSProxy class with the specified proxy address and credentials.
            </summary>
            <param name="address">The address of the SOCKS proxy server.</param>
            <param name="credentials">The credentials for proxy authentication (if required).</param>
        </member>
        <member name="T:Best.HTTP.Request.Authentication.AuthenticationTypes">
            <summary>
            Authentication types that supported by Best.HTTP.
            The authentication is defined by the server, so the Basic and Digest are not interchangeable. If you don't know what to use, the preferred way is to choose Unknow.
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Authentication.AuthenticationTypes.Unknown">
            <summary>
            If the authentication type is not known this will do a challenge turn to receive what methode should be choosen.
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Authentication.AuthenticationTypes.Basic">
            <summary>
            The most basic authentication type. It's easy to do, and easy to crack, don't use it with plain http://
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Authentication.AuthenticationTypes.Digest">
            <summary>
            HTTP Digest authentication
            </summary>
        </member>
        <member name="T:Best.HTTP.Request.Authentication.Credentials">
            <summary>
            Hold all information that required to authenticate to a remote server.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Authentication.Credentials.Type">
            <summary>
            The type of the Authentication. If you don't know what to use, the preferred way is to choose Unknow.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Authentication.Credentials.UserName">
            <summary>
            The username to authenticate on the remote server.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Authentication.Credentials.Password">
            <summary>
            The password to use in the authentication process. The password will be stored only in this class.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Authentication.Credentials.#ctor(System.String,System.String)">
            <summary>
            Set up the authentication credentials with the username and password. The Type will be set to Unknown.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Authentication.Credentials.#ctor(Best.HTTP.Request.Authentication.AuthenticationTypes,System.String,System.String)">
            <summary>
            Set up the authentication credentials with the given authentication type, username and password.
            </summary>
        </member>
        <member name="T:Best.HTTP.Request.Authentication.Digest">
            <summary>
            Internal class that stores all information that received from a server in a WWW-Authenticate and need to construct a valid Authorization header. Based on rfc 2617 (http://tools.ietf.org/html/rfc2617).
            Used only internally by the plugin.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Authentication.Digest.Uri">
            <summary>
            The Uri that this Digest is bound to.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Authentication.Digest.Realm">
            <summary>
            A string to be displayed to users so they know which username and password to use.
            This string should contain at least the name of the host performing the authentication and might additionally indicate the collection of users who might have access.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Authentication.Digest.Stale">
            <summary>
            A flag, indicating that the previous request from the client was rejected because the nonce value was stale.
            If stale is TRUE (case-insensitive), the client may wish to simply retry the request with a new encrypted response, without  the user for a new username and password.
            The server should only set stale to TRUE if it receives a request for which the nonce is invalid but with a valid digest for that nonce
            (indicating that the client knows the correct username/password).
            If stale is FALSE, or anything other than TRUE, or the stale directive is not present, the username and/or password are invalid, and new values must be obtained.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Authentication.Digest.Nonce">
            <summary>
            A server-specified data string which should be uniquely generated each time a 401 response is made.
            Specifically, since the string is passed in the header lines as a quoted string, the double-quote character is not allowed.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Authentication.Digest.Opaque">
            <summary>
            A string of data, specified by the server, which should be returned by the client unchanged in the Authorization header of subsequent requests with URIs in the same protection space.
            It is recommended that this string be base64 or data.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Authentication.Digest.Algorithm">
            <summary>
            A string indicating a pair of algorithms used to produce the digest and a checksum. If this is not present it is assumed to be "MD5".
            If the algorithm is not understood, the challenge should be ignored (and a different one used, if there is more than one).
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Authentication.Digest.ProtectedUris">
            <summary>
            List of URIs, as specified in RFC XURI, that define the protection space.
            If a URI is an abs_path, it is relative to the canonical root URL (see section 1.2 above) of the server being accessed.
            An absoluteURI in this list may refer to a different server than the one being accessed.
            The client can use this list to determine the set of URIs for which the same authentication information may be sent:
            any URI that has a URI in this list as a prefix (after both have been made absolute) may be assumed to be in the same protection space.
            If this directive is omitted or its value is empty, the client should assume that the protection space consists of all URIs on the responding server.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Authentication.Digest.QualityOfProtections">
            <summary>
            If present, it is a quoted string of one or more tokens indicating the "quality of protection" values supported by the server.
            The value "auth" indicates authentication. The value "auth-int" indicates authentication with integrity protection.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Authentication.Digest.NonceCount">
            <summary>
            his MUST be specified if a qop directive is sent (see above), and MUST NOT be specified if the server did not send a qop directive in the WWW-Authenticate header field.
            The nc-value is the hexadecimal count of the number of requests (including the current request) that the client has sent with the nonce value in this request.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Authentication.Digest.HA1Sess">
            <summary>
            Used to store the last HA1 that can be used in the next header generation when Algorithm is set to "md5-sess".
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Authentication.Digest.ParseChallange(System.String)">
            <summary>
            Parses a WWW-Authenticate header's value to retrive all information.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Authentication.Digest.GenerateResponseHeader(Best.HTTP.Request.Authentication.Credentials,System.Boolean,Best.HTTP.HTTPMethods,System.Uri)">
            <summary>
            Generates a string that can be set to an Authorization header.
            </summary>
        </member>
        <member name="T:Best.HTTP.Request.Authentication.DigestStore">
            <summary>
            Stores and manages already received digest infos.
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Authentication.DigestStore.SupportedAlgorithms">
            <summary>
            Array of algorithms that the plugin supports. It's in the order of priority(first has the highest priority).
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Authentication.DigestStore.GetOrCreate(System.Uri)">
            <summary>
            It will retrieve or create a new Digest for the given Uri.
            </summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="T:Best.HTTP.Request.Authentication.WWWAuthenticateHeaderParser">
            <summary>
            Used for parsing WWW-Authenticate headers:
            `Digest realm="my realm", nonce="4664b327a2963503ba58bbe13ad672c0", qop=auth, opaque="f7e38bdc1c66fce214f9019ffe43117c"`
            </summary>
        </member>
        <member name="T:Best.HTTP.Request.Authenticators.BearerTokenAuthenticator">
            <summary>
            An <see cref="T:Best.HTTP.Request.Authenticators.IAuthenticator"/> implementation for Bearer Token authentication.
            </summary>
            <remarks>
            Bearer Token authentication is a method used to access protected resources on a server.
            It involves including a bearer token in the Authorization header of an HTTP request to prove the identity of the requester.
            </remarks>
        </member>
        <member name="P:Best.HTTP.Request.Authenticators.BearerTokenAuthenticator.Token">
            <summary>
            Initializes a new instance of the BearerTokenAuthenticator class with the specified Bearer Token.
            </summary>
            <param name="token">The Bearer Token to use for authentication.</param>
        </member>
        <member name="M:Best.HTTP.Request.Authenticators.BearerTokenAuthenticator.#ctor(System.String)">
            <summary>
            Sets up the required Authorization header with the Bearer Token for the HTTP request.
            </summary>
            <param name="request">The HTTP request for which the Authorization header should be added.</param>
            <remarks>
            When sending an HTTP request to a server that requires Bearer Token authentication,
            this method sets the Authorization header with the Bearer Token to prove the identity of the requester.
            This allows the requester to access protected resources on the server.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Request.Authenticators.BearerTokenAuthenticator.HandleChallange(Best.HTTP.HTTPRequest,Best.HTTP.HTTPResponse)">
            <summary>
            Handles the server response with a 401 (Unauthorized) status code and a WWW-Authenticate header.
            This authenticator does not handle challenges and always returns <c>false</c>.
            </summary>
            <param name="req">The HTTP request that received the 401 response.</param>
            <param name="resp">The HTTP response containing the 401 (Unauthorized) status.</param>
            <returns><c>false</c>, as this authenticator does not handle challenges.</returns>
            <remarks>
            Bearer Token authentication typically does not require handling challenges,
            as the Bearer Token is included directly in the Authorization header of the request.
            This method always returns <c>false</c>, as no additional challenge processing is needed.
            </remarks>
        </member>
        <member name="T:Best.HTTP.Request.Authenticators.CredentialAuthenticator">
            <summary>
            An <see cref="T:Best.HTTP.Request.Authenticators.IAuthenticator"/> implementation for HTTP Basic or Digest authentication.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Authenticators.CredentialAuthenticator.Credentials">
            <summary>
            Gets or sets the <see cref="T:Best.HTTP.Request.Authentication.Credentials"/> associated with this authenticator.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Authenticators.CredentialAuthenticator.#ctor(Best.HTTP.Request.Authentication.Credentials)">
            <summary>
            Initializes a new instance of the CrendetialAuthenticator class with the specified <see cref="T:Best.HTTP.Request.Authentication.Credentials"/>.
            </summary>
            <param name="credentials">The <see cref="T:Best.HTTP.Request.Authentication.Credentials"/> to use for authentication.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="credentials"/> is null.</exception>
        </member>
        <member name="M:Best.HTTP.Request.Authenticators.CredentialAuthenticator.SetupRequest(Best.HTTP.HTTPRequest)">
            <summary>
            Sets up the required headers for the HTTP request based on the provided credentials.
            </summary>
            <param name="request">The HTTP request for which headers should be added.</param>
        </member>
        <member name="M:Best.HTTP.Request.Authenticators.CredentialAuthenticator.HandleChallange(Best.HTTP.HTTPRequest,Best.HTTP.HTTPResponse)">
            <summary>
            Handles the server response with a 401 (Unauthorized) status code and a WWW-Authenticate header.
            The authenticator might determine the authentication method to use and initiate authentication if needed.
            </summary>
            <param name="req">The HTTP request that received the 401 response.</param>
            <param name="resp">The HTTP response containing the 401 (Unauthorized) status.</param>
            <returns><c>true</c> if the challenge is handled by the authenticator and the request can be resent with authentication; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:Best.HTTP.Request.Authenticators.IAuthenticator">
            <summary>
            Represents an interface for various authentication implementations used in HTTP requests.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Authenticators.IAuthenticator.SetupRequest(Best.HTTP.HTTPRequest)">
            <summary>
            Set required headers or content for the HTTP request. Called right before the request is sent out.
            </summary>
            <remarks>
            <para>
            The SetupRequest method will be called every time the request is redirected or retried.
            </para>
            </remarks>
            <param name="request">The HTTP request to which headers or content will be added.</param>
        </member>
        <member name="M:Best.HTTP.Request.Authenticators.IAuthenticator.HandleChallange(Best.HTTP.HTTPRequest,Best.HTTP.HTTPResponse)">
            <summary>
            Called when the server is sending a 401 (Unauthorized) response with an WWW-Authenticate header.
            The authenticator might find additional knowledge about the authentication requirements (like what auth method it should use).
            If the authenticator is confident it can successfully (re)authenticate the request it can return true and the request will be resent to the server.
            </summary>
            <remarks>
            More details can be found here:
            <list type="bullet">
                <item><description><see href="https://www.rfc-editor.org/rfc/rfc9110.html#status.401">RFC-9110 - 401 Unauthorized</see></description></item>
                <item><description><see href="https://www.rfc-editor.org/rfc/rfc9110.html#name-www-authenticate">RFC-9110 - WWW-Authenticate header</see></description></item>
            </list>
            </remarks>
            <param name="req">The HTTP request that received the 401 response.</param>
            <param name="resp">The HTTP response containing the 401 (Unauthorized) status.</param>
            <returns><c>true</c> if the challange is handled by the authenticator and the request can be re-sent with authentication.</returns>
        </member>
        <member name="T:Best.HTTP.Request.Settings.OnHeadersReceivedDelegate">
            <summary>
            Delegate for handling the event when headers are received in a response.
            </summary>
            <param name="req">The <see cref="T:Best.HTTP.HTTPRequest"/> object.</param>
            <param name="resp">The <see cref="T:Best.HTTP.HTTPResponse"/> object.</param>
            <param name="headers">The headers received from the server.</param>
        </member>
        <member name="T:Best.HTTP.Request.Settings.OnProgressDelegate">
            <summary>
            Delegate for handling progress during the download.
            </summary>
            <param name="req">The <see cref="T:Best.HTTP.HTTPRequest"/> object.</param>
            <param name="progress">The number of bytes downloaded so far.</param>
            <param name="length">The total length of the content being downloaded, or -1 if the length cannot be determined.</param>
        </member>
        <member name="T:Best.HTTP.Request.Settings.OnDownloadStartedDelegate">
            <summary>
            Delegate for handling the event when the download of content starts.
            </summary>
            <param name="req">The <see cref="T:Best.HTTP.HTTPRequest"/> object.</param>
            <param name="resp">The <see cref="T:Best.HTTP.HTTPResponse"/> object.</param>
            <param name="stream">The <see cref="T:Best.HTTP.Response.DownloadContentStream"/> used for receiving downloaded content.</param>
        </member>
        <member name="T:Best.HTTP.Request.Settings.OnCreateDownloadStreamDelegate">
            <summary>
            Delegate for creating a new <see cref="T:Best.HTTP.Response.DownloadContentStream"/> object.
            </summary>
            <param name="req">The <see cref="T:Best.HTTP.HTTPRequest"/> object.</param>
            <param name="resp">The <see cref="T:Best.HTTP.HTTPResponse"/> object.</param>
            <param name="bufferAvailableHandler">An interface for notifying connections that the buffer has free space for downloading data.</param>
            <returns>The newly created <see cref="T:Best.HTTP.Response.DownloadContentStream"/>.</returns>
        </member>
        <member name="T:Best.HTTP.Request.Settings.OnUpgradedDelegate">
            <summary>
            Delegate for handling the event when a response is upgraded.
            </summary>
            <param name="req">The <see cref="T:Best.HTTP.HTTPRequest"/> object.</param>
            <param name="resp">The <see cref="T:Best.HTTP.HTTPResponse"/> object.</param>
            <param name="contentProvider">A stream that provides content for the upgraded response.</param>
            <returns><c>true</c> to keep the underlying connection open; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:Best.HTTP.Request.Settings.DownloadSettings">
            <summary>
            Represents settings for configuring an HTTP request's download behavior.
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Settings.DownloadSettings.ContentStreamMaxBuffered">
            <summary>
            Gets or sets the maximum number of bytes the <see cref="T:Best.HTTP.Response.DownloadContentStream"/> will buffer before pausing the download until its buffer has free space again.
            </summary>
            <remarks>
            When the download content stream buffers data up to this specified limit, it will temporarily pause downloading until it has free space in its buffer.
            Increasing this value may help reduce the frequency of pauses during downloads, but it also increases memory usage.
            </remarks>
        </member>
        <member name="P:Best.HTTP.Request.Settings.DownloadSettings.DisableCache">
            <summary>
            Gets or sets a value indicating whether caching should be enabled for this request.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Settings.DownloadSettings.CacheOnly">
            <summary>
            Gets or sets a value indicating whether the response's <see cref="T:Best.HTTP.Response.DownloadContentStream"/> should be populated with downloaded data or if the content should be written only to the local cache when available.
            </summary>
            <remarks>
            If set to <c>true</c> and the content isn't cacheable (e.g., it doesn't have any cache-related headers), the content will be downloaded but will be lost.
            </remarks>
            <summary>
            Gets or sets a value indicating whether the response's <see cref="P:Best.HTTP.HTTPResponse.DownStream"/> should be populated with downloaded data or if the content should be written only to the local cache when available.
            </summary>
            <remarks>
            If set to <c>true</c> and the content isn't cacheable (e.g., it doesn't have any cache-related headers), the content will be downloaded but will be lost.
            This is because the downloaded data would be written exclusively to the local cache and will not be stored in memory or the response's <see cref="P:Best.HTTP.HTTPResponse.DownStream"/> for further use.
            </remarks>
        </member>
        <member name="F:Best.HTTP.Request.Settings.DownloadSettings.OnHeadersReceived">
            <summary>
            This event is called when the plugin received and parsed all headers.
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Settings.DownloadSettings.DownloadStreamFactory">
            <summary>
            Represents a function that creates a new <see cref="T:Best.HTTP.Response.DownloadContentStream"/> object when needed for downloading content.
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Settings.DownloadSettings.OnDownloadStarted">
            <summary>
            Event for handling the start of the download process for 2xx status code responses.
            </summary>
            <param name="req">The <see cref="T:Best.HTTP.HTTPRequest"/> object.</param>
            <param name="resp">The <see cref="T:Best.HTTP.HTTPResponse"/> object representing the response.</param>
            <param name="stream">
            The <see cref="T:Best.HTTP.Response.DownloadContentStream"/> containing the downloaded data. It might already be populated with some content.
            </param>
            <remarks>
            This event is called when the plugin expects the server to send content. When called, the <see cref="T:Best.HTTP.Response.DownloadContentStream"/>
            might already be populated with some content. It is specifically meant for responses with 2xx status codes.
            </remarks>
        </member>
        <member name="F:Best.HTTP.Request.Settings.DownloadSettings.OnDownloadProgress">
            <summary>
            Gets or sets the event that is called when new data is downloaded from the server.
            </summary>
            <remarks>
            The first parameter is the original <see cref="T:Best.HTTP.HTTPRequest"/> object itself, the second parameter is the downloaded bytes, and the third parameter is the content length.
            There are download modes where we can't figure out the exact length of the final content. In these cases, we guarantee that the third parameter will be at least the size of the second one.
            </remarks>
        </member>
        <member name="F:Best.HTTP.Request.Settings.DownloadSettings.OnUpgraded">
            <summary>
            Called when a response with status code 101 (upgrade), "<c>connection: upgrade</c>" header and value or an "<c>upgrade</c>" header received.
            </summary>
            <remarks>This callback might be called on a thread other than the main one!</remarks>
            <remarks>Isn't available under WebGL!</remarks>
        </member>
        <member name="T:Best.HTTP.Request.Settings.ProxySettings">
            <summary>
            Represents settings related to using a proxy server for HTTP requests.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Settings.ProxySettings.HasProxyFor(System.Uri)">
            <summary>
            Checks if there is a proxy configured for the given URI.
            </summary>
            <param name="uri">The URI to check for proxy usage.</param>
            <returns><c>true</c> if a proxy is configured and should be used for the URI; otherwise, <c>false</c>.</returns>
        </member>
        <member name="P:Best.HTTP.Request.Settings.ProxySettings.Proxy">
            <summary>
            Gets or sets the proxy object used for the request.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Settings.ProxySettings.SetupRequest(Best.HTTP.HTTPRequest)">
            <summary>
            Sets up the HTTP request for passing through a proxy server.
            </summary>
            <param name="request">The HTTP request to set up.</param>
        </member>
        <member name="M:Best.HTTP.Request.Settings.ProxySettings.Handle407(Best.HTTP.HTTPRequest)">
            <summary>
            Handles the proxy's response with status code <c>407</c>.
            </summary>
            <param name="request">The HTTP request that received a <c>407</c> response.</param>
            <returns><c>true</c> to resend the request through the proxy; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Best.HTTP.Request.Settings.ProxySettings.AddToHash(System.Uri,UnityEngine.Hash128@)">
            <summary>
            Adds the proxy address to a hash for the given request URI.
            </summary>
            <param name="requestUri">The request URI for which the proxy address is added to the hash.</param>
            <param name="hash">The hash to which the proxy address is added.</param>
        </member>
        <member name="T:Best.HTTP.Request.Settings.RedirectSettings">
            <summary>
            Represents settings related to handling HTTP request redirection.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Settings.RedirectSettings.IsRedirected">
            <summary>
            Indicates whether the request has been redirected.
            A request's IsRedirected might be true while <see cref="P:Best.HTTP.Request.Settings.RedirectSettings.RedirectCount"/> is zero if the redirection is made to the local cache.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Settings.RedirectSettings.RedirectUri">
            <summary>
            The Uri that the request is redirected to.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Settings.RedirectSettings.MaxRedirects">
            <summary>
            How many redirection is supported for this request. The default is 10. Zero or a negative value means no redirections are supported.
            </summary>
            <summary>
            Gets or sets the maximum number of redirections supported for this request. The default is <c>10</c>.
            A value of zero or a negative value means no redirections are supported.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Settings.RedirectSettings.RedirectCount">
            <summary>
            Gets the number of times the request has been redirected.
            </summary>
        </member>
        <member name="E:Best.HTTP.Request.Settings.RedirectSettings.OnBeforeRedirection">
            <summary>
            Occurs before the plugin makes a new request to the new URI during redirection.
            The return value of this event handler controls whether the redirection is aborted (<c>false</c>) or allowed (<c>true</c>).
            This event is called on a thread other than the main Unity thread.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Settings.RedirectSettings.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the RedirectSettings class with the specified maximum redirections.
            </summary>
            <param name="maxRedirects">The maximum number of redirections allowed.</param>
        </member>
        <member name="M:Best.HTTP.Request.Settings.RedirectSettings.Reset">
            <summary>
            Resets <see cref="P:Best.HTTP.Request.Settings.RedirectSettings.IsRedirected"/> and <see cref="P:Best.HTTP.Request.Settings.RedirectSettings.RedirectCount"/> to their default values.
            </summary>
        </member>
        <member name="T:Best.HTTP.Request.Settings.RetrySettings">
            <summary>
            Represents settings related to request retry behavior.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Settings.RetrySettings.Retries">
            <summary>
            Gets the number of times that the plugin has retried the request.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Settings.RetrySettings.MaxRetries">
            <summary>
            Gets or sets the maximum number of retry attempts allowed. To disable retries, set this value to <c>0</c>.
            The default value is <c>1</c> for GET requests, otherwise <c>0</c>.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Settings.RetrySettings.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the RetrySettings class with the specified maximum retry attempts.
            </summary>
            <param name="maxRetries">The maximum number of retry attempts allowed.</param>
        </member>
        <member name="T:Best.HTTP.Request.Settings.TimeoutSettings">
            <summary>
            Represents settings related to connection-timeouts and processing duration.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Settings.TimeoutSettings.QueuedAt">
            <summary>
            Gets the timestamp when the request was queued for processing.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Settings.TimeoutSettings.ProcessingStarted">
            <summary>
            Gets the timestamp when the processing of the request started by a connection.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Settings.TimeoutSettings.ConnectTimeout">
            <summary>
            Gets or sets the maximum time to wait for establishing the connection to the target server.
            If set to <c>TimeSpan.Zero</c> or lower, no connect timeout logic is executed. Default value is 20 seconds.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Settings.TimeoutSettings.Timeout">
            <summary>
            Gets or sets the maximum time to wait for the request to finish after the connection is established.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Settings.TimeoutSettings.IsConnectTimedOut(System.DateTime)">
            <summary>
            Returns <c>true</c> if the request has been stuck in the connection phase for too long.
            </summary>
            <param name="now">The current timestamp.</param>
            <returns><c>true</c> if the connection has timed out; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Best.HTTP.Request.Settings.TimeoutSettings.IsTimedOut(System.DateTime)">
            <summary>
            Returns <c>true</c> if the time has passed the specified Timeout setting since processing started or if the connection has timed out.
            </summary>
            <param name="now">The current timestamp.</param>
            <returns><c>true</c> if the request has timed out; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Best.HTTP.Request.Settings.TimeoutSettings.#ctor(Best.HTTP.HTTPRequest)">
            <summary>
            Initializes a new instance of the TimeoutSettings class for a specific <see cref="T:Best.HTTP.HTTPRequest"/>.
            </summary>
            <param name="request">The <see cref="T:Best.HTTP.HTTPRequest"/> associated with these timeout settings.</param>
        </member>
        <member name="T:Best.HTTP.Request.Settings.UploadSettings">
            <summary>
            Options for sending the request headers and content, including upload progress monitoring.
            </summary>
            <remarks><see cref="M:Best.HTTP.Request.Settings.UploadSettings.SetupRequest(Best.HTTP.HTTPRequest,System.Boolean)"/> might be called when redirected or retried!</remarks>
        </member>
        <member name="F:Best.HTTP.Request.Settings.UploadSettings.UploadChunkSize">
            <summary>
            Size of the internal buffer, and upload progress will be fired when this size of data sent to the wire. Its default value is 4 KiB.
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Settings.UploadSettings.UploadStream">
            <summary>
            The stream that the plugin will use to send data to the server.
            </summary>
            <remarks>
            The stream can be any regular <see cref="T:System.IO.Stream"/> implementation or a specialized one inheriting from <see cref="T:Best.HTTP.Request.Upload.UploadStreamBase"/>:
            <list type="bullet">
                <item><term><see cref="T:Best.HTTP.Request.Upload.DynamicUploadStream"/></term><description>A specialized <see cref="T:Best.HTTP.Request.Upload.UploadStreamBase"/> for data generated on-the-fly or periodically. The request remains active until the <see cref="M:Best.HTTP.Request.Upload.DynamicUploadStream.Complete"/> method is invoked, ensuring continuous data feed even during temporary empty states.</description></item>
                <item><term><see cref="T:Best.HTTP.Request.Upload.JSonDataStream`1"/></term><description>An <see cref="T:Best.HTTP.Request.Upload.UploadStreamBase"/> implementation to convert and upload the object as JSON data. It sets the <c>"Content-Type"</c> header to <c>"application/json; charset=utf-8"</c>.</description></item>
                <item><term><see cref="T:Best.HTTP.Request.Upload.Forms.UrlEncodedStream"/></term><description>An <see cref="T:Best.HTTP.Request.Upload.UploadStreamBase"/> implementation representing a stream that prepares and sends data as URL-encoded form data in an HTTP request.</description></item>
                <item><term><see cref="T:Best.HTTP.Request.Upload.Forms.MultipartFormDataStream"/></term><description>An <see cref="T:Best.HTTP.Request.Upload.UploadStreamBase"/> based implementation of the <c>multipart/form-data</c> Content-Type. It's very memory-effective, streams are read into memory in chunks.</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Best.HTTP.Request.Settings.UploadSettings.DisposeStream">
            <summary>
            Set to <c>false</c> if the plugin MUST NOT dispose <see cref="F:Best.HTTP.Request.Settings.UploadSettings.UploadStream"/> after the request is finished.
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Settings.UploadSettings.OnUploadProgress">
            <summary>
            Called periodically when data sent to the server.
            </summary>
        </member>
        <member name="E:Best.HTTP.Request.Settings.UploadSettings.OnHeadersSent">
            <summary>
            This event is fired after the headers are sent to the server.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Settings.UploadSettings.SetupRequest(Best.HTTP.HTTPRequest,System.Boolean)">
            <summary>
            Called every time the request is sent out (redirected or retried).
            </summary>
            <param name="request">The <see cref="T:Best.HTTP.HTTPRequest"/> being prepared.</param>
            <param name="dispatchHeadersSentCallback"><c>true</c> if the <see cref="E:Best.HTTP.Request.Settings.UploadSettings.OnHeadersSent"/> can be fired.</param>
        </member>
        <member name="M:Best.HTTP.Request.Settings.UploadSettings.Dispose">
            <summary>
            Dispose of resources used by the UploadSettings instance.
            </summary>
        </member>
        <member name="T:Best.HTTP.Request.Timings.TimingCollector">
            <summary>
            Helper class to store, calculate and manage request related events and theirs duration, referenced by <see cref="P:Best.HTTP.HTTPRequest.Timing"/> field.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Timings.TimingCollector.Created">
            <summary>
            When the TimingCollector instance created.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Timings.TimingCollector.Finished">
            <summary>
            When the closing Finish event is sent.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Timings.TimingCollector.Events">
            <summary>
            List of added events.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Timings.TimingCollector.Finish">
            <summary>
            Finish the last event.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Timings.TimingCollector.Abort">
            <summary>
            Abort the currently running event.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Timings.TimingCollector.AddEvent(System.String,System.DateTime,System.TimeSpan)">
            <summary>
            When the event happened and for how long.
            </summary>
        </member>
        <member name="T:Best.HTTP.Request.Timings.TimingEvent">
            <summary>
            Struct to hold information about one timing event recorded for a <see cref="T:Best.HTTP.HTTPRequest"/>. Timing events are managed by the <see cref="T:Best.HTTP.Request.Timings.TimingCollector"/>.
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Timings.TimingEvent.Name">
            <summary>
            Name of the event
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Timings.TimingEvent.Duration">
            <summary>
            Duration of the event.
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Timings.TimingEvent.When">
            <summary>
            When the event occurred.
            </summary>
        </member>
        <member name="T:Best.HTTP.Request.Upload.BodyLengths">
            <summary>
            Provides constants representing different, special body lengths for HTTP requests with upload streams.
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Upload.BodyLengths.UnknownWithChunkedTransferEncoding">
            <summary>
            The <see cref="T:Best.HTTP.Request.Upload.UploadStreamBase"/>'s length is unknown and the plugin have to send data with '<c>chunked</c>' transfer-encoding.
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Upload.BodyLengths.UnknownRaw">
            <summary>
            The <see cref="T:Best.HTTP.Request.Upload.UploadStreamBase"/>'s length is unknown and the plugin have to send data as-is, without any encoding.
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Upload.BodyLengths.NoBody">
            <summary>
            No content to send.
            </summary>
        </member>
        <member name="T:Best.HTTP.Request.Upload.DynamicUploadStream">
            <summary>
            A specialized upload stream designed to handle data that's generated on-the-fly or periodically.
            </summary>
            <remarks>
            This implementation is designed to handle scenarios where data may not always be immediately available for upload.
            The request will remain active until the <see cref="M:Best.HTTP.Request.Upload.DynamicUploadStream.Complete"/> method is invoked, ensuring that data can continue to be fed into the stream even if it's temporarily empty during a Read operation.
            </remarks>
        </member>
        <member name="P:Best.HTTP.Request.Upload.DynamicUploadStream.Length">
            <summary>
            Gets the length of the upload stream.
            </summary>
            <remarks>
            This implementation returns a constant value of <c>-1</c>, indicating that the length of the data to be uploaded is unknown. When the processing connection encounters this value, it should utilize chunked uploading to handle the data transfer.
            </remarks>
            <value>The constant value of <c>-1</c>, representing unknown length.</value>
        </member>
        <member name="P:Best.HTTP.Request.Upload.DynamicUploadStream.BufferedLength">
            <summary>
            Gets the length of data currently buffered and ready for upload.
            </summary>
            <value>The length of buffered data in bytes.</value>
        </member>
        <member name="M:Best.HTTP.Request.Upload.DynamicUploadStream.#ctor(System.String)">
            <summary>
            Initializes a new instance of the DynamicUploadStream class with an optional content type.
            </summary>
            <param name="contentType">The MIME type of the content to be uploaded. Defaults to "<c>application/octet-stream</c>" if not specified.</param>
            <remarks>
            This constructor allows the caller to specify the content type of the data to be uploaded. If not provided, it defaults to a general binary data type.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Request.Upload.DynamicUploadStream.BeforeSendHeaders(Best.HTTP.HTTPRequest)">
            <summary>
            Sets the necessary headers before sending the request.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Upload.DynamicUploadStream.BeforeSendBody(Best.HTTP.HTTPRequest,Best.HTTP.Hosts.Connections.IThreadSignaler)">
            <summary>
            Prepares the stream before the request body is sent.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Upload.DynamicUploadStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads data from the stream to be uploaded.
            </summary>
            <remarks>
            The returned value indicates the state of the stream:
            <list type="bullet">
                <item><term>-1</term><description>More data is expected in the future, but isn't currently available. When new data is ready, the IThreadSignaler must be notified.</description></item>
                <item><term>0</term><description>The stream has been closed and no more data will be provided.</description></item>
                <item><description>Otherwise it returns with the number bytes copied to the buffer.</description></item>
            </list>
            Note: A zero return value can come after a -1 return, indicating a transition from waiting to completion.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Request.Upload.DynamicUploadStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes data to the stream, making it available for upload.
            </summary>
            <remarks>
            After writing data to the stream using this method, the connection is signaled that data is available to send.
            </remarks>
            <param name="buffer">The array of unsigned bytes from which to copy count bytes to the current stream.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
            <exception cref="T:System.InvalidOperationException">Thrown when trying to write after the stream has been marked as complete.</exception>
        </member>
        <member name="M:Best.HTTP.Request.Upload.DynamicUploadStream.Write(Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment)">
            <summary>
            Writes a segment of data to the stream, making it available for upload.
            </summary>
            <param name="segment">A segment of data to be written to the stream.</param>
            <exception cref="T:System.InvalidOperationException">Thrown when trying to write after the stream has been marked as complete.</exception>
            <remarks>
            After writing a segment to the stream using this method, the connection is signaled that data is available to send.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Request.Upload.DynamicUploadStream.Complete">
            <summary>
            Marks the stream as complete, signaling that no more data will be added.
            </summary>
            <remarks>
            All remaining buffered data will be sent to the server.
            </remarks>
        </member>
        <member name="T:Best.HTTP.Request.Upload.Forms.MultipartFormDataStream">
            <summary>
            An <see cref="T:Best.HTTP.Request.Upload.UploadStreamBase"/> based implementation of the <c>multipart/form-data</c> Content-Type. It's very memory-effective, streams are read into memory in chunks.
            </summary>
            <remarks>
            <para>The return value of <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> is treated specially in the plugin:
            <list type="bullet">
                <item>
                    <term>Less than zero(<c>-1</c>) value </term>
                    <description> indicates that no data is currently available but more is expected in the future. In this case, when new data becomes available the IThreadSignaler object must be signaled.</description>
                </item>
                <item>
                    <term>Zero (<c>0</c>)</term>
                    <description> means that the stream is closed, no more data can be expected.</description>
                </item>
            </list>
            A zero value to signal stream closure can follow a less than zero value.</para>
            </remarks>
        </member>
        <member name="P:Best.HTTP.Request.Upload.Forms.MultipartFormDataStream.Length">
            <summary>
            Gets the length of this multipart/form-data stream.
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Upload.Forms.MultipartFormDataStream.boundary">
            <summary>
            A random boundary generated in the constructor.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Upload.Forms.MultipartFormDataStream.#ctor">
            <summary>
            Initializes a new instance of the MultipartFormDataStream class.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Upload.Forms.MultipartFormDataStream.#ctor(System.String)">
            <summary>
            Initializes a new instance of the MultipartFormDataStream class with a custom boundary.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Upload.Forms.MultipartFormDataStream.AddField(System.String,System.String)">
            <summary>
            Adds a textual field to the multipart/form-data stream.
            </summary>
            <param name="fieldName">The name of the field.</param>
            <param name="value">The textual value of the field.</param>
            <returns>The MultipartFormDataStream instance for method chaining.</returns>
        </member>
        <member name="M:Best.HTTP.Request.Upload.Forms.MultipartFormDataStream.AddField(System.String,System.String,System.Text.Encoding)">
            <summary>
            Adds a textual field to the multipart/form-data stream.
            </summary>
            <param name="fieldName">The name of the field.</param>
            <param name="value">The textual value of the field.</param>
            <param name="encoding">The encoding to use for the value.</param>
            <returns>The MultipartFormDataStream instance for method chaining.</returns>
        </member>
        <member name="M:Best.HTTP.Request.Upload.Forms.MultipartFormDataStream.AddField(System.String,System.Byte[])">
            <summary>
            Adds a stream field to the multipart/form-data stream.
            </summary>
            <param name="fieldName">The name of the field.</param>
            <param name="data">The data containing the field data.</param>
            <returns>The MultipartFormDataStream instance for method chaining.</returns>
        </member>
        <member name="M:Best.HTTP.Request.Upload.Forms.MultipartFormDataStream.AddStreamField(System.String,System.IO.Stream)">
            <summary>
            Adds a stream field to the multipart/form-data stream.
            </summary>
            <param name="stream">The stream containing the field data.</param>
            <param name="fieldName">The name of the field.</param>
            <returns>The MultipartFormDataStream instance for method chaining.</returns>
        </member>
        <member name="M:Best.HTTP.Request.Upload.Forms.MultipartFormDataStream.AddStreamField(System.String,System.IO.Stream,System.String)">
            <summary>
            Adds a stream field to the multipart/form-data stream.
            </summary>
            <param name="stream">The stream containing the field data.</param>
            <param name="fieldName">The name of the field.</param>
            <param name="fileName">The name of the file, if applicable.</param>
            <returns>The MultipartFormDataStream instance for method chaining.</returns>
        </member>
        <member name="M:Best.HTTP.Request.Upload.Forms.MultipartFormDataStream.AddStreamField(System.String,System.IO.Stream,System.String,System.String)">
            <summary>
            Adds a stream field to the multipart/form-data stream.
            </summary>
            <param name="stream">The stream containing the field data.</param>
            <param name="fieldName">The name of the field.</param>
            <param name="fileName">The name of the file, if applicable.</param>
            <param name="mimeType">The MIME type of the content.</param>
            <returns>The MultipartFormDataStream instance for method chaining.</returns>
        </member>
        <member name="M:Best.HTTP.Request.Upload.Forms.MultipartFormDataStream.BeforeSendBody(Best.HTTP.HTTPRequest,Best.HTTP.Hosts.Connections.IThreadSignaler)">
            <summary>
            Adds the final boundary to the multipart/form-data stream before sending the request body.
            </summary>
            <param name="request">The HTTP request.</param>
            <param name="threadSignaler">The thread signaler for handling asynchronous operations.</param>
        </member>
        <member name="M:Best.HTTP.Request.Upload.Forms.MultipartFormDataStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads data from the multipart/form-data stream into the provided buffer.
            </summary>
            <param name="buffer">The buffer to read data into.</param>
            <param name="offset">The starting offset in the buffer.</param>
            <param name="length">The maximum number of bytes to read.</param>
            <returns>The number of bytes read into the buffer.</returns>
        </member>
        <member name="T:Best.HTTP.Request.Upload.Forms.FormField">
            <summary>
            Readonly struct to hold key -> value pairs, where the value is either textual or binary.
            </summary>
        </member>
        <member name="T:Best.HTTP.Request.Upload.Forms.UrlEncodedStream">
            <summary>
            An <see cref="T:Best.HTTP.Request.Upload.UploadStreamBase"/> implementation representing a stream that prepares and sends data as URL-encoded form data in an HTTP request.
            </summary>
            <remarks>
            <para>This stream is used to send data as URL-encoded form data in an HTTP request. It sets the <c>"Content-Type"</c> header to <c>"application/x-www-form-urlencoded"</c>.
            URL-encoded form data is typically used for submitting form data to a web server. It is commonly used in HTTP POST requests to send data to a server, such as submitting HTML form data.</para>
            
            <para>The return value of <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> is treated specially in the plugin:
            <list type="bullet">
                <item>
                    <term>Less than zero(<c>-1</c>) value </term>
                    <description> indicates that no data is currently available but more is expected in the future. In this case, when new data becomes available the IThreadSignaler object must be signaled.</description>
                </item>
                <item>
                    <term>Zero (<c>0</c>)</term>
                    <description> means that the stream is closed, no more data can be expected.</description>
                </item>
            </list>
            A zero value to signal stream closure can follow a less than zero value.</para>
            <para>While it's possible, it's not advised to send binary data url-encoded!</para>
            </remarks>
        </member>
        <member name="P:Best.HTTP.Request.Upload.Forms.UrlEncodedStream.Length">
            <summary>
            Gets the length of the stream.
            </summary>
        </member>
        <member name="F:Best.HTTP.Request.Upload.Forms.UrlEncodedStream._fields">
            <summary>
            A list that holds the form's fields.
            </summary>
        </member>
        <member name="M:Best.HTTP.Request.Upload.Forms.UrlEncodedStream.BeforeSendHeaders(Best.HTTP.HTTPRequest)">
            <summary>
            Sets up the HTTP request by adding the <c>"Content-Type"</c> header as <c>"application/x-www-form-urlencoded"</c>.
            </summary>
            <param name="request">The HTTP request.</param>
        </member>
        <member name="M:Best.HTTP.Request.Upload.Forms.UrlEncodedStream.AddBinaryData(System.String,System.Byte[])">
            <summary>
            Adds binary data to the form. It is not advised to send binary data with an URL-encoded form due to the conversion cost of binary to text conversion.
            </summary>
            <param name="fieldName">The name of the field.</param>
            <param name="content">The binary data content.</param>
            <returns>The UrlEncodedStream instance for method chaining.</returns>
        </member>
        <member name="T:Best.HTTP.Request.Upload.JSonDataStream`1">
            <summary>
            An <see cref="T:Best.HTTP.Request.Upload.UploadStreamBase"/> implementation to convert and upload the object as JSON data. It sets the <c>"Content-Type"</c> header to <c>"application/json; charset=utf-8"</c>.
            </summary>
            <typeparam name="T">The type of the object to be converted to JSON.</typeparam>
            <remarks>
            <para>This stream keeps a reference to the object until the preparation in <see cref="M:Best.HTTP.Request.Upload.JSonDataStream`1.BeforeSendHeaders(Best.HTTP.HTTPRequest)"/>. This means, changes to the object after passing it to the constructor will be reflected in the sent data too.</para>
            <para>The return value of <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> is treated specially in the plugin:
            <list type="bullet">
                <item>
                    <term>Less than zero(<c>-1</c>) value </term>
                    <description> indicates that no data is currently available but more is expected in the future. In this case, when new data becomes available the IThreadSignaler object must be signaled.</description>
                </item>
                <item>
                    <term>Zero (<c>0</c>)</term>
                    <description> means that the stream is closed, no more data can be expected.</description>
                </item>
            </list>
            A zero value to signal stream closure can follow a less than zero value.</para>
            </remarks>
        </member>
        <member name="M:Best.HTTP.Request.Upload.JSonDataStream`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Best.HTTP.Request.Upload.JSonDataStream`1"/> class with the specified object.
            </summary>
            <param name="obj">The object to be converted to JSON and uploaded.</param>
        </member>
        <member name="M:Best.HTTP.Request.Upload.JSonDataStream`1.BeforeSendHeaders(Best.HTTP.HTTPRequest)">
            <summary>
            Called before sending out the request's headers. It sets the <c>"Content-Type"</c> header to <c>"application/json; charset=utf-8"</c>.
            </summary>
            <param name="request">The HTTP request.</param>
        </member>
        <member name="M:Best.HTTP.Request.Upload.JSonDataStream`1.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset"/> and ( <paramref name="offset"/> + <paramref name="count"/> - 1) replaced by the bytes read from the current source.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns>The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</returns>
        </member>
        <member name="M:Best.HTTP.Request.Upload.JSonDataStream`1.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:Best.HTTP.Request.Upload.JSonDataStream`1"/> and optionally releases the managed resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="T:Best.HTTP.Request.Upload.UploadStreamBase">
            <summary>
            Abstract class to serve as a base for non-conventional streams used in HTTP requests.
            </summary>
            <remarks>
            The return value of <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> is treated specially in the plugin:
            <list type="bullet">
                <item>
                    <term>Less than zero(<c>-1</c>)</term>
                    <description> indicates that no data is currently available but more is expected in the future. In this case, when new data becomes available the IThreadSignaler object must be signaled.</description>
                </item>
                <item>
                    <term>Zero (<c>0</c>)</term>
                    <description> means that the stream is closed, no more data can be expected.</description>
                </item>
                <item><description>Otherwise it must return with the number bytes copied to the buffer.</description></item>
            </list>
            A zero value to signal stream closure can follow a less than zero value.
            </remarks>
        </member>
        <member name="P:Best.HTTP.Request.Upload.UploadStreamBase.Signaler">
            <summary>
            Gets the <see cref="T:Best.HTTP.Hosts.Connections.IThreadSignaler"/> object for signaling when new data is available.
            </summary>
        </member>
        <member name="P:Best.HTTP.Request.Upload.UploadStreamBase.Length">
            <summary>
            Length in bytes that the stream will upload.
            </summary>
            <remarks>
            The return value of Length is treated specially in the plugin:
            <list type="bullet">
                <item><term>-2</term><description>The stream's length is unknown and the plugin have to send data <c>with 'chunked' transfer-encoding</c>.</description></item>
                <item><term>-1</term><description>The stream's length is unknown and the plugin have to send data <c>as-is, without any encoding</c>.</description></item>
                <item><term>0</term><description>No content to send. The content-length header will contain zero (<c>0</c>).</description></item>
                <item><term>>0</term><description>Length of the content is known, will be sent <c>as-is, without any encoding</c>. The content-length header will contain zero (<c>0</c>).</description></item>
            </list>
            Constants for the first three points can be found in <see cref="T:Best.HTTP.Request.Upload.BodyLengths"/>.
            </remarks>
        </member>
        <member name="M:Best.HTTP.Request.Upload.UploadStreamBase.BeforeSendHeaders(Best.HTTP.HTTPRequest)">
            <summary>
            Called before sending out the request's headers. Perform content processing to calculate the final length if possible.
            In this function the implementor can set headers and other parameters to the request.
            </summary>
            <remarks>Typically called on a thread.</remarks>
            <param name="request">The <see cref="T:Best.HTTP.HTTPRequest"/> associated with the stream.</param>
        </member>
        <member name="M:Best.HTTP.Request.Upload.UploadStreamBase.BeforeSendBody(Best.HTTP.HTTPRequest,Best.HTTP.Hosts.Connections.IThreadSignaler)">
            <summary>
            Called just before sending out the request's body, and saves the <see cref="T:Best.HTTP.Hosts.Connections.IThreadSignaler"/> for signaling when new data is available.
            </summary>
            <param name="request">The HTTPRequest associated with the stream.</param>
            <param name="threadSignaler">The <see cref="T:Best.HTTP.Hosts.Connections.IThreadSignaler"/> object to be used for signaling.</param>
            <remarks>Typically called on a separate thread.</remarks>
            <summary>
            Called just before sending out the request's body, saves the <see cref="T:Best.HTTP.Hosts.Connections.IThreadSignaler"/> that can be used for signaling when new data is available.
            </summary>
            <param name="request">The HTTPRequest associated with the stream.</param>
            <param name="threadSignaler">The <see cref="T:Best.HTTP.Hosts.Connections.IThreadSignaler"/> object to be used for signaling.</param>
            <remarks>Typically called on a separate thread.</remarks>
        </member>
        <member name="T:Best.HTTP.Response.BlockingDownloadContentStream">
            <summary>
            A blocking variant of the <see cref="T:Best.HTTP.Response.DownloadContentStream"/> that allows clients to wait for downloaded data when the buffer is empty but not completed.
            </summary>
            <remarks>
            <para>
            The BlockingDownloadContentStream is a specialized variant of the <see cref="T:Best.HTTP.Response.DownloadContentStream"/> designed to provide a blocking mechanism for clients waiting for downloaded data.
            This class is particularly useful when clients need to read from the stream, but the buffer is temporarily empty due to ongoing downloads.
            </para>
            <para>
            Key Features:
            <list type="bullet">
                <item>
                    <term>Blocking Data Retrieval</term>
                    <description>Provides a blocking <see cref="M:Best.HTTP.Response.BlockingDownloadContentStream.Take"/> method that allows clients to wait for data if the buffer is empty but not yet completed.</description>
                </item>
                <item>
                    <term>Timeout Support</term>
                    <description>The <see cref="M:Best.HTTP.Response.BlockingDownloadContentStream.Take(System.TimeSpan)"/> method accepts a timeout parameter, allowing clients to set a maximum wait time for data availability.</description>
                </item>
                <item>
                    <term>Exception Handling</term>
                    <description>Handles exceptions and errors that occur during download, ensuring that clients receive any relevant exception information.</description>
                </item>
            </list>
            </para>
            <para>
            Clients can use the <see cref="M:Best.HTTP.Response.BlockingDownloadContentStream.Take"/> method to retrieve data from the stream, and if the buffer is empty, the method will block until new data is downloaded or a timeout occurs.
            This blocking behavior is particularly useful in scenarios where clients need to consume data sequentially but can't proceed until data is available.
            </para>
            <para>
            When the download is completed or if an error occurs during download, this stream allows clients to inspect the completion status and any associated exceptions, just like the base <see cref="T:Best.HTTP.Response.DownloadContentStream"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Best.HTTP.Response.BlockingDownloadContentStream.#ctor(Best.HTTP.HTTPResponse,System.Int64,Best.HTTP.Hosts.Connections.IDownloadContentBufferAvailable)">
            <summary>
            Initializes a new instance of the <see cref="T:Best.HTTP.Response.BlockingDownloadContentStream"/> class.
            </summary>
            <param name="response">The HTTP response associated with this download stream.</param>
            <param name="maxBuffered">The maximum size of the internal buffer.</param>
            <param name="bufferAvailableHandler">Handler for notifying when buffer space becomes available.</param>
        </member>
        <member name="M:Best.HTTP.Response.BlockingDownloadContentStream.TryTake(Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment@)">
            <summary>
            Attempts to retrieve a downloaded content-segment from the stream, blocking if necessary until a segment is available.
            </summary>
            <param name="segment">When this method returns, contains the <see cref="T:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment"/> instance representing the data, if available; otherwise, contains the value of <see cref="F:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment.Empty"/>. This parameter is passed uninitialized.</param>
            <returns><c>true</c> if a segment could be retrieved; otherwise, <c>false</c>.</returns>
            <remarks>
            <para>
            The TryTake function provides a blocking approach to retrieve data from the stream.
            If the stream has data available, it immediately returns the data.
            If there's no data available, the method will block until new data is downloaded or the buffer is marked as completed.
            </para>
            <para>
            This method is designed for scenarios where clients need to read from the stream sequentially and are willing to wait until data is available.
            It ensures that clients receive data as soon as it becomes available, without having to repeatedly check or poll the stream.
            </para>
            </remarks>
        </member>
        <member name="M:Best.HTTP.Response.BlockingDownloadContentStream.Take">
            <summary>
            Returns with a download content-segment. If the stream is currently empty but not completed the execution is blocked until new data downloaded.
            A segment is an arbitrary length array of bytes the plugin could read in one operation, it can range from couple of bytes to kilobytes.
            </summary>
            <returns>A BufferSegment holding a reference to the byte[] containing the downloaded data, offset and count of bytes in the array.</returns>
            <exception cref="T:System.ObjectDisposedException">The stream is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The stream is empty and marked as completed.</exception>
        </member>
        <member name="M:Best.HTTP.Response.BlockingDownloadContentStream.Take(System.TimeSpan)">
            <summary>
            Returns with a download content-segment. If the stream is currently empty but not completed the execution is blocked until new data downloaded or the timeout is reached.
            A segment is an arbitrary length array of bytes the plugin could read in one operation, it can range from couple of bytes to kilobytes.
            </summary>
            <param name="timeout">A TimeSpan that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <returns>A BufferSegment holding a reference to the byte[] containing the downloaded data, offset and count of bytes in the array. In case of a timeout, BufferSegment.Empty returned.</returns>
            <exception cref="T:System.ObjectDisposedException">The stream is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The stream is empty and marked as completed.</exception>
        </member>
        <member name="M:Best.HTTP.Response.BlockingDownloadContentStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
            <remarks>
            <para>
            This override of the <see cref="M:Best.HTTP.Response.BlockingDownloadContentStream.Read(System.Byte[],System.Int32,System.Int32)"/> method provides blocking behavior, meaning if there are no bytes available in the stream, the method will block until new data is downloaded or until the stream completes. Once data is available, or if the stream completes, the method will return with the number of bytes read.
            </para>
            <para>
            This behavior ensures that consumers of the stream can continue reading data sequentially, even if the stream's internal buffer is temporarily empty due to ongoing downloads.
            </para>
            </remarks>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset"/> and (<paramref name="offset"/> + <paramref name="count"/> - 1) replaced by the bytes read from the current source.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns>
            The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero if the end of the stream is reached.
            </returns>
        </member>
        <member name="T:Best.HTTP.Response.DownloadContentStream">
            <summary>
            A read-only stream that the plugin uses to store the downloaded content. This stream is designed to buffer downloaded data efficiently and provide it to consumers.
            </summary>
            <remarks>
            <para>
            The DownloadContentStream serves as a storage medium for content downloaded during HTTP requests.
            It buffers the downloaded data in segments and allows clients to read from the buffer as needed.
            This buffering mechanism is essential for optimizing download performance, especially in scenarios where the download rate may vary or be faster than the rate at which data is consumed.
            </para>
            <para>
            The stream operates in conjunction with the <see cref="T:Best.HTTP.Hosts.Connections.IDownloadContentBufferAvailable"/> interface, which is used to signal connections when buffer space becomes available.
            Connections can then transfer additional data into the buffer for processing.
            </para>
            <para>
            <list type="bullet">
                <item>
                    <term>Efficient Buffering</term>
                    <description>The stream efficiently buffers downloaded content, ensuring that data is readily available for reading without extensive delays.</description>
                </item>
                <item>
                    <term>Dynamic Resizing</term>
                    <description>The internal buffer dynamically resizes to accommodate varying amounts of downloaded data, optimizing memory usage.</description>
                </item>
                <item>
                    <term>Asynchronous Signal Handling</term>
                    <description>Asynchronous signaling mechanisms are used to notify connections when buffer space is available, enabling efficient data transfer.</description>
                </item>
                <item>
                    <term>Error Handling</term>
                    <description>The stream captures and propagates errors that occur during download, allowing clients to handle exceptions gracefully.</description>
                </item>
                <item>
                    <term>Blocking Variant</term>
                    <description>A blocking variant, <see cref="T:Best.HTTP.Response.BlockingDownloadContentStream"/>, allows clients to wait for data when the buffer is empty but not completed.</description>
                </item>
            </list>
            </para>
            <para>
            Clients can read from this stream using standard stream reading methods, and the stream will release memory segments as data is read.
            When the download is completed or if an error occurs during download, this stream allows clients to inspect the completion status and any associated exceptions.
            </para>
            </remarks>
        </member>
        <member name="P:Best.HTTP.Response.DownloadContentStream.Response">
            <summary>
            Gets the HTTP response from which this download stream originated.
            </summary>
        </member>
        <member name="P:Best.HTTP.Response.DownloadContentStream.IsCompleted">
            <summary>
            Gets a value indicating whether the download is completed, and there's no more data buffered in the stream to read.
            </summary>
        </member>
        <member name="P:Best.HTTP.Response.DownloadContentStream.CompletedWith">
            <summary>
            Gets a reference to an exception if the download completed with an error.
            </summary>
        </member>
        <member name="P:Best.HTTP.Response.DownloadContentStream.Length">
            <summary>
            Gets the length of the buffered data. Because downloads happen in parallel, a <see cref="M:Best.HTTP.Response.DownloadContentStream.Read(System.Byte[],System.Int32,System.Int32)"/> call can return with more data after checking Length.
            </summary>
        </member>
        <member name="P:Best.HTTP.Response.DownloadContentStream.MaxBuffered">
            <summary>
            Gets the maximum size of the internal buffer of this stream.
            </summary>
            <remarks>In some cases, the plugin may put more data into the stream than the specified size.</remarks>
        </member>
        <member name="P:Best.HTTP.Response.DownloadContentStream.IsFull">
            <summary>
            Gets a value indicating whether the internal buffer holds at least the <see cref="P:Best.HTTP.Response.DownloadContentStream.MaxBuffered"/> amount of data.
            </summary>
        </member>
        <member name="P:Best.HTTP.Response.DownloadContentStream.IsDetached">
            <summary>
            Gets or sets whether the stream is detached from the <see cref="T:Best.HTTP.HTTPRequest"/>/<see cref="T:Best.HTTP.HTTPResponse"/> when <see cref="M:Best.HTTP.Response.DownloadContentStream.Read(System.Byte[],System.Int32,System.Int32)"/> is used before the request is finished.
            When the stream is detached from the response object, their lifetimes are not bound together,
            meaning that the stream isn't disposed automatically, and the client code is responsible for calling the stream's <see cref="M:System.IO.Stream.Dispose"/> function.
            </summary>
        </member>
        <member name="M:Best.HTTP.Response.DownloadContentStream.EmergencyIncreaseMaxBuffered">
            <summary>
            There are cases where the plugin have to put more data into the buffer than its previously set maximum.
            For example when the underlying connection is closed, but the content provider still have buffered data,
            in witch case we have to push all processed data to the user facing download stream.
            </summary>
        </member>
        <member name="F:Best.HTTP.Response.DownloadContentStream._isFullCheckCount">
            <summary>
            Count of consecutive calls with DoFullCheck that found the stream fully buffered.
            </summary>
        </member>
        <member name="M:Best.HTTP.Response.DownloadContentStream.#ctor(Best.HTTP.HTTPResponse,System.Int64,Best.HTTP.Hosts.Connections.IDownloadContentBufferAvailable)">
            <summary>
            Initializes a new instance of the DownloadContentStream class.
            </summary>
            <param name="response">The HTTP response associated with this download stream.</param>
            <param name="maxBuffered">The maximum size of the internal buffer.</param>
            <param name="bufferAvailableHandler">Handler for notifying when buffer space becomes available.</param>
        </member>
        <member name="M:Best.HTTP.Response.DownloadContentStream.CompleteAdding(System.Exception)">
            <summary>
            Completes the download stream with an optional error. Called when the download is finished.
            </summary>
            <param name="error">The exception that occurred during download, if any.</param>
        </member>
        <member name="M:Best.HTTP.Response.DownloadContentStream.TryTake(Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment@)">
            <summary>
            Tries to remove a downloaded segment from the stream. If the stream is empty, it returns immediately with false.
            </summary>
            <param name="segment">A <see cref="T:Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment"/> containing the reference to a byte[] and the offset and count of the data in the array.</param>
            <returns><c>true</c> if a downloaded segment was available and could return with, otherwise <c>false</c></returns>
        </member>
        <member name="M:Best.HTTP.Response.DownloadContentStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            A non-blocking Read function. When it returns <c>0</c>, it doesn't mean the download is complete. If the download interrupted before completing, the next Read call can throw an exception.
            </summary>
            <param name="buffer">The buffer to read data into.</param>
            <param name="offset">The zero-based byte offset in the buffer at which to begin copying bytes.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <returns>The number of bytes copied to the buffer, or zero if no downloaded data is available at the time of the call.</returns>
            <exception cref="T:System.ObjectDisposedException">If the stream is already disposed.</exception>
        </member>
        <member name="M:Best.HTTP.Response.DownloadContentStream.Write(Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment)">
            <summary>
            Writes a downloaded data segment to the stream.
            </summary>
            <param name="segment">The downloaded data segment to write.</param>
        </member>
        <member name="M:Best.HTTP.Response.DownloadContentStream.DoFullCheck(System.Int32)">
            <summary>
            Checks whether the stream is fully buffered and increases a counter if it's full, resetting it otherwise.
            </summary>
            <param name="limit">The limit for the full check counter.</param>
            <returns><c>true</c> if the counter is equal to or larger than the limit parameter; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Best.HTTP.Response.DownloadContentStream.Dispose(System.Boolean)">
            <summary>
            Disposes of the stream, releasing any resources held by it.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="T:Best.HTTP.Response.HTTPStatusCodes">
            <summary>
            Provides constants representing various HTTP status codes.
            </summary>
        </member>
        <member name="T:Best.HTTP.HTTPResponse">
            <summary>
            Represents an HTTP response received from a remote server, containing information about the response status, headers, and data.
            </summary>
            <remarks>
            <para>
            The HTTPResponse class represents an HTTP response received from a remote server. It contains information about the response status, headers, and the data content.
            </para>
            <para>
            Key Features:
            <list type="bullet">
                <item>
                    <term>Response Properties</term>
                    <description>Provides access to various properties such as <see cref="P:Best.HTTP.HTTPResponse.HTTPVersion"/>, <see cref="P:Best.HTTP.HTTPResponse.StatusCode"/>, <see cref="P:Best.HTTP.HTTPResponse.Message"/>, and more, to inspect the response details.</description>
                </item>
                <item>
                    <term>Data Access</term>
                    <description>Allows access to the response data in various forms, including raw bytes, UTF-8 text, and as a <see cref="T:UnityEngine.Texture2D"/> for image data.</description>
                </item>
                <item>
                    <term>Header Management</term>
                    <description>Provides methods to add, retrieve, and manipulate HTTP headers associated with the response, making it easy to inspect and work with header information.</description>
                </item>
                <item>
                    <term>Caching Support</term>
                    <description>Supports response caching, enabling the storage of downloaded data in local cache storage for future use.</description>
                </item>
                <item>
                    <term>Stream Management</term>
                    <description>Manages the download process and data streaming through a <see cref="T:Best.HTTP.Response.DownloadContentStream"/> (<see cref="P:Best.HTTP.HTTPResponse.DownStream"/>) to optimize memory usage and ensure efficient handling of large response bodies.</description>
                </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Best.HTTP.HTTPResponse.HTTPVersion">
            <summary>
            Gets the version of the HTTP protocol with which the response was received. Typically, this is HTTP/1.1 for local file and cache responses, even if the original response received with a different version.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPResponse.StatusCode">
            <summary>
            Gets the HTTP status code sent from the server, indicating the outcome of the HTTP request.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPResponse.Message">
            <summary>
            Gets the message sent along with the status code from the server. This message can add some details, but it's empty for HTTP/2 responses.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPResponse.IsSuccess">
            <summary>
            Gets a value indicating whether the response represents a successful HTTP request. Returns true if the status code is in the range of [200..300[ or 304 (Not Modified).
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPResponse.IsFromCache">
            <summary>
            Gets a value indicating whether the response body is read from the cache.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPResponse.Headers">
            <summary>
            Gets the headers sent from the server as key-value pairs. You can use additional methods to manage and retrieve header information.
            </summary>
            <remarks>
            The Headers property provides access to the headers sent by the server in the HTTP response. You can use the following methods to work with headers:
            <list type="bullet">
                <item><term><see cref="M:Best.HTTP.HTTPResponse.AddHeader(System.String,System.String)"/> </term><description>Adds an HTTP header with the specified name and value to the response headers.</description></item>
                <item><term><see cref="M:Best.HTTP.HTTPResponse.GetHeaderValues(System.String)"/> </term><description>Retrieves the list of values for a given header name as received from the server.</description></item>
                <item><term><see cref="M:Best.HTTP.HTTPResponse.GetFirstHeaderValue(System.String)"/> </term><description>Retrieves the first value for a given header name as received from the server.</description></item>
                <item><term><see cref="M:Best.HTTP.HTTPResponse.HasHeaderWithValue(System.String,System.String)"/> </term><description>Checks if a header with the specified name and value exists in the response headers.</description></item>
                <item><term><see cref="M:Best.HTTP.HTTPResponse.HasHeader(System.String)"/> </term><description>Checks if a header with the specified name exists in the response headers.</description></item>
                <item><term><see cref="M:Best.HTTP.HTTPResponse.GetRange"/></term><description>Parses the 'Content-Range' header's value and returns a <see cref="T:Best.HTTP.HTTPRange"/> object representing the byte range of the response content.</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Best.HTTP.HTTPResponse.Data">
            <summary>
            The data that downloaded from the server. All Transfer and Content encodings decoded if any(eg. chunked, gzip, deflate).
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPResponse.IsUpgraded">
            <summary>
            The normal HTTP protocol is upgraded to an other.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPResponse.dataAsText">
            <summary>
            Cached, converted data.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPResponse.DataAsText">
            <summary>
            The data converted to an UTF8 string.
            </summary>
        </member>
        <member name="F:Best.HTTP.HTTPResponse.texture">
            <summary>
            Cached converted data.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPResponse.DataAsTexture2D">
            <summary>
            The data loaded to a Texture2D.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPResponse.DownStream">
            <summary>
            Reference to the <see cref="T:Best.HTTP.Response.DownloadContentStream"/> instance that contains the downloaded data.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPResponse.Context">
            <summary>
            IProtocol.LoggingContext implementation.
            </summary>
        </member>
        <member name="P:Best.HTTP.HTTPResponse.Request">
            <summary>
            The original request that this response is created for.
            </summary>
        </member>
        <member name="M:Best.HTTP.HTTPResponse.AddHeader(System.String,System.String)">
            <summary>
            Adds an HTTP header with the specified name and value to the response headers.
            </summary>
            <param name="name">The name of the header.</param>
            <param name="value">The value of the header.</param>
        </member>
        <member name="M:Best.HTTP.HTTPResponse.GetHeaderValues(System.String)">
            <summary>
            Retrieves the list of values for a given header name as received from the server.
            </summary>
            <param name="name">The name of the header.</param>
            <returns>
            A list of header values if the header exists and contains values; otherwise, returns <c>null</c>.
            </returns>
        </member>
        <member name="M:Best.HTTP.HTTPResponse.GetFirstHeaderValue(System.String)">
            <summary>
            Retrieves the first value for a given header name as received from the server.
            </summary>
            <param name="name">The name of the header.</param>
            <returns>
            The first header value if the header exists and contains values; otherwise, returns <c>null</c>.
            </returns>
        </member>
        <member name="M:Best.HTTP.HTTPResponse.HasHeaderWithValue(System.String,System.String)">
            <summary>
            Checks if a header with the specified name and value exists in the response headers.
            </summary>
            <param name="headerName">The name of the header to check.</param>
            <param name="value">The value to check for in the header.</param>
            <returns>
            <c>true</c> if a header with the given name and value exists in the response headers; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Best.HTTP.HTTPResponse.HasHeader(System.String)">
            <summary>
            Checks if a header with the specified name exists in the response headers.
            </summary>
            <param name="headerName">The name of the header to check.</param>
            <returns>
            <c>true</c> if a header with the given name exists in the response headers; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Best.HTTP.HTTPResponse.GetRange">
            <summary>
            Parses the <c>'Content-Range'</c> header's value and returns a <see cref="T:Best.HTTP.HTTPRange"/> object representing the byte range of the response content.
            </summary>
            <remarks>
            If the server ignores a byte-range-spec because it is syntactically invalid, the server SHOULD treat the request as if the invalid Range header field did not exist.
            (Normally, this means return a 200 response containing the full entity). In this case because there are no <c>'Content-Range'</c> header values, this function will return <c>null</c>.
            </remarks>
            <returns>
            A <see cref="T:Best.HTTP.HTTPRange"/> object representing the byte range of the response content, or <c>null</c> if no '<c>Content-Range</c>' header is found.
            </returns>
        </member>
        <member name="M:Best.HTTP.HTTPResponse.FeedDownloadedContentChunk(Best.HTTP.Shared.PlatformSupport.Memory.BufferSegment)">
            <summary>
            Add data to the fragments list.
            </summary>
            <param name="buffer">The buffer to be added.</param>
            <param name="pos">The position where we start copy the data.</param>
            <param name="length">How many data we want to copy.</param>
        </member>
        <member name="M:Best.HTTP.HTTPResponse.Dispose">
            <summary>
            IDisposable implementation.
            </summary>
        </member>
        <member name="T:Best.HTTP.Futures.FutureState">
            <summary>
            Describes the state of a future.
            </summary>
        </member>
        <member name="F:Best.HTTP.Futures.FutureState.Pending">
            <summary>
            The future hasn't begun to resolve a value.
            </summary>
        </member>
        <member name="F:Best.HTTP.Futures.FutureState.Processing">
            <summary>
            The future is working on resolving a value.
            </summary>
        </member>
        <member name="F:Best.HTTP.Futures.FutureState.Success">
            <summary>
            The future has a value ready.
            </summary>
        </member>
        <member name="F:Best.HTTP.Futures.FutureState.Error">
            <summary>
            The future failed to resolve a value.
            </summary>
        </member>
        <member name="T:Best.HTTP.Futures.IFuture`1">
            <summary>
            Defines the interface of an object that can be used to track a future value.
            </summary>
            <typeparam name="T">The type of object being retrieved.</typeparam>
        </member>
        <member name="P:Best.HTTP.Futures.IFuture`1.state">
            <summary>
            Gets the state of the future.
            </summary>
        </member>
        <member name="P:Best.HTTP.Futures.IFuture`1.value">
            <summary>
            Gets the value if the State is Success.
            </summary>
        </member>
        <member name="P:Best.HTTP.Futures.IFuture`1.error">
            <summary>
            Gets the failure exception if the State is Error.
            </summary>
        </member>
        <member name="M:Best.HTTP.Futures.IFuture`1.OnItem(Best.HTTP.Futures.FutureValueCallback{`0})">
            <summary>
            Adds a new callback to invoke when an intermediate result is known.
            </summary>
            <param name="callback">The callback to invoke.</param>
            <returns>The future so additional calls can be chained together.</returns>
        </member>
        <member name="M:Best.HTTP.Futures.IFuture`1.OnSuccess(Best.HTTP.Futures.FutureValueCallback{`0})">
            <summary>
            Adds a new callback to invoke if the future value is retrieved successfully.
            </summary>
            <param name="callback">The callback to invoke.</param>
            <returns>The future so additional calls can be chained together.</returns>
        </member>
        <member name="M:Best.HTTP.Futures.IFuture`1.OnError(Best.HTTP.Futures.FutureErrorCallback)">
            <summary>
            Adds a new callback to invoke if the future has an error.
            </summary>
            <param name="callback">The callback to invoke.</param>
            <returns>The future so additional calls can be chained together.</returns>
        </member>
        <member name="M:Best.HTTP.Futures.IFuture`1.OnComplete(Best.HTTP.Futures.FutureCallback{`0})">
            <summary>
            Adds a new callback to invoke if the future value is retrieved successfully or has an error.
            </summary>
            <param name="callback">The callback to invoke.</param>
            <returns>The future so additional calls can be chained together.</returns>
        </member>
        <member name="T:Best.HTTP.Futures.FutureCallback`1">
            <summary>
            Defines the signature for callbacks used by the future.
            </summary>
            <param name="future">The future.</param>
        </member>
        <member name="T:Best.HTTP.Futures.Future`1">
            <summary>
            An implementation of <see cref="T:Best.HTTP.Futures.IFuture`1"/> that can be used internally by methods that return futures.
            </summary>
            <remarks>
            Methods should always return the <see cref="T:Best.HTTP.Futures.IFuture`1"/> interface when calling code requests a future.
            This class is intended to be constructed internally in the method to provide a simple implementation of
            the interface. By returning the interface instead of the class it ensures the implementation can change
            later on if requirements change, without affecting the calling code.
            </remarks>
            <typeparam name="T">The type of object being retrieved.</typeparam>
        </member>
        <member name="P:Best.HTTP.Futures.Future`1.state">
            <summary>
            Gets the state of the future.
            </summary>
        </member>
        <member name="P:Best.HTTP.Futures.Future`1.value">
            <summary>
            Gets the value if the State is Success.
            </summary>
        </member>
        <member name="P:Best.HTTP.Futures.Future`1.error">
            <summary>
            Gets the failure exception if the State is Error.
            </summary>
        </member>
        <member name="M:Best.HTTP.Futures.Future`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Best.HTTP.Futures.Future`1"/> class.
            </summary>
        </member>
        <member name="M:Best.HTTP.Futures.Future`1.OnSuccess(Best.HTTP.Futures.FutureValueCallback{`0})">
            <summary>
            Adds a new callback to invoke if the future value is retrieved successfully.
            </summary>
            <param name="callback">The callback to invoke.</param>
            <returns>The future so additional calls can be chained together.</returns>
        </member>
        <member name="M:Best.HTTP.Futures.Future`1.OnError(Best.HTTP.Futures.FutureErrorCallback)">
            <summary>
            Adds a new callback to invoke if the future has an error.
            </summary>
            <param name="callback">The callback to invoke.</param>
            <returns>The future so additional calls can be chained together.</returns>
        </member>
        <member name="M:Best.HTTP.Futures.Future`1.OnComplete(Best.HTTP.Futures.FutureCallback{`0})">
            <summary>
            Adds a new callback to invoke if the future value is retrieved successfully or has an error.
            </summary>
            <param name="callback">The callback to invoke.</param>
            <returns>The future so additional calls can be chained together.</returns>
        </member>
        <member name="M:Best.HTTP.Futures.Future`1.Process(System.Func{`0})">
            <summary>
            Begins running a given function on a background thread to resolve the future's value, as long
            as it is still in the Pending state.
            </summary>
            <param name="func">The function that will retrieve the desired value.</param>
        </member>
        <member name="M:Best.HTTP.Futures.Future`1.Assign(`0)">
            <summary>
            Allows manually assigning a value to a future, as long as it is still in the pending state.
            </summary>
            <remarks>
            There are times where you may not need to do background processing for a value. For example,
            you may have a cache of values and can just hand one out. In those cases you still want to
            return a future for the method signature, but can just call this method to fill in the future.
            </remarks>
            <param name="value">The value to assign the future.</param>
        </member>
        <member name="M:Best.HTTP.Futures.Future`1.Fail(System.Exception)">
            <summary>
            Allows manually failing a future, as long as it is still in the pending state.
            </summary>
            <remarks>
            As with the Assign method, there are times where you may know a future value is a failure without
            doing any background work. In those cases you can simply fail the future manually and return it.
            </remarks>
            <param name="error">The exception to use to fail the future.</param>
        </member>
        <member name="T:PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction">
            <summary>
            This enum describes the action that caused a CollectionChanged event.
            </summary>
        </member>
        <member name="F:PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction.Add">
            <summary> One or more items were added to the collection. </summary>
        </member>
        <member name="F:PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction.Remove">
            <summary> One or more items were removed from the collection. </summary>
        </member>
        <member name="F:PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction.Replace">
            <summary> One or more items were replaced in the collection. </summary>
        </member>
        <member name="F:PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction.Move">
            <summary> One or more items were moved within the collection. </summary>
        </member>
        <member name="F:PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction.Reset">
            <summary> The contents of the collection changed dramatically. </summary>
        </member>
        <member name="T:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs">
            <summary>
            Arguments for the CollectionChanged event.
            A collection that supports INotifyCollectionChangedThis raises this event
            whenever an item is added or removed, or when the contents of the collection
            changes dramatically.
            </summary>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a reset change.
            </summary>
            <param name="action">The action that caused the event (must be Reset).</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Object)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a one-item change.
            </summary>
            <param name="action">The action that caused the event; can only be Reset, Add or Remove action.</param>
            <param name="changedItem">The item affected by the change.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Object,System.Int32)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a one-item change.
            </summary>
            <param name="action">The action that caused the event.</param>
            <param name="changedItem">The item affected by the change.</param>
            <param name="index">The index where the change occurred.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a multi-item change.
            </summary>
            <param name="action">The action that caused the event.</param>
            <param name="changedItems">The items affected by the change.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList,System.Int32)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a multi-item change (or a reset).
            </summary>
            <param name="action">The action that caused the event.</param>
            <param name="changedItems">The items affected by the change.</param>
            <param name="startingIndex">The index where the change occurred.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Object,System.Object)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a one-item Replace event.
            </summary>
            <param name="action">Can only be a Replace action.</param>
            <param name="newItem">The new item replacing the original item.</param>
            <param name="oldItem">The original item that is replaced.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Object,System.Object,System.Int32)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a one-item Replace event.
            </summary>
            <param name="action">Can only be a Replace action.</param>
            <param name="newItem">The new item replacing the original item.</param>
            <param name="oldItem">The original item that is replaced.</param>
            <param name="index">The index of the item being replaced.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList,System.Collections.IList)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a multi-item Replace event.
            </summary>
            <param name="action">Can only be a Replace action.</param>
            <param name="newItems">The new items replacing the original items.</param>
            <param name="oldItems">The original items that are replaced.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList,System.Collections.IList,System.Int32)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a multi-item Replace event.
            </summary>
            <param name="action">Can only be a Replace action.</param>
            <param name="newItems">The new items replacing the original items.</param>
            <param name="oldItems">The original items that are replaced.</param>
            <param name="startingIndex">The starting index of the items being replaced.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Object,System.Int32,System.Int32)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a one-item Move event.
            </summary>
            <param name="action">Can only be a Move action.</param>
            <param name="changedItem">The item affected by the change.</param>
            <param name="index">The new index for the changed item.</param>
            <param name="oldIndex">The old index for the changed item.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList,System.Int32,System.Int32)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a multi-item Move event.
            </summary>
            <param name="action">The action that caused the event.</param>
            <param name="changedItems">The items affected by the change.</param>
            <param name="index">The new index for the changed items.</param>
            <param name="oldIndex">The old index for the changed items.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList,System.Collections.IList,System.Int32,System.Int32)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs with given fields (no validation). Used by WinRT marshaling.
            </summary>
        </member>
        <member name="P:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.Action">
            <summary>
            The action that caused the event.
            </summary>
        </member>
        <member name="P:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.NewItems">
            <summary>
            The items affected by the change.
            </summary>
        </member>
        <member name="P:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.OldItems">
            <summary>
            The old items affected by the change (for Replace events).
            </summary>
        </member>
        <member name="P:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.NewStartingIndex">
            <summary>
            The index where the change occurred.
            </summary>
        </member>
        <member name="P:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.OldStartingIndex">
            <summary>
            The old index where the change occurred (for Move events).
            </summary>
        </member>
        <member name="T:UnitySourceGeneratedAssemblyMonoScriptTypes_v1.MonoScriptData">
            <summary>
            Data is UTF-8 encoded strings
            </summary>
        </member>
    </members>
</doc>
